<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>集合 | Uncle He</title><meta name="description" content="集合概述不管是哪一种数据结构，其实本质上都是容器来着，就是用来装对象的。因此，我们就要搞清楚两点：（1）如何存储（2）存储特点 数据结构：存储数据的某种结构 （1）底层的物理结构 ​        ①数组：开辟连续的存储空间，每一个元素使用[下标]进行区别 ​        ②链式：不需要开辟连续的存储空间，但是需要“结点”来包装要存储的数据，结点包含两部分内容： ​            A、数"><meta name="keywords" content="集合"><meta name="author" content="Uncle He"><meta name="copyright" content="Uncle He"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="集合"><meta name="twitter:description" content="集合概述不管是哪一种数据结构，其实本质上都是容器来着，就是用来装对象的。因此，我们就要搞清楚两点：（1）如何存储（2）存储特点 数据结构：存储数据的某种结构 （1）底层的物理结构 ​        ①数组：开辟连续的存储空间，每一个元素使用[下标]进行区别 ​        ②链式：不需要开辟连续的存储空间，但是需要“结点”来包装要存储的数据，结点包含两部分内容： ​            A、数"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/java.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="集合"><meta property="og:url" content="https://www.unclehe.net/2020/06/19/java-collection/"><meta property="og:site_name" content="Uncle He"><meta property="og:description" content="集合概述不管是哪一种数据结构，其实本质上都是容器来着，就是用来装对象的。因此，我们就要搞清楚两点：（1）如何存储（2）存储特点 数据结构：存储数据的某种结构 （1）底层的物理结构 ​        ①数组：开辟连续的存储空间，每一个元素使用[下标]进行区别 ​        ②链式：不需要开辟连续的存储空间，但是需要“结点”来包装要存储的数据，结点包含两部分内容： ​            A、数"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/java.jpeg"><meta property="article:published_time" content="2020-06-19T01:05:10.000Z"><meta property="article:modified_time" content="2020-06-21T09:53:57.312Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://www.unclehe.net/2020/06/19/java-collection/"><link rel="prev" title="泛型" href="https://www.unclehe.net/2020/06/20/java-%3CT%3E/"><link rel="next" title="常用类" href="https://www.unclehe.net/2020/06/17/java-common-class/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://unclehe.net/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: Uncle He","link":"链接: ","source":"来源: Uncle He","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"top-right"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'true',
  isFontAwesomeV5: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/css/customcss.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="https://unclehe.gitee.io" target="_blank" rel="noopener"><i class="fa-fw fa fa-toolbox"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#集合概述"><span class="toc-number">1.</span> <span class="toc-text">集合概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">1.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合"><span class="toc-number">1.2.</span> <span class="toc-text">集合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#手动实现一些逻辑结构"><span class="toc-number">2.</span> <span class="toc-text">手动实现一些逻辑结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Collection接口"><span class="toc-number">3.</span> <span class="toc-text">Collection接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection系列的集合的遍历"><span class="toc-number">3.1.</span> <span class="toc-text">Collection系列的集合的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator迭代器遍历"><span class="toc-number">3.2.</span> <span class="toc-text">Iterator迭代器遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#List集合"><span class="toc-number">4.</span> <span class="toc-text">List集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#List接口常用方法"><span class="toc-number">4.1.</span> <span class="toc-text">List接口常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口的实现类"><span class="toc-number">4.2.</span> <span class="toc-text">接口的实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList与Vector的区别？"><span class="toc-number">4.2.1.</span> <span class="toc-text">ArrayList与Vector的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector与Stack的区别与联系？"><span class="toc-number">4.2.2.</span> <span class="toc-text">Vector与Stack的区别与联系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList类"><span class="toc-number">4.2.3.</span> <span class="toc-text">LinkedList类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List集合的遍历"><span class="toc-number">4.3.</span> <span class="toc-text">List集合的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#普通for循环遍历"><span class="toc-number">4.3.1.</span> <span class="toc-text">普通for循环遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ListIterator迭代器"><span class="toc-number">4.3.2.</span> <span class="toc-text">ListIterator迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#源码分析"><span class="toc-number">4.4.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector"><span class="toc-number">4.4.1.</span> <span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList源码分析"><span class="toc-number">4.4.2.</span> <span class="toc-text">ArrayList源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList源码分析"><span class="toc-number">4.4.3.</span> <span class="toc-text">LinkedList源码分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Set集合"><span class="toc-number">5.</span> <span class="toc-text">Set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#实现类的特点"><span class="toc-number">5.1.</span> <span class="toc-text">实现类的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet和LinkedHashSet"><span class="toc-number">5.1.1.</span> <span class="toc-text">HashSet和LinkedHashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet"><span class="toc-number">5.1.2.</span> <span class="toc-text">TreeSet</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Map集合"><span class="toc-number">6.</span> <span class="toc-text">Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Map的方法"><span class="toc-number">6.1.</span> <span class="toc-text">Map的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map的遍历"><span class="toc-number">6.2.</span> <span class="toc-text">Map的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map的实现类们的区别"><span class="toc-number">6.3.</span> <span class="toc-text">Map的实现类们的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap源码分析"><span class="toc-number">6.4.</span> <span class="toc-text">HashMap源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-6源码："><span class="toc-number">6.4.1.</span> <span class="toc-text">JDK1.6源码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-7源码："><span class="toc-number">6.4.2.</span> <span class="toc-text">JDK1.7源码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK1-8源码"><span class="toc-number">6.4.3.</span> <span class="toc-text">JDK1.8源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于HashMap的面试问题"><span class="toc-number">6.4.4.</span> <span class="toc-text">关于HashMap的面试问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#集合框架图"><span class="toc-number">7.</span> <span class="toc-text">集合框架图</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/java.jpeg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Uncle He</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="https://unclehe.gitee.io" target="_blank" rel="noopener"><i class="fa-fw fa fa-toolbox"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">集合</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-19 09:05:10"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-06-19</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-21 17:53:57"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-21</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%87%AA%E5%AD%A6Java/">自学Java</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%87%AA%E5%AD%A6Java/%E9%9B%86%E5%90%88/">集合</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon far fa-file-word" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">14.8k</span><span class="post-meta__separator">|</span><i class="post-meta__icon far fa-clock" aria-hidden="true"></i><span>阅读时长: 57 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon far fa-comments" aria-hidden="true"></i><span>评论数:</span><a href="/2020/06/19/java-collection/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/06/19/java-collection/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h1><p>不管是哪一种数据结构，其实本质上都是容器来着，就是用来装对象的。因此，我们就要搞清楚两点：（1）如何存储（2）存储特点</p>
<p>数据结构：存储数据的某种结构</p>
<p>（1）底层的物理结构</p>
<p>​        ①数组：开辟连续的存储空间，每一个元素使用[下标]进行区别</p>
<p>​        ②链式：不需要开辟连续的存储空间，但是需要“结点”来包装要存储的数据，结点包含两部分内容：</p>
<p>​            A、数据</p>
<p>​            B、记录其他结点的地址，例如：next，pre，left，right，parent等</p>
<p>（2）表现出来的逻辑结构：动态数组、单向链表、双向链表、队列、栈、二叉树、哈希表、图等</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p>逻辑结构：线性的</p>
</li>
<li><p>物理结构：顺序的存储结构</p>
</li>
<li><p>申请内存：一次申请一大段连续的空间，一旦申请到了，内存就固定了。</p>
</li>
<li><p>存储特点：所有数据存储在这个连续的空间中，数组中的每一个元素都是一个具体的数据（或对象），所有数据都紧密排布，不能有间隔。</p>
</li>
</ul>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection1.png" alt="Collection"></p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection2.png" alt="Collection"></p>
<ul>
<li><p>操作</p>
<ul>
<li>查询：每一个元素都有一个数值下标，可以通过下标瞬间定位到某个元素</li>
<li>增加：<ul>
<li>先使用total变量辅助记录实际存储元素个数</li>
<li>从尾部增加：数组名[total++]=新元素</li>
<li>从其他位置插入：先把index位置开始所有元素后移，然后数组名[index]=新元素</li>
</ul>
</li>
<li>删除：先把index后面的元素前移，然后数组名[total–] = null</li>
<li>改：直接数组名[index]=新元素</li>
</ul>
</li>
<li><p>优缺点</p>
<ul>
<li>优点：按索引查询效率高</li>
<li>缺点：添加/删除效率低，因为都涉及到移动元素；无法直接获取有效元素的个数，需要total来辅助</li>
</ul>
</li>
</ul>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection3.png" alt="Collection"></p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection4.png" alt="Collection"></p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>为了可以满足用户数据更多种的逻辑关系，而设计的一系列的不同于数组的可变的聚合的抽象数据类型。这些接口和类在java.util包中，因为类型很丰富，因此我们通常称为集合框架集</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection5.png" alt="Collection"></p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection6.png" alt="Collection"></p>
<ul>
<li>Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何直接实现：它提供更具体的子接口（如 Set 和 List、Queue）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。<ul>
<li>List：有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。</li>
<li>Queue：队列通常（但并非一定）以 FIFO（先进先出）的方式排序各个元素。不过优先级队列和 LIFO 队列（或堆栈）例外，前者根据提供的比较器或元素的自然顺序对元素进行排序，后者按 LIFO（后进先出）的方式对元素进行排序。</li>
<li>Set：一个不包含重复元素的 collection。更确切地讲，set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2，并且最多包含一个 null 元素。正如其名称所暗示的，此接口模仿了数学上的 set 抽象。<ul>
<li>SortedSet进一步提供关于元素的总体排序 的 Set。这些元素使用其自然顺序进行排序，或者根据通常在创建有序 set 时提供的 Comparator进行排序。该 set 的迭代器将按元素升序遍历 set。提供了一些附加的操作来利用这种排序。</li>
</ul>
</li>
</ul>
</li>
<li>Map：将键映射到值(key,value)的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。映射顺序 定义为迭代器在映射的 collection 视图上返回其元素的顺序。某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap 类。<ul>
<li>SortedMap进一步提供关于键的总体排序 的 Map。该映射是根据其键的自然顺序进行排序的，或者根据通常在创建有序映射时提供的 Comparator 进行排序。</li>
</ul>
</li>
</ul>
<h1 id="手动实现一些逻辑结构"><a href="#手动实现一些逻辑结构" class="headerlink" title="手动实现一些逻辑结构"></a>手动实现一些逻辑结构</h1><p>1、动态数组</p>
<p>包含：</p>
<p>（1）内部使用一个数组，用来存储数据</p>
<p>（2）内部使用一个total，记录实际存储的元素的个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span> </span>&#123;</span><br><span class="line">	<span class="comment">//为什么使用Object，因为只是说这个容器是用来装对象的，但是不知道用来装什么对象。</span></span><br><span class="line">	<span class="keyword">private</span> Object[] data;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyArrayList</span><span class="params">()</span></span>&#123;</span><br><span class="line">		data = <span class="keyword">new</span> Object[<span class="number">5</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加一个元素</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="comment">//检查是否需要扩容</span></span><br><span class="line">		checkCapacity();</span><br><span class="line">		data[total++] = obj;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//如果data满了，就扩容为原来的2倍</span></span><br><span class="line">		<span class="keyword">if</span>(total &gt;= data.length)&#123;</span><br><span class="line">			data = Arrays.copyOf(data, data.length*<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回实际元素的个数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回数组的实际容量</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data.length;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取[index]位置的元素</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">		<span class="comment">//校验index的合理性范围</span></span><br><span class="line">		checkIndex(index);</span><br><span class="line">		<span class="keyword">return</span> data[index];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=total)&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(index+<span class="string">"对应位置的元素不存在"</span>);</span><br><span class="line"><span class="comment">//			throw new IndexOutOfBoundsException(index+"越界");</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//替换[index]位置的元素</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Object value)</span></span>&#123;</span><br><span class="line">		<span class="comment">//校验index的合理性范围</span></span><br><span class="line">		checkIndex(index);</span><br><span class="line">		</span><br><span class="line">		data[index] = value;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//在[index]位置插入一个元素value</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, Object value)</span></span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * (1)考虑下标的合理性</span></span><br><span class="line"><span class="comment">		 * (2)总长度是否够</span></span><br><span class="line"><span class="comment">		 * (3)[index]以及后面的元素往后移动，把[index]位置腾出来</span></span><br><span class="line"><span class="comment">		 * (4)data[index]=value  放入新元素</span></span><br><span class="line"><span class="comment">		 * (5)total++  有效元素的个数增加</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(1)考虑下标的合理性：校验index的合理性范围</span></span><br><span class="line">		checkIndex(index);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(2)总长度是否够：检查是否需要扩容</span></span><br><span class="line">		checkCapacity();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(3)[index]以及后面的元素往后移动，把[index]位置腾出来</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 假设total = 5, data.length= 10, index= 1</span></span><br><span class="line"><span class="comment">		 * 有效元素的下标[0,4]</span></span><br><span class="line"><span class="comment">		 * 移动：[1]-&gt;[2],[2]-&gt;[3],[3]-&gt;[4],[4]-&gt;[5]</span></span><br><span class="line"><span class="comment">		 * 移动元素的个数：total-index</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		System.arraycopy(data, index, data, index+<span class="number">1</span>, total-index);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(4)data[index]=value  放入新元素</span></span><br><span class="line">		data[index] = value;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(5)total++  有效元素的个数增加</span></span><br><span class="line">		total++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回所有实际存储的元素</span></span><br><span class="line">	<span class="keyword">public</span> Object[] getAll()&#123;</span><br><span class="line">		<span class="comment">//返回total个</span></span><br><span class="line">		<span class="keyword">return</span> Arrays.copyOf(data, total);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//删除[index]位置的元素</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * (1)校验index的合理性范围</span></span><br><span class="line"><span class="comment">		 * (2)移动元素，把[index+1]以及后面的元素往前移动</span></span><br><span class="line"><span class="comment">		 * (3)把data[total-1]=null  让垃圾回收器尽快回收</span></span><br><span class="line"><span class="comment">		 * (4)总元素个数减少 total--</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(1)考虑下标的合理性：校验index的合理性范围</span></span><br><span class="line">		checkIndex(index);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(2)移动元素，把[index+1]以及后面的元素往前移动</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 假设total=8, data.length=10, index = 3</span></span><br><span class="line"><span class="comment">		 * 有效元素的范围[0,7]</span></span><br><span class="line"><span class="comment">		 * 移动：[4]-&gt;[3],[5]-&gt;[4],[6]-&gt;[5],[7]-&gt;[6]</span></span><br><span class="line"><span class="comment">		 * 移动了4个：total-index-1</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		System.arraycopy(data, index+<span class="number">1</span>, data, index, total-index-<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(3)把data[total-1]=null  让垃圾回收器尽快回收</span></span><br><span class="line">		data[total-<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		(4)总元素个数减少 total--</span></span><br><span class="line">		total--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查询某个元素的下标</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(data[i] == <span class="keyword">null</span>)&#123;<span class="comment">//等价于 if(data[i] == obj)</span></span><br><span class="line">					<span class="keyword">return</span> i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(obj.equals(data[i]))&#123;</span><br><span class="line">					<span class="keyword">return</span> i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//删除数组中的某个元素</span></span><br><span class="line">	<span class="comment">//如果有重复的，只删除第一个</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * (1)先查询obj的[index]</span></span><br><span class="line"><span class="comment">		 * (2)如果存在，就调用remove(index)删除就可以</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(1)先查询obj的[index]</span></span><br><span class="line">		<span class="keyword">int</span> index = indexOf(obj);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(index != -<span class="number">1</span>)&#123;</span><br><span class="line">			remove(index);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//不存在，可以什么也不做</span></span><br><span class="line">		<span class="comment">//不存在，也可以抛异常</span></span><br><span class="line">		<span class="comment">//throw new RuntimeException(obj + "不存在");</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object old, Object value)</span></span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * (1)查询old的[index]</span></span><br><span class="line"><span class="comment">		 * (2)如果存在，就调用set(index, value)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">//		(1)查询old的[index]</span></span><br><span class="line">		<span class="keyword">int</span> index = indexOf(old);</span><br><span class="line">		<span class="keyword">if</span>(index!=-<span class="number">1</span>)&#123;</span><br><span class="line">			set(index, value);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//不存在，可以什么也不做</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、单向链表</p>
<p>包含：</p>
<p>（1）包含一个Node类型的成员变量first：用来记录第一个结点的地址</p>
<p>​        如果这个链表是空的，还没有任何结点，那么first是null。</p>
<p>​        最后一个结点的特征：就是它的next是null</p>
<p>（2）内部使用一个total，记录实际存储的元素的个数</p>
<p>（3）使用了一个内部类Node</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里不需要数组，不需要其他的复杂的结构，我只要记录单向链表的“头”结点</span></span><br><span class="line">	<span class="keyword">private</span> Node first;<span class="comment">//first中记录的是第一个结点的地址</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total;<span class="comment">//这里我记录total是为了后面处理的方便，例如：当用户获取链表有效元素的个数时，不用现数，而是直接返回total等</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 内部类，因为这种Node结点的类型，在别的地方没有用，只在单向链表中，用于存储和表示它的结点关系。</span></span><br><span class="line"><span class="comment">	 * 因为我这里涉及为内部类型。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">		Object data;<span class="comment">//因为数据可以是任意类型的对象，所以设计为Object</span></span><br><span class="line">		Node next;<span class="comment">//因为next中记录的下一个结点的地址，因此类型是结点类型</span></span><br><span class="line">		<span class="comment">//这里data,next没有私有化，是希望在外部类中可以不需要get/set，而是直接“结点对象.data","结点对象.next"使用</span></span><br><span class="line">		Node(Object data, Node next)&#123;</span><br><span class="line">			<span class="keyword">this</span>.data = data;</span><br><span class="line">			<span class="keyword">this</span>.next = next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * (1)把obj的数据，包装成一个Node类型结点对象</span></span><br><span class="line"><span class="comment">		 * (2)把新结点“链接”当前链表的最后</span></span><br><span class="line"><span class="comment">		 * ①当前新结点是第一个结点</span></span><br><span class="line"><span class="comment">		 * 如何判断是否是第一个   if(first==null)说明暂时还没有第一个</span></span><br><span class="line"><span class="comment">		 * ②先找到目前的最后一个，把新结点链接到它的next中</span></span><br><span class="line"><span class="comment">		 * 如何判断是否是最后一个   if(某个结点.next == null)说明这个结点是最后一个</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"><span class="comment">//		(1)把obj的数据，包装成一个Node类型结点对象</span></span><br><span class="line">		<span class="comment">//这里新结点的next赋值为null，表示新结点是最后一个结点</span></span><br><span class="line">		Node newNode = <span class="keyword">new</span> Node(obj, <span class="keyword">null</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//①当前新结点是第一个结点</span></span><br><span class="line">		<span class="keyword">if</span>(first == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//说明newNode是第一个</span></span><br><span class="line">			first = newNode;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//②先找到目前的最后一个，把新结点链接到它的next中</span></span><br><span class="line">			Node node = first;</span><br><span class="line">			<span class="keyword">while</span>(node.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">				node = node.next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//退出循环时node指向最后一个结点</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//把新结点链接到它的next中</span></span><br><span class="line">			node.next = newNode;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		total++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> Object[] getAll()&#123;</span><br><span class="line">		<span class="comment">//(1)创建一个数组，长度为total</span></span><br><span class="line">		Object[] all = <span class="keyword">new</span> Object[total];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(2)把单向链表的每一个结点中的data，拿过来放到all数组中</span></span><br><span class="line">		Node node = first;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line"><span class="comment">//			all[i] = 结点.data;</span></span><br><span class="line">			all[i] = node.data;</span><br><span class="line">			<span class="comment">//然后node指向下一个</span></span><br><span class="line">			node = node.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//(3)返回数组</span></span><br><span class="line">		<span class="keyword">return</span> all;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//(1)先考虑是否是第一个</span></span><br><span class="line">			<span class="keyword">if</span>(first!=<span class="keyword">null</span>)&#123;<span class="comment">//链表非空</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">//要删除的结点正好是第一个结点</span></span><br><span class="line">				<span class="keyword">if</span>(first.data == <span class="keyword">null</span>)&#123;</span><br><span class="line">					<span class="comment">//让第一个结点指向它的下一个</span></span><br><span class="line">					first = first.next;</span><br><span class="line">					total--;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//要删除的不是第一个结点</span></span><br><span class="line">				Node node = first.next;<span class="comment">//第二个结点</span></span><br><span class="line">				Node last = first;</span><br><span class="line">				<span class="keyword">while</span>(node.next!=<span class="keyword">null</span>)&#123;<span class="comment">//这里不包括最后一个，因为node.next==null，不进入循环，而node.next==null是最后一个</span></span><br><span class="line">					<span class="keyword">if</span>(node.data == <span class="keyword">null</span>)&#123;</span><br><span class="line">						last.next = node.next;</span><br><span class="line">						total--;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					last = node;</span><br><span class="line">					node = node.next;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//单独判断最后一个是否是要删除的结点</span></span><br><span class="line">				<span class="keyword">if</span>(node.data == <span class="keyword">null</span>)&#123;</span><br><span class="line">					<span class="comment">//要删除的是最后一个结点</span></span><br><span class="line">					last.next = <span class="keyword">null</span>;</span><br><span class="line">					total--;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//(1)先考虑是否是第一个</span></span><br><span class="line">			<span class="keyword">if</span>(first!=<span class="keyword">null</span>)&#123;<span class="comment">//链表非空</span></span><br><span class="line">				</span><br><span class="line">				<span class="comment">//要删除的结点正好是第一个结点</span></span><br><span class="line">				<span class="keyword">if</span>(obj.equals(first.data))&#123;</span><br><span class="line">					<span class="comment">//让第一个结点指向它的下一个</span></span><br><span class="line">					first = first.next;</span><br><span class="line">					total--;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//要删除的不是第一个结点</span></span><br><span class="line">				Node node = first.next;<span class="comment">//第二个结点</span></span><br><span class="line">				Node last = first;</span><br><span class="line">				<span class="keyword">while</span>(node.next!=<span class="keyword">null</span>)&#123;<span class="comment">//这里不包括最后一个，因为node.next==null，不进入循环，而node.next==null是最后一个</span></span><br><span class="line">					<span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line">						last.next = node.next;</span><br><span class="line">						total--;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					last = node;</span><br><span class="line">					node = node.next;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//单独判断最后一个是否是要删除的结点</span></span><br><span class="line">				<span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line">					<span class="comment">//要删除的是最后一个结点</span></span><br><span class="line">					last.next = <span class="keyword">null</span>;</span><br><span class="line">					total--;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">			Node node = first;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(node.data == <span class="keyword">null</span>)&#123;</span><br><span class="line">					<span class="keyword">return</span> i;</span><br><span class="line">				&#125;</span><br><span class="line">				node = node.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			Node node = first;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line">					<span class="keyword">return</span> i;</span><br><span class="line">				&#125;</span><br><span class="line">				node = node.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><p>因为集合的类型很多，那么我们把它们称为集合框架。</p>
<p>集合框架分为两个家族：Collection（一组对象）和Map（一组映射关系、一组键值对）</p>
<p>Collection是代表一种对象的集合。它是Collection系列的根接口。</p>
<p>它们虽然：有些可能是有序的，有些可能是无序的，有些可能可以重复的，有些不能重复的，但是它们有共同的操作规范，因此这些操作的规范就抽象为了Collection接口。</p>
<p><strong>常用方法：</strong></p>
<ul>
<li><p>boolean add(Object obj)：添加一个</p>
</li>
<li><p>boolean addAll（Collection c）：添加多个</p>
</li>
<li><p>boolean remove(Object obj)：删除一个</p>
</li>
<li><p>boolean removeAll(Collection c )： 删除多个</p>
</li>
<li><p>boolean contains(Object c)：是否包含某个</p>
</li>
<li><p>boolean containsAll(Collection c)： 是否包含所有</p>
</li>
<li><p>boolean isEmpty()：是否为空</p>
</li>
<li><p>int size()：获取元素个数</p>
</li>
<li><p>void clear()：清空集合</p>
</li>
<li><p>Object[] toArray()：获取所有元素</p>
</li>
<li><p>Iterator iterator()： 获取遍历当前集合的迭代器对象</p>
</li>
<li><p>retainAll(Collection c)：求当前集合与c集合的交集</p>
</li>
</ul>
<h2 id="Collection系列的集合的遍历"><a href="#Collection系列的集合的遍历" class="headerlink" title="Collection系列的集合的遍历"></a>Collection系列的集合的遍历</h2><p>1、明确使用Iterator迭代器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection c = ....;</span><br><span class="line"></span><br><span class="line">Iterator iter = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hashNext())&#123;</span><br><span class="line">    Object obj = iter.next();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterator 接口的方法：</p>
<p>（1）boolean hasNext()</p>
<p>（2）Object next()</p>
<p>（3）void remove()</p>
<p>2、foreach</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Collection c &#x3D; ....;</span><br><span class="line"></span><br><span class="line">for(Object  obj :  c)&#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么样的集合（容器）能够使用foreach遍历？</p>
<p>（1）数组：</p>
<p>（2）实现了java.lang.Iterable接口</p>
<p>这个接口有一个抽象方法：Iterator iterator()</p>
<p>Iterator也是一个接口，它的实现类，通常在集合（容器）类中用内部类实现。并在iterator()的方法中创建它的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span> <span class="keyword">implements</span> <span class="title">Iterable</span></span>&#123;</span><br><span class="line">	<span class="comment">//为什么使用Object，因为只是说这个容器是用来装对象的，但是不知道用来装什么对象。</span></span><br><span class="line">	<span class="keyword">private</span> Object[] data;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//其他代码省略....</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyItr();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyItr</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> cursor;<span class="comment">//游标</span></span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> cursor!=total;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> data[cursor++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>思考：如果遍历数组，什么情况下选用foreach，什么情况下选用for循环？</p>
<p>当如果你的操作中涉及到[下标]操作时，用for最好。</p>
<p>当你只是查看元素的内容，那么选foreach更简洁一些。</p>
<p>思考：如果遍历Collection系列集合，什么情况下选用foreach，是否能选用for循环？</p>
<p>首先考虑使用foreach，如果该集合也有索引信息的话，也可以通过for来操作，如果没有下标的信息，就不要用for。即，如果该集合的物理结构是数组的，那么可以用for，如果物理结构是链式，那么使用下标操作效率很低。</p>
<p>思考：如果遍历Collection系列集合，什么情况下选用foreach，什么情况下使用Iterator？</p>
<p>如果只是查看集合的元素，使用foreach，代码会更简洁。</p>
<p>但是如果要涉及到在遍历集合的同时根据某种条件要删除元素等操作，那么选用Iterator。</p>
<h2 id="Iterator迭代器遍历"><a href="#Iterator迭代器遍历" class="headerlink" title="Iterator迭代器遍历"></a>Iterator迭代器遍历</h2><p>因为Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，该对象可以用于迭代集合中的元素。</p>
<ul>
<li>Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建 Iterator 对象，则必须有一个被迭代的集合。</li>
<li>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素位置。</li>
</ul>
<p><strong>常用方法</strong></p>
<ul>
<li>boolean hasNext()：如果仍有元素可以迭代，则返回 true</li>
<li>Object next()：返回迭代的下一个元素。</li>
<li>void remove()：从迭代器指向的 collection 中移除迭代器返回的最后一个元素（可选操作）</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>建议在调用it.next()方法之前调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。</li>
<li>如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException</li>
</ul>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection8.png" alt="Collection"></p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection9.png" alt="Collection"></p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection10.png" alt="Collection"></p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection11.png" alt="Collection"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  c.add(<span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">"张三"</span>));</span><br><span class="line">  c.add(<span class="keyword">new</span> Student(<span class="number">2</span>,<span class="string">"李四"</span>));</span><br><span class="line">  c.add(<span class="keyword">new</span> Student(<span class="number">3</span>,<span class="string">"王五"</span>));</span><br><span class="line">  c.add(<span class="keyword">new</span> Student(<span class="number">4</span>,<span class="string">"赵六"</span>));</span><br><span class="line">  c.add(<span class="keyword">new</span> Student(<span class="number">5</span>,<span class="string">"钱七"</span>));</span><br><span class="line"></span><br><span class="line">  Iterator iterator = c.iterator();</span><br><span class="line">  <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    Student next = (Student) iterator.next();</span><br><span class="line">    <span class="comment">//例如：要删除学号为1的学生对象</span></span><br><span class="line">    <span class="keyword">if</span>(next.getId()==<span class="number">1</span>)&#123;</span><br><span class="line">      iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h1><p>List集合类中元素有序、且可重复。这就像银行门口客服，给每一个来办理业务的客户分配序号：第一个来的是“张三”，客服给他分配的是0；第二个来的是“李四”，客服给他分配的1；以此类推，最后一个序号应该是“总人数-1”。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/list.png" alt="list"></p>
<p>List：是Collection的子接口。</p>
<p>List系列的集合：有序的、可重复的</p>
<p>List系列的常用集合：ArrayList、Vector、LinkedList、Stack</p>
<p><strong>注意</strong></p>
<p>在JavaSE中List名称的类型有两个，一个是java.util.List集合接口，一个是java.awt.List图形界面的组件，别导错包了。</p>
<p>List集合关心元素是否有序，而不关心是否重复，请大家记住这个原则。例如“张三”可以领取两个号。</p>
<h2 id="List接口常用方法"><a href="#List接口常用方法" class="headerlink" title="List接口常用方法"></a>List接口常用方法</h2><ul>
<li><p>boolean add(Object obj)：添加一个</p>
</li>
<li><p>boolean addAll（Collection c）：添加多个</p>
</li>
<li><p>void add(int index, Object obj)：添加一个，指定位置添加</p>
</li>
<li><p>void addAll(int index, Collection c）：添加多个</p>
</li>
<li><p>boolean remove(Object obj)：删除一个</p>
</li>
<li><p>Object remove(int index)：删除指定位置的元素，并返回刚刚删除的元素</p>
</li>
<li><p>boolean removeAll(Collection c )： 删除多个</p>
</li>
<li><p>boolean contains(Object c)：是否包含某个</p>
</li>
<li><p>boolean containsAll(Collection c)： 是否包含所有</p>
</li>
<li><p>boolean isEmpty()：是否为空</p>
</li>
<li><p>int size()：获取元素个数</p>
</li>
<li><p>void clear()：清空集合</p>
</li>
<li><p>Object[] toArray()：获取所有元素</p>
</li>
<li><p>Iterator iterator()： 获取遍历当前集合的迭代器对象</p>
</li>
<li><p>retainAll(Collection c)：求当前集合与c集合的交集</p>
</li>
<li><p>ListIterator listIterator()：获取遍历当前集合的迭代器对象，这个迭代器可以往前、往后遍历</p>
</li>
<li><p>ListIterator listIterator(int index)：从[index]位置开始，往前或往后遍历</p>
</li>
<li><p>Object get(int index)：返回index位置的元素</p>
</li>
<li><p>List  subList(int start, int end)：截取[start,end)部分的子列表</p>
</li>
</ul>
<h2 id="接口的实现类"><a href="#接口的实现类" class="headerlink" title="接口的实现类"></a>接口的实现类</h2><p>Vector 类：动态数组</p>
<p>ArrayList类：动态数组</p>
<p>Stack类：堆栈</p>
<p>LinkedList：双向链表，从JDK1.6之后又实现了双端队列</p>
<h3 id="ArrayList与Vector的区别？"><a href="#ArrayList与Vector的区别？" class="headerlink" title="ArrayList与Vector的区别？"></a>ArrayList与Vector的区别？</h3><p>它们的底层物理结构都是数组，我们称为动态数组。</p>
<ul>
<li>ArrayList是新版的动态数组，线程不安全，效率高，Vector是旧版的动态数组，线程安全，效率低。</li>
<li>动态数组的扩容机制不同，ArrayList扩容为原来的1.5倍，Vector扩容增加为原来的2倍。</li>
<li>数组的初始化容量，如果在构建ArrayList与Vector的集合对象时，没有显式指定初始化容量，那么Vector的内部数组的初始容量默认为10，而ArrayList在JDK1.6及之前的版本也是10，而JDK1.7之后的版本ArrayList初始化为长度为0的空数组，之后在添加第一个元素时，再创建长度为10的数组。</li>
<li>Vector因为版本古老，支持Enumeration 迭代器。但是该迭代器不支持快速失败。而Iterator和ListIterator迭代器支持快速失败。如果在迭代器创建后的任意时间从结构上修改了向量（通过迭代器自身的 remove 或 add 方法之外的任何其他方式），则迭代器将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就完全失败，而不是冒着在将来不确定的时间任意发生不确定行为的风险。</li>
</ul>
<p><strong>提示：</strong>在List列表集合实现中都有一个变量modCount，每次添加、删除都会使得modCount变量增加，因此用foreach和Iterator迭代时，如果再通过集合的add和remove等方法修改集合，会抛出 ConcurrentModificationException。</p>
<h3 id="Vector与Stack的区别与联系？"><a href="#Vector与Stack的区别与联系？" class="headerlink" title="Vector与Stack的区别与联系？"></a>Vector与Stack的区别与联系？</h3><p>Stack类是Vector的子类。</p>
<p>Stack类表示后进先出（LIFO）的对象堆栈。它通过五个操作对类 Vector 进行了扩展 ，允许将向量视为堆栈。它提供了通常的 push 和 pop 操作，以及取堆栈顶点的 peek 方法、测试堆栈是否为空的 empty 方法、在堆栈中查找项并确定到堆栈顶距离的 search 方法。</p>
<h3 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h3><p>除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。</p>
<p>代码示例一：作为List的普通列表形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLinkedList</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		LinkedList list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">		list.add(<span class="number">1</span>);</span><br><span class="line">		list.add(<span class="number">2</span>);</span><br><span class="line">		list.add(<span class="number">3</span>);</span><br><span class="line">		list.add(<span class="number">4</span>);</span><br><span class="line">		list.add(<span class="number">5</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (Object object : list) &#123;</span><br><span class="line">			System.out.println(object);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.6之后LinkedList实现了Deque接口。双端队列也可用作 LIFO（后进先出）堆栈。如果要使用堆栈结构的集合，可以考虑使用LinkedList，而不是Stack。</p>
<table>
<thead>
<tr>
<th>堆栈方法</th>
<th>等效Deque方法</th>
</tr>
</thead>
<tbody><tr>
<td>push(e)</td>
<td>addFirst(e)</td>
</tr>
<tr>
<td>pop()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody></table>
<p>代码示例二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		LinkedList list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">		<span class="comment">//入栈</span></span><br><span class="line">		list.addFirst(<span class="number">1</span>);</span><br><span class="line">		list.addFirst(<span class="number">2</span>);</span><br><span class="line">		list.addFirst(<span class="number">3</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//出栈： LIFO（后进先出）</span></span><br><span class="line">		System.out.println(list.removeFirst());<span class="comment">//3</span></span><br><span class="line">		System.out.println(list.removeFirst());<span class="comment">//2</span></span><br><span class="line">		System.out.println(list.removeFirst());<span class="comment">//1</span></span><br><span class="line">		<span class="comment">//栈空了，会报异常java.util.NoSuchElementException</span></span><br><span class="line">		System.out.println(list.removeFirst());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用作队列时，将得到 FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。</p>
<table>
<thead>
<tr>
<th>Queue 方法</th>
<th>等效 Deque 方法</th>
</tr>
</thead>
<tbody><tr>
<td>add(e)</td>
<td>addLast(e)</td>
</tr>
<tr>
<td>offer(e)</td>
<td>offerLast(e)</td>
</tr>
<tr>
<td>remove()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>poll()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>element()</td>
<td>getFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody></table>
<p>代码示例三：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		LinkedList list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">		<span class="comment">//入队</span></span><br><span class="line">		list.addLast(<span class="number">1</span>);</span><br><span class="line">		list.addLast(<span class="number">2</span>);</span><br><span class="line">		list.addLast(<span class="number">3</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//出队， FIFO（先进先出）</span></span><br><span class="line">		System.out.println(list.pollFirst());<span class="comment">//1</span></span><br><span class="line">		System.out.println(list.pollFirst());<span class="comment">//2</span></span><br><span class="line">		System.out.println(list.pollFirst());<span class="comment">//3</span></span><br><span class="line">		<span class="comment">//队空了，返回null</span></span><br><span class="line">		System.out.println(list.pollFirst());<span class="comment">//null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。</p>
<table>
<thead>
<tr>
<th></th>
<th>第一个元素（头部）</th>
<th></th>
<th>最后一个元素（尾部）</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>抛出异常</td>
<td>特殊值</td>
<td>抛出异常</td>
<td>特殊值</td>
</tr>
<tr>
<td>插入</td>
<td>addFirst(e)</td>
<td>offerFirst(e)</td>
<td>addLast(e)</td>
<td>offerLast(e)</td>
</tr>
<tr>
<td>移除</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>检查</td>
<td>getFirst()</td>
<td>peekFirst()</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
<h2 id="List集合的遍历"><a href="#List集合的遍历" class="headerlink" title="List集合的遍历"></a>List集合的遍历</h2><h3 id="普通for循环遍历"><a href="#普通for循环遍历" class="headerlink" title="普通for循环遍历"></a>普通for循环遍历</h3><p>对于ArrayList和Vector这样的动态数组，也可以使用普通for循环进行遍历。</p>
<h3 id="ListIterator迭代器"><a href="#ListIterator迭代器" class="headerlink" title="ListIterator迭代器"></a>ListIterator迭代器</h3><p>List 集合额外提供了一个 listIterator() 方法，该方法返回一个 ListIterator 对象， ListIterator 接口继承了 Iterator 接口，提供了专门操作 List 的方法：</p>
<ul>
<li>void add()：通过迭代器添加元素到对应集合</li>
<li>void set(Object obj)：通过迭代器替换正迭代的元素</li>
<li>void remove()：通过迭代器删除刚迭代的元素</li>
</ul>
<ul>
<li>boolean hasPrevious()：如果以逆向遍历列表，往前是否还有元素。</li>
<li>Object previous()：返回列表中的前一个元素。</li>
<li>int previousIndex()：返回列表中的前一个元素的索引</li>
</ul>
<ul>
<li>boolean hasNext()</li>
<li>Object next()</li>
<li>int nextIndex()</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>(<span class="number">10</span>);<span class="comment">//指定初始容量initialCapacity为10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);<span class="comment">//指定capacityIncrement增量为0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement增量为<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  <span class="comment">//判断了形参初始容量initialCapacity的合法性</span></span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                       initialCapacity);</span><br><span class="line">  <span class="comment">//创建了一个Object[]类型的数组</span></span><br><span class="line">  <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];<span class="comment">//默认是10</span></span><br><span class="line">  <span class="comment">//增量，默认是0，如果是0，后面就按照2倍增加，如果不是0，后面就按照你指定的增量进行增量</span></span><br><span class="line">  <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//synchronized意味着线程安全的   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//看是否需要扩容</span></span><br><span class="line">  ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//把新的元素存入[elementCount]，存入后，elementCount元素的个数增1</span></span><br><span class="line">  elementData[elementCount++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="comment">//看是否超过了当前数组的容量</span></span><br><span class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    grow(minCapacity);<span class="comment">//扩容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//获取目前数组的长度</span></span><br><span class="line">  <span class="comment">//如果capacityIncrement增量是0，新容量 = oldCapacity的2倍</span></span><br><span class="line">  <span class="comment">//如果capacityIncrement增量是不是0，新容量 = oldCapacity + capacityIncrement增量;</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                   capacityIncrement : oldCapacity);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果按照上面计算的新容量还不够，就按照你指定的需要的最小容量来扩容minCapacity</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果新容量超过了最大数组限制，那么单独处理</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//把旧数组中的数据复制到新数组中，新数组的长度为newCapacity</span></span><br><span class="line">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> removeElement(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeElement</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//查找obj在当前Vector中的下标</span></span><br><span class="line">  <span class="keyword">int</span> i = indexOf(obj);</span><br><span class="line">  <span class="comment">//如果i&gt;=0，说明存在，删除[i]位置的元素</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    removeElementAt(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> indexOf(o, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;<span class="comment">//要查找的元素是null值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">      <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)<span class="comment">//如果是null值，用==null判断</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//要查找的元素是非null值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">      <span class="keyword">if</span> (o.equals(elementData[i]))<span class="comment">//如果是非null值，用equals判断</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//判断下标的合法性</span></span><br><span class="line">  <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">                                             elementCount);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//j是要移动的元素的个数</span></span><br><span class="line">  <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//如果需要移动元素，就调用System.arraycopy进行移动</span></span><br><span class="line">  <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//把index+1位置以及后面的元素往前移动</span></span><br><span class="line">    <span class="comment">//index+1的位置的元素移动到index位置，依次类推</span></span><br><span class="line">    <span class="comment">//一共移动j个</span></span><br><span class="line">    System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//元素的总个数减少</span></span><br><span class="line">  elementCount--;</span><br><span class="line">  <span class="comment">//将elementData[elementCount]这个位置置空，用来添加新元素，位置的元素等着被GC回收</span></span><br><span class="line">  elementData[elementCount] = <span class="keyword">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h3><p>JDK1.6：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="number">10</span>);<span class="comment">//指定初始容量为10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  <span class="comment">//检查初始容量的合法性</span></span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> + initialCapacity);</span><br><span class="line">  <span class="comment">//数组初始化为长度为initialCapacity的数组</span></span><br><span class="line">  <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.7</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;<span class="comment">//默认初始容量10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="comment">//数组初始化为一个空数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  elementData[size++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;<span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">    <span class="comment">//minCapacity按照 默认初始容量和minCapacity中的的最大值处理</span></span><br><span class="line">    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//看是否需要扩容处理</span></span><br><span class="line">  ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>JDK1.8</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<span class="comment">//初始化为空数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//存入新元素到[size]位置，然后size自增1</span></span><br><span class="line">  elementData[size++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">  <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    <span class="comment">//那么minCapacity取DEFAULT_CAPACITY与minCapacity的最大值</span></span><br><span class="line">    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//查看是否需要扩容</span></span><br><span class="line">  ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果需要的最小容量  比  当前数组的长度  大，即当前数组不够存，就扩容</span></span><br><span class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//当前数组容量</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//新数组容量是旧数组容量的1.5倍</span></span><br><span class="line">  <span class="comment">//看旧数组的1.5倍是否够</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line">  <span class="comment">//看旧数组的1.5倍是否超过最大数组限制</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//复制一个新数组</span></span><br><span class="line">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先找到o在当前ArrayList的数组中的下标</span></span><br><span class="line">  <span class="comment">//分o是否为空两种情况讨论</span></span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">      <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;<span class="comment">//null值用==比较</span></span><br><span class="line">        fastRemove(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">      <span class="keyword">if</span> (o.equals(elementData[index])) &#123;<span class="comment">//非null值用equals比较</span></span><br><span class="line">        fastRemove(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line">  <span class="comment">//需要移动的元素个数</span></span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                     numMoved);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">  modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被删除的元素，用于最后返回被删除的元素</span></span><br><span class="line">  E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//需要移动的元素个数</span></span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                     numMoved);</span><br><span class="line">  <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被替换的元素，用于最后返回被替换的元素</span></span><br><span class="line">  E oldValue = elementData(index);</span><br><span class="line">  <span class="comment">//用element替换[index]位置的元素</span></span><br><span class="line">  elementData[index] = element;</span><br><span class="line">  <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elementData(index);<span class="comment">//返回[index]位置的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//从前往后找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//从后往前找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">Node&lt;E&gt; first;<span class="comment">//记录第一个结点的位置</span></span><br><span class="line">Node&lt;E&gt; last;<span class="comment">//记录最后一个结点的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  E item;<span class="comment">//元素数据</span></span><br><span class="line">  Node&lt;E&gt; next;<span class="comment">//下一个结点</span></span><br><span class="line">  Node&lt;E&gt; prev;<span class="comment">//前一个结点</span></span><br><span class="line"></span><br><span class="line">  Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.item = element;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">    <span class="keyword">this</span>.prev = prev;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  linkLast(e);<span class="comment">//默认把新元素链接到链表尾部</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; l = last;<span class="comment">//用l 记录原来的最后一个结点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建新结点</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">//现在的新结点是最后一个结点了</span></span><br><span class="line">  last = newNode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果l==null，说明原来的链表是空的</span></span><br><span class="line">  <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">//那么新结点同时也是第一个结点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">//否则把新结点链接到原来的最后一个结点的next中</span></span><br><span class="line">    l.next = newNode;</span><br><span class="line">  <span class="comment">//元素个数增加</span></span><br><span class="line">  size++;</span><br><span class="line">  <span class="comment">//修改次数增加</span></span><br><span class="line">  modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//分o是否为空两种情况</span></span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//找到o对应的结点x</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">        unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//找到o对应的结点x</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">        unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;<span class="comment">//x是要被删除的结点</span></span><br><span class="line">  <span class="comment">// assert x != null;</span></span><br><span class="line">  <span class="keyword">final</span> E element = x.item;<span class="comment">//被删除结点的数据</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; next = x.next;<span class="comment">//被删除结点的下一个结点</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="comment">//被删除结点的上一个结点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果被删除结点的前面没有结点，说明被删除结点是第一个结点</span></span><br><span class="line">  <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//那么被删除结点的下一个结点变为第一个结点</span></span><br><span class="line">    first = next;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是第一个结点</span></span><br><span class="line">    <span class="comment">//被删除结点的上一个结点的next指向被删除结点的下一个结点</span></span><br><span class="line">    prev.next = next;</span><br><span class="line">    <span class="comment">//断开被删除结点与上一个结点的链接</span></span><br><span class="line">    x.prev = <span class="keyword">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果被删除结点的后面没有结点，说明被删除结点是最后一个结点</span></span><br><span class="line">  <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//那么被删除结点的上一个结点变为最后一个结点</span></span><br><span class="line">    last = prev;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是最后一个结点</span></span><br><span class="line">    <span class="comment">//被删除结点的下一个结点的prev执行被删除结点的上一个结点</span></span><br><span class="line">    next.prev = prev;</span><br><span class="line">    <span class="comment">//断开被删除结点与下一个结点的连接</span></span><br><span class="line">    x.next = <span class="keyword">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//把被删除结点的数据也置空，使得GC回收</span></span><br><span class="line">  x.item = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//元素个数减少</span></span><br><span class="line">  size--;</span><br><span class="line">  <span class="comment">//修改次数增加</span></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//返回被删除结点的数据</span></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h1><p>Set接口是Collection的子接口，set接口没有提供额外的方法。因此Set集合支持的遍历方式和Collection集合一样：foreach和Iterator。</p>
<p>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。</p>
<p>Set的常用实现类有：HashSet、TreeSet、LinkedHashSet。</p>
<blockquote>
<p>Set系列的集合：不可重复的<br>Set系列的集合，有有序的也有无序的。HashSet无序的，TreeSet按照元素的大小顺序遍历，LinkedHashSet按照元素的添加顺序遍历。</p>
</blockquote>
<h2 id="实现类的特点"><a href="#实现类的特点" class="headerlink" title="实现类的特点"></a>实现类的特点</h2><h3 id="HashSet和LinkedHashSet"><a href="#HashSet和LinkedHashSet" class="headerlink" title="HashSet和LinkedHashSet"></a>HashSet和LinkedHashSet</h3><p>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。</p>
<p>HashSet底层是HashMap实现。添加到HashSet的元素是作为HashMap的key，value是一个Object类型的常量对象PRESENT。依赖于元素的hashCode()和equals()保证元素的不可重复，存储位置和hashCode()值有关，根据hashCode()来算出它在底层table数组中的[index]</p>
<p>HashSet 和LinkedHashSet按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。HashSet 和LinkedHashSet集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。因此，存储到HashSet和LinkedHashSet的元素要重写hashCode和equals方法。</p>
<p>LinkedHashSet是HashSet的子类，它在HashSet的基础上，在结点中增加两个属性before和after维护了结点的前后添加顺序。LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。</p>
<p>底层是LinkedHashMap。添加到LinkedHashSet的元素是作为LinkedHashMap的key，value是一个Object类型的常量对象PRESENT。LinkedHashSet是HashSet的子类，比父类多维护了元素的添加顺序。当且仅当，你既想要元素不可重复，又要保证元素的添加顺序时，再使用它。</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>底层是TreeMap实现。添加到TreeSet的元素是作为TreeMap的key，value是一个Object类型的常量对象PRESENT。</p>
<p>依赖于元素的大小，要么是java.lang.Comparable接口compareTo(Object obj)，要么是java.util.Comparator接口的compare(Object o1, Object o2)来比较元素的大小。认为大小相等的两个元素就是重复元素。</p>
<p>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。使用元素的自然顺序(Comparable)对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。</p>
<h1 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h1><p>用来存储键值对，映射关系的集合。所有的Map的key都不能重复。</p>
<p>键值对、映射关系的类型：Entry类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entry接口是Map接口的内部接口。所有的Map的键值对的类型都实现了这个接口。</span><br><span class="line">HashMap中的映射关系，是有一个内部类来实现Entry的接口，JDK1.7是一个叫做Entry的内部类实现Entry接口。</span><br><span class="line">JDK1.8是一个叫做Node的内部类实现Entry接口。</span><br><span class="line">TreeMap中的映射关系，是有一个内部类Entry来实现Entry的接口</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Map 中的 key 和 value 都可以是任何引用类型的数据</p>
</li>
<li><p>Map 中的 key 不允许重复</p>
</li>
<li><p>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value。</p>
</li>
</ul>
<p>Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。映射顺序 定义为迭代器在映射的 collection 视图上返回其元素的顺序。某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap 类</p>
<h2 id="Map的方法"><a href="#Map的方法" class="headerlink" title="Map的方法"></a>Map的方法</h2><p>1、添加操作</p>
<ul>
<li><p>Object put(Object key,Object value)</p>
</li>
<li><p>void putAll(Map t)</p>
</li>
</ul>
<p>2、删除</p>
<ul>
<li><p>void clear()</p>
</li>
<li><p>Object remove(Object key)</p>
</li>
</ul>
<p>3、元素查询的操作</p>
<ul>
<li><p>Object get(Object key)</p>
</li>
<li><p>boolean containsKey(Object key)</p>
</li>
<li><p>boolean containsValue(Object value)</p>
</li>
<li><p>boolean isEmpty()</p>
</li>
</ul>
<p>4、元视图操作的方法：</p>
<ul>
<li><p>Set keySet()</p>
</li>
<li><p>Collection values()</p>
</li>
<li><p>Set entrySet()</p>
</li>
</ul>
<p>5、其他方法</p>
<ul>
<li>int size()</li>
</ul>
<h2 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h2><p>Collection集合的遍历：（1）foreach（2）通过Iterator对象遍历</p>
<p>Map的遍历，不能支持foreach</p>
<p>（1）分开遍历：单独遍历所有key</p>
<p>​      单独遍历所有value</p>
<p>（2）成对遍历：遍历的是映射关系Map.Entry</p>
<p>Map.Entry是Map接口的内部接口。每一种Map内部有自己的Map.Entry的实现类</p>
<p>在Map中存储数据，实际上是将Key—-&gt;value的数据存储在Map.Entry接口的实例中，再在Map集合中插入Map.Entry的实例化对象</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/map.png" alt="map"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMap</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">		map.put(<span class="string">"许仙"</span>, <span class="string">"白娘子"</span>);</span><br><span class="line">		map.put(<span class="string">"董永"</span>, <span class="string">"七仙女"</span>);</span><br><span class="line">		map.put(<span class="string">"牛郎"</span>, <span class="string">"织女"</span>);</span><br><span class="line">		map.put(<span class="string">"许仙"</span>, <span class="string">"小青"</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"所有的key:"</span>);</span><br><span class="line">		Set keySet = map.keySet();</span><br><span class="line">		<span class="keyword">for</span> (Object key : keySet) &#123;</span><br><span class="line">			System.out.println(key);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"所有的value："</span>);</span><br><span class="line">		Collection values = map.values();</span><br><span class="line">		<span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">			System.out.println(value);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"所有的映射关系"</span>);</span><br><span class="line">		Set entrySet = map.entrySet();</span><br><span class="line">		<span class="keyword">for</span> (Object entry : entrySet) &#123;</span><br><span class="line">			System.out.println(entry);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Map的实现类们的区别"><a href="#Map的实现类们的区别" class="headerlink" title="Map的实现类们的区别"></a>Map的实现类们的区别</h2><ul>
<li><p>HashMap：</p>
<p>依据key的hashCode()和equals()来保证key是否重复。</p>
<p>key如果重复，新的value会替换旧的value。</p>
<p>hashCode()决定了映射关系在table数组中的存储的位置，index = hash(key.hashCode()) &amp; table.length-1 </p>
<p>HashMap的底层实现：JDK1.7是数组+链表；JDK1.8是数组+链表/红黑树</p>
</li>
<li><p>TreeMap</p>
<p>依据key的大小来保证key是否重复。key如果重复，新的value会替换旧的value。</p>
<p>key的大小依赖于，java.lang.Comparable或java.util.Comparator。</p>
</li>
<li><p>LinkedHashMap</p>
<p>依据key的hashCode()和equals()来保证key是否重复。key如果重复，新的value会替换旧的value。</p>
<p>LinkedHashMap是HashMap的子类，比HashMap多了添加顺序</p>
</li>
<li><p>Properties</p>
<p>Properties 类是 Hashtable 的子类，Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。</p>
<p>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Properties properties = System.getProperties();</span><br><span class="line">		String p2 = properties.getProperty(<span class="string">"file.encoding"</span>);<span class="comment">//当前源文件字符编码</span></span><br><span class="line">		System.out.println(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><h3 id="JDK1-6源码："><a href="#JDK1-6源码：" class="headerlink" title="JDK1.6源码："></a>JDK1.6源码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//this.loadFactor加载因子，影响扩容的频率</span></span><br><span class="line">  <span class="comment">//DEFAULT_LOAD_FACTOR：默认加载因子0.75</span></span><br><span class="line">  <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">  <span class="comment">//threshold阈值 = 容量 * 加载因子</span></span><br><span class="line">  <span class="comment">//threshold阈值，当size达到threhold时，考虑扩容</span></span><br><span class="line">  <span class="comment">//扩容需要两个条件同时满足：（1）size &gt;= threhold （2）table[index]！=null，即新映射关系要存入的位置非空</span></span><br><span class="line">  threshold = (<span class="keyword">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</span><br><span class="line">  <span class="comment">//table是数组，</span></span><br><span class="line">  <span class="comment">//DEFAULT_INITIAL_CAPACITY：默认是16</span></span><br><span class="line">  table = <span class="keyword">new</span> Entry[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">  init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDK1-7源码："><a href="#JDK1-7源码：" class="headerlink" title="JDK1.7源码："></a>JDK1.7源码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//DEFAULT_INITIAL_CAPACITY：默认初始容量16</span></span><br><span class="line">  <span class="comment">//DEFAULT_LOAD_FACTOR：默认加载因子0.75</span></span><br><span class="line">  <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//校验initialCapacity合法性</span></span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">  <span class="comment">//校验initialCapacity合法性                                       </span></span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">  <span class="comment">//校验loadFactor合法性</span></span><br><span class="line">  <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line">                                               </span><br><span class="line">	<span class="comment">//加载因子，初始化为0.75</span></span><br><span class="line">  <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">  <span class="comment">// threshold 初始为初始容量                                  </span></span><br><span class="line">  threshold = initialCapacity;</span><br><span class="line">  init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果table数组是空的，那么先创建数组</span></span><br><span class="line">  <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">    <span class="comment">//threshold一开始是初始容量的值</span></span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果key是null，单独处理</span></span><br><span class="line">  <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对key的hashCode进行干扰，算出一个hash值</span></span><br><span class="line">  <span class="keyword">int</span> hash = hash(key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算新的映射关系应该存到table[i]位置，</span></span><br><span class="line">  <span class="comment">//i = hash &amp; table.length-1，可以保证i在[0,table.length-1]范围内</span></span><br><span class="line">  <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查table[i]下面有没有key与我新的映射关系的key重复，如果重复替换value</span></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">    Object k;</span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      e.value = value;</span><br><span class="line">      e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//添加新的映射关系</span></span><br><span class="line">  addEntry(hash, key, value, i);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">  <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);<span class="comment">//容量是等于toSize值的最接近的2的n次方</span></span><br><span class="line">  <span class="comment">//计算阈值 = 容量 * 加载因子</span></span><br><span class="line">  threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//创建Entry[]数组，长度为capacity</span></span><br><span class="line">  table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">  initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果key是null，直接存入[0]的位置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判断是否有重复的key，如果有重复的，就替换value</span></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      e.value = value;</span><br><span class="line">      e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//把新的映射关系存入[0]的位置，而且key的hash值用0表示</span></span><br><span class="line">  addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判断是否需要库容</span></span><br><span class="line">  <span class="comment">//扩容：（1）size达到阈值（2）table[i]正好非空</span></span><br><span class="line">  <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">    <span class="comment">//table扩容为原来的2倍，并且扩容后，会重新调整所有映射关系的存储位置</span></span><br><span class="line">    resize(<span class="number">2</span> * table.length);</span><br><span class="line">    <span class="comment">//新的映射关系的hash和index也会重新计算</span></span><br><span class="line">    hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">    bucketIndex = indexFor(hash, table.length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//存入table中</span></span><br><span class="line">  createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">  Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">  <span class="comment">//原来table[i]下面的映射关系作为新的映射关系next</span></span><br><span class="line">  table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">  size++;<span class="comment">//个数增加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>put(key,value)</strong></p>
<ul>
<li><p>当第一次添加映射关系时，数组初始化为一个长度为<strong>16</strong>的<strong>HashMap$Entry</strong>的数组，这个HashMap$Entry类型是实现了java.util.<strong>Map.Entry</strong>接口</p>
</li>
<li><p>特殊考虑：如果key为null，index直接是[0]</p>
</li>
<li><p>在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p>
</li>
<li><p>计算index = table.length-1 &amp; hash;</p>
</li>
<li><p>如果table[index]下面，已经有映射关系的key与我要添加的新的映射关系的key相同了，会用新的value替换旧的value。</p>
</li>
<li><p>如果没有相同的，会把新的映射关系添加到链表的头，原来table[index]下面的Entry对象连接到新的映射关系的next中。</p>
</li>
<li><p>添加之前先判断if(size &gt;= threshold  &amp;&amp;  table[index]!=null)如果该条件为true，会扩容</p>
</li>
</ul>
<p>​    if ( size &gt;= threshold  &amp;&amp;  table[index]!=null ) {</p>
<p>​        ①会扩容</p>
<p>​        ②会重新计算key的hash</p>
<p>​        ③会重新计算index</p>
<p>​    }</p>
<p><strong>get(key)</strong></p>
<ul>
<li><p>计算key的hash值，用这个方法hash(key)</p>
</li>
<li><p>找index = table.length-1 &amp; hash;</p>
</li>
<li><p>如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就返回它的value</p>
</li>
</ul>
<p><strong>remove(key)</strong></p>
<ul>
<li><p>计算key的hash值，用这个方法hash(key)</p>
</li>
<li><p>找index = table.length-1 &amp; hash;</p>
</li>
<li><p>如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</p>
</li>
</ul>
<h3 id="JDK1-8源码"><a href="#JDK1-8源码" class="headerlink" title="JDK1.8源码"></a>JDK1.8源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">几个常量和变量：</span><br><span class="line">（<span class="number">1</span>）DEFAULT_INITIAL_CAPACITY：默认的初始容量 <span class="number">16</span></span><br><span class="line">（<span class="number">2</span>）MAXIMUM_CAPACITY：最大容量  <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br><span class="line">（<span class="number">3</span>）DEFAULT_LOAD_FACTOR：默认加载因子 <span class="number">0.75</span></span><br><span class="line">（<span class="number">4</span>）TREEIFY_THRESHOLD：默认树化阈值<span class="number">8</span>，当链表的长度达到这个值后，要考虑树化</span><br><span class="line">（<span class="number">5</span>）UNTREEIFY_THRESHOLD：默认反树化阈值<span class="number">6</span>，当树中的结点的个数达到这个阈值后，要考虑变为链表</span><br><span class="line">（<span class="number">6</span>）MIN_TREEIFY_CAPACITY：最小树化容量<span class="number">64</span></span><br><span class="line">		当单个的链表的结点个数达到<span class="number">8</span>，并且table的长度达到<span class="number">64</span>，才会树化。</span><br><span class="line">		当单个的链表的结点个数达到<span class="number">8</span>，但是table的长度未达到<span class="number">64</span>，会先扩容</span><br><span class="line">（<span class="number">7</span>）Node&lt;K,V&gt;[] table：数组</span><br><span class="line">（<span class="number">8</span>）size：记录有效映射关系的对数，也是Entry对象的个数</span><br><span class="line">（<span class="number">9</span>）<span class="keyword">int</span> threshold：阈值，当size达到阈值时，考虑扩容</span><br><span class="line">（<span class="number">10</span>）<span class="keyword">double</span> loadFactor：加载因子，影响扩容的频率</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">  <span class="comment">// all other fields defaulted，其他字段都是默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目的：干扰hashCode值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="comment">//如果key是null，hash是0</span></span><br><span class="line">  <span class="comment">//如果key非null，用key的hashCode值 与 key的hashCode值高16进行异或</span></span><br><span class="line">  <span class="comment">//		即就是用key的hashCode值高16位与低16位进行了异或的干扰运算</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">		index = hash &amp; table.length-1</span></span><br><span class="line"><span class="comment">		如果用key的原始的hashCode值  与 table.length-1 进行按位与，那么基本上高16没机会用上。</span></span><br><span class="line"><span class="comment">		这样就会增加冲突的概率，为了降低冲突的概率，把高16位加入到hash信息中。</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; <span class="comment">//数组</span></span><br><span class="line">  Node&lt;K,V&gt; p; <span class="comment">//一个结点</span></span><br><span class="line">  <span class="keyword">int</span> n, i;<span class="comment">//n是数组的长度   i是下标</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//tab和table等价</span></span><br><span class="line">  <span class="comment">//如果table是空的</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)&#123;</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">			tab = resize();</span></span><br><span class="line"><span class="comment">			n = tab.length;*/</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">			如果table是空的，resize()完成了①创建了一个长度为16的数组②threshold = 12</span></span><br><span class="line"><span class="comment">			n = 16</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//i = (n - 1) &amp; hash ，下标 = 数组长度-1 &amp; hash</span></span><br><span class="line">  <span class="comment">//p = tab[i] 第1个结点</span></span><br><span class="line">  <span class="comment">//if(p==null) 条件满足的话说明 table[i]还没有元素</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//把新的映射关系直接放入table[i]</span></span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//newNode（）方法就创建了一个Node类型的新结点，新结点的next是null</span></span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; </span><br><span class="line">    K k;</span><br><span class="line">    <span class="comment">//p是table[i]中第一个结点</span></span><br><span class="line">    <span class="comment">//if(table[i]的第一个结点与新的映射关系的key重复)</span></span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">      e = p;<span class="comment">//用e记录这个table[i]的第一个结点</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123;<span class="comment">//如果table[i]第一个结点是一个树结点</span></span><br><span class="line">      <span class="comment">//单独处理树结点</span></span><br><span class="line">      <span class="comment">//如果树结点中，有key重复的，就返回那个重复的结点用e接收，即e!=null</span></span><br><span class="line">      <span class="comment">//如果树结点中，没有key重复的，就把新结点放到树中，并且返回null，即e=null</span></span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//table[i]的第一个结点不是树结点，也与新的映射关系的key不重复</span></span><br><span class="line">      <span class="comment">//binCount记录了table[i]下面的结点的个数</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="comment">//如果p的下一个结点是空的，说明当前的p是最后一个结点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//把新的结点连接到table[i]的最后</span></span><br><span class="line">          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//如果binCount&gt;=8-1，达到7个时</span></span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)&#123; <span class="comment">// -1 for 1st</span></span><br><span class="line">            <span class="comment">//要么扩容，要么树化</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果key重复了，就跳出for循环，此时e结点记录的就是那个key重复的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = e;<span class="comment">//下一次循环，e=p.next，就类似于e=e.next，往链表下移动</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果这个e不是null，说明有key重复，就考虑替换原来的value</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)&#123;</span><br><span class="line">        e.value = value;</span><br><span class="line">      &#125;</span><br><span class="line">      afterNodeAccess(e);<span class="comment">//什么也没干</span></span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++modCount;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//元素个数增加</span></span><br><span class="line">  <span class="comment">//size达到阈值</span></span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)&#123;</span><br><span class="line">    resize();<span class="comment">//一旦扩容，重新调整所有映射关系的位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  afterNodeInsertion(evict);<span class="comment">//什么也没干</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//oldTab原来的table</span></span><br><span class="line">  <span class="comment">//oldCap：原来数组的长度</span></span><br><span class="line">  <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//oldThr：原来的阈值</span></span><br><span class="line">  <span class="keyword">int</span> oldThr = threshold;<span class="comment">//最开始threshold是0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//newCap，新容量</span></span><br><span class="line">  <span class="comment">//newThr：新阈值</span></span><br><span class="line">  <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//说明原来不是空数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//是否达到数组最大限制</span></span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">              oldCap &gt;= DEFAULT_INITIAL_CAPACITY)&#123;</span><br><span class="line">      <span class="comment">//newCap = 旧的容量*2 ，新容量&lt;最大数组容量限制</span></span><br><span class="line">      <span class="comment">//新容量：32,64，...</span></span><br><span class="line">      <span class="comment">//oldCap &gt;= 初始容量16</span></span><br><span class="line">      <span class="comment">//新阈值重新算 = 24，48 ....</span></span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)&#123; <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//新容量是默认初始化容量16</span></span><br><span class="line">    <span class="comment">//新阈值= 默认的加载因子 * 默认的初始化容量 = 0.75*16 = 12</span></span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  threshold = newThr;<span class="comment">//阈值赋值为新阈值12，24.。。。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建了一个新数组，长度为newCap，16，32,64.。。</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;<span class="comment">//原来不是空数组</span></span><br><span class="line">    <span class="comment">//把原来的table中映射关系，倒腾到新的table中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;<span class="comment">//e是table下面的结点</span></span><br><span class="line">        oldTab[j] = <span class="keyword">null</span>;<span class="comment">//把旧的table[j]位置清空</span></span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)<span class="comment">//如果是最后一个结点</span></span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;<span class="comment">//重新计算e的在新table中的存储位置，然后放入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果e是树结点</span></span><br><span class="line">          <span class="comment">//把原来的树拆解，放到新的table</span></span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">						把原来table[i]下面的整个链表，重新挪到了新的table中</span></span><br><span class="line"><span class="comment">						*/</span></span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建一个新结点</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, index; </span><br><span class="line">  Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="comment">//MIN_TREEIFY_CAPACITY：最小树化容量64</span></span><br><span class="line">  <span class="comment">//如果table是空的，或者  table的长度没有达到64</span></span><br><span class="line">  <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">    resize();<span class="comment">//先扩容</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//用e记录table[index]的结点的地址</span></span><br><span class="line">    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">			do...while，把table[index]链表的Node结点变为TreeNode类型的结点</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">        hd = p;<span class="comment">//hd记录根结点</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        p.prev = tl;</span><br><span class="line">        tl.next = p;</span><br><span class="line">      &#125;</span><br><span class="line">      tl = p;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果table[index]下面不是空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">      hd.treeify(tab);<span class="comment">//将table[index]下面的链表进行树化</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>添加过程</strong></p>
<ul>
<li><p>当第一次添加映射关系时，数组初始化为一个长度为<strong>16</strong>的<strong>HashMap$Node</strong>的数组，这个HashMap$Node类型是实现了java.util.<strong>Map.Entry</strong>接口</p>
</li>
<li><p>在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p>
</li>
</ul>
<blockquote>
<p>JDK1.8关于hash(key)方法的实现比JDK1.7要简洁。 key.hashCode() ^ key.Code()&gt;&gt;&gt;16;</p>
</blockquote>
<ul>
<li><p>计算index = table.length-1 &amp; hash;</p>
</li>
<li><p>如果table[index]下面，已经有映射关系的key与我要添加的新的映射关系的key相同了，会用新的value替换旧的value。</p>
</li>
<li><p>如果没有相同的，</p>
<p>① table[index]链表的长度没有达到8个，会把新的映射关系添加到链表的尾</p>
<p>② table[index]链表的长度达到8个，但是table.length没有达到64，会先对table进行扩容，然后再添加</p>
<p>③ table[index]链表的长度达到8个，并且table.length达到64，会先把该分支进行树化，结点的类型变为TreeNode，然后把链表转    为一棵红黑树</p>
<p>④table[index]本来就已经是红黑树了，那么直接连接到树中，可能还会考虑考虑左旋右旋以保证树的平衡问题</p>
</li>
<li><p>添加完成后判断 if (size &gt; threshold ){</p>
<p>① 会扩容</p>
<p>② 会重新计算key的hash</p>
<p>③ 会重新计算index</p>
</li>
</ul>
<p>​    }</p>
<p><strong>remove(key)</strong></p>
<ul>
<li>计算key的hash值，用这个方法hash(key)</li>
<li>找index = table.length-1 &amp; hash;</li>
<li>如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</li>
<li>如果table[index]下面原来是红黑树，结点删除后，个数小于等于6，会把红黑树变为链表</li>
</ul>
<h3 id="关于HashMap的面试问题"><a href="#关于HashMap的面试问题" class="headerlink" title="关于HashMap的面试问题"></a>关于HashMap的面试问题</h3><p>1、HashMap的底层实现</p>
<blockquote>
<p>答：JDK1.7是数组+链表，JDK1.8是数组+链表/红黑树</p>
</blockquote>
<p>2、HashMap的数组的元素类型</p>
<blockquote>
<p>答：java.util.Map$Entry接口类型。</p>
<p>JDK1.7的HashMap中有内部类Entry实现Entry接口</p>
<p>JDK1.8的HashMap中有内部类Node和TreeNode类型实现Entry接口</p>
</blockquote>
<p>3、为什么要使用数组？</p>
<blockquote>
<p> 答：因为数组的访问的效率高</p>
</blockquote>
<p>4、为什么数组还需要链表？或问如何解决hash或[index]冲突问题？</p>
<blockquote>
<p> 答：为了解决hash和[index]冲突问题</p>
<p> （1）两个不相同的key的hashCode值本身可能相同</p>
<p> （2）两个hashCode不相同的key，通过hash(key)以及 hash &amp; table.length-1运算得到的[index]可能相同</p>
<p> 那么意味着table[index]下可能需要存储多个Entry的映射关系对象，所以需要链表</p>
</blockquote>
<p>5、HashMap的数组的初始化长度</p>
<blockquote>
<p>答：默认的初始容量值是16</p>
</blockquote>
<p>6、HashMap的映射关系的存储索引index如何计算</p>
<blockquote>
<p>答：hash &amp; table.length-1</p>
</blockquote>
<p>7、为什么要使用hashCode()? 空间换时间</p>
<blockquote>
<p>答：因为hashCode()是一个整数值，可以用来直接计算index，效率比较高，用数组这种结构虽然会浪费一些空间，但是可以提高查询效率。</p>
</blockquote>
<p>8、hash()函数的作用是什么</p>
<blockquote>
<p> 答：在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p>
<p> JDK1.8关于hash(key)方法的实现比JDK1.7要简洁。 key.hashCode() ^ key.Code()&gt;&gt;&gt;16; 因为这样可以使得hashCode的高16位信息也能参与到运算中来</p>
</blockquote>
<p>9、HashMap的数组长度为什么一定要是2的幂次方</p>
<blockquote>
<p>答：因为2的n次方-1的二进制值是前面都0，后面几位都是1，这样的话，与hash进行&amp;运算的结果就能保证在[0,table.length-1]范围内，而且是均匀的。</p>
</blockquote>
<p>10、HashMap 为什么使用 &amp;按位与运算代替%模运算？</p>
<blockquote>
<p>答：因为&amp;效率高</p>
</blockquote>
<p>11、HashMap的数组什么时候扩容？</p>
<blockquote>
<p>答：JDK1.7版：当要添加新Entry对象时发现（1）size达到threshold（2）table[index]!=null时，两个条件同时满足会扩容</p>
<p>JDK1.8版：当要添加新Entry对象时发现（1）size达到threshold（2）当table[index]下的结点个数达到8个但是table.length又没有达到64。两种情况满足其一都会导致数组扩容</p>
<p>而且数组一旦扩容，不管哪个版本，都会导致所有映射关系重新调整存储位置。</p>
</blockquote>
<p>12、如何计算扩容阈值(临界值)？</p>
<blockquote>
<p>答：threshold = capacity * loadfactor</p>
</blockquote>
<p>13、loadFactor为什么是0.75，如果是1或者0.1呢有什么不同？</p>
<blockquote>
<p>答：1的话，会导致某个table[index]下面的结点个数可能很长</p>
<p>0.1的话，会导致数组扩容的频率太高</p>
</blockquote>
<p>14、JDK1.8的HashMap什么时候树化？</p>
<blockquote>
<p>答：当table[index]下的结点个数达到8个但是table.length已经达到64</p>
</blockquote>
<p>15、JDK1.8的HashMap什么时候反树化？</p>
<blockquote>
<p>答：当table[index]下的树结点个数少于6个</p>
</blockquote>
<p>16、JDK1.8的HashMap为什么要树化？</p>
<blockquote>
<p>答：因为当table[index]下的结点个数超过8个后，查询效率就低下了，修改为红黑树的话，可以提高查询效率</p>
</blockquote>
<p>17、JDK1.8的HashMap为什么要反树化？</p>
<blockquote>
<p>答：因为因为当table[index]下树的结点个数少于6个后，使用红黑树反而过于复杂了，此时使用链表既简洁又效率也不错</p>
</blockquote>
<p>18、作为HashMap的key类型重写equals和hashCode方法有什么要求</p>
<p>​    （1）equals与hashCode一起重写</p>
<p>​    （2）重写equals()方法，但是有一些注意事项；</p>
<ul>
<li>自反性：x.equals(x)必须返回true。<br>对称性：x.equals(y)与y.equals(x)的返回值必须相等。<br>传递性：x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)必须为true。<br>一致性：如果对象x和y在equals()中使用的信息都没有改变，那么x.equals(y)值始终不变。<br>非null：x不是null，y为null，则x.equals(y)必须为false。</li>
</ul>
<p>​    （3）重写hashCode（）的注意事项</p>
<ul>
<li>如果equals返回true的两个对象，那么hashCode值一定相同，并且只要参与equals判断属性没有修改，hashCode值也不能修改；<br>如果equals返回false的两个对象，那么hashCode值可以相同也可以不同；<br>如果hashCode值不同的，equals一定要返回false；<br>hashCode不宜过简单，太简单会导致冲突严重，hashCode也不宜过于复杂，会导致性能低下；</li>
</ul>
<p>19、为什么大部分 hashcode 方法使用 31？</p>
<blockquote>
<p> 答：因为31是一个不大不小的素数</p>
</blockquote>
<p>20、请问已经存储到HashMap中的key的对象属性是否可以修改？为什么？</p>
<blockquote>
<p>答：如果该属性参与hashCode的计算，那么不要修改。因为一旦修改hashCode()已经不是原来的值。<br>而存储到HashMap中时，key的hashCode()–&gt;hash()–&gt;hash已经确定了，不会重新计算。用新的hashCode值再查询get(key)/删除remove(key)时，算的hash值与原来不一样就不找不到原来的映射关系了。</p>
</blockquote>
<p>21、所以为什么，我们实际开发中，key的类型一般用String和Integer</p>
<blockquote>
<p>答：因为他们不可变。</p>
</blockquote>
<p>22、为什么HashMap中的Node或Entry类型的hash变量与key变量加final声明？</p>
<blockquote>
<p> 答：因为不希望你修改hash和key值</p>
</blockquote>
<p>23、为什么HashMap中的Node或Entry类型要单独存储hash？</p>
<blockquote>
<p> 答：为了在添加、删除、查找过程中，比较hash效率更高，不用每次重新计算key的hash值</p>
</blockquote>
<p>24、请问已经存储到HashMap中的value的对象属性是否可以修改？为什么？</p>
<blockquote>
<p>答：可以。因为我们存储、删除等都是根据key，和value无关。</p>
</blockquote>
<p>25、如果key是null是如何存储的？</p>
<blockquote>
<p>答：会存在table[0]中</p>
</blockquote>
<h1 id="集合框架图"><a href="#集合框架图" class="headerlink" title="集合框架图"></a>集合框架图</h1><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection12.png" alt="collection"></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Uncle He</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.unclehe.net/2020/06/19/java-collection/">https://www.unclehe.net/2020/06/19/java-collection/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.unclehe.net" target="_blank">Uncle He</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9B%86%E5%90%88/">集合</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/java.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/wechat.jpg" alt="wechat"/><div class="post-qr-code__desc">wechat</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/alipay.jpg" alt="alipay"/><div class="post-qr-code__desc">alipay</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/20/java-%3CT%3E/"><img class="prev_cover" data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/java.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">泛型</div></div></a></div><div class="next-post pull_right"><a href="/2020/06/17/java-common-class/"><img class="next_cover" data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/java.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">常用类</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'kJLrzEh54hbM7O4kjF6VhlAt-MdYXbMMI',
  appKey: 'wbsLMRTmGNJ2wpVv2Xtvo17B',
  notify: false,
  verify: false,
  placeholder: '昵称请填写QQ号会自动获取头像和昵称...',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: true,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/java.jpeg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Uncle He</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://www.unclehe.net/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode far fa-moon" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/js/customjs.js"></script></body></html>