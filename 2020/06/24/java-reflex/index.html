<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>反射 | Uncle He</title><meta name="description" content="类的加载、连接和初始化当程序主动使用某个类时，如果该类还未被加载到JVM内存中，系统会通过加载、连接、初始化三个步骤来对该类进行初始化，如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载。  类的加载系统可能在第一次使用某个类时加载该类，但也可能采用预先加载机制来预加载某个类，不管怎样，类的加载必须由类加载器完成，类加载器通常由JVM提供，由JVM提供的这些类加载器通常"><meta name="keywords" content="反射"><meta name="author" content="Uncle He"><meta name="copyright" content="Uncle He"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="反射"><meta name="twitter:description" content="类的加载、连接和初始化当程序主动使用某个类时，如果该类还未被加载到JVM内存中，系统会通过加载、连接、初始化三个步骤来对该类进行初始化，如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载。  类的加载系统可能在第一次使用某个类时加载该类，但也可能采用预先加载机制来预加载某个类，不管怎样，类的加载必须由类加载器完成，类加载器通常由JVM提供，由JVM提供的这些类加载器通常"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/cover/java.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="反射"><meta property="og:url" content="https://www.unclehe.net/2020/06/24/java-reflex/"><meta property="og:site_name" content="Uncle He"><meta property="og:description" content="类的加载、连接和初始化当程序主动使用某个类时，如果该类还未被加载到JVM内存中，系统会通过加载、连接、初始化三个步骤来对该类进行初始化，如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载。  类的加载系统可能在第一次使用某个类时加载该类，但也可能采用预先加载机制来预加载某个类，不管怎样，类的加载必须由类加载器完成，类加载器通常由JVM提供，由JVM提供的这些类加载器通常"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/cover/java.jpeg"><meta property="article:published_time" content="2020-06-24T06:55:08.000Z"><meta property="article:modified_time" content="2020-07-08T06:47:34.915Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://www.unclehe.net/2020/06/24/java-reflex/"><link rel="prev" title="Lambda表达式与StreamAPI" href="https://www.unclehe.net/2020/06/27/java-lambda/"><link rel="next" title="网络编程" href="https://www.unclehe.net/2020/06/23/java-network-programming/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://unclehe.net/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: Uncle He","link":"链接: ","source":"来源: Uncle He","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"top-right"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'true',
  isFontAwesomeV5: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/css/customcss.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">29</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">17</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="https://unclehe.gitee.io" target="_blank" rel="noopener"><i class="fa-fw fa fa-toolbox"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#类的加载、连接和初始化"><span class="toc-number">1.</span> <span class="toc-text">类的加载、连接和初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#类的加载"><span class="toc-number">1.1.</span> <span class="toc-text">类的加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类的连接"><span class="toc-number">1.2.</span> <span class="toc-text">类的连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类的初始化"><span class="toc-number">1.3.</span> <span class="toc-text">类的初始化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类加载器"><span class="toc-number">2.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#四种类加载器"><span class="toc-number">2.1.</span> <span class="toc-text">四种类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#经典委托模式"><span class="toc-number">2.2.</span> <span class="toc-text">经典委托模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-lang-ClassLoader"><span class="toc-number">2.3.</span> <span class="toc-text">java.lang.ClassLoader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用类加载器加载资源文件"><span class="toc-number">2.4.</span> <span class="toc-text">使用类加载器加载资源文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#通过反射查看类信息"><span class="toc-number">3.</span> <span class="toc-text">通过反射查看类信息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java-lang-Class"><span class="toc-number">3.1.</span> <span class="toc-text">java.lang.Class</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#哪些类型有Class对象"><span class="toc-number">3.1.1.</span> <span class="toc-text">哪些类型有Class对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获得Class对象"><span class="toc-number">3.1.2.</span> <span class="toc-text">获得Class对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从Class中获取信息"><span class="toc-number">3.2.</span> <span class="toc-text">从Class中获取信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#获取某个类的加载器"><span class="toc-number">3.2.1.</span> <span class="toc-text">获取某个类的加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取包名和类型名"><span class="toc-number">3.2.2.</span> <span class="toc-text">获取包名和类型名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取类型修饰符"><span class="toc-number">3.2.3.</span> <span class="toc-text">获取类型修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取父类或父接口"><span class="toc-number">3.2.4.</span> <span class="toc-text">获取父类或父接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取内部类或外部类信息"><span class="toc-number">3.2.5.</span> <span class="toc-text">获取内部类或外部类信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取属性"><span class="toc-number">3.2.6.</span> <span class="toc-text">获取属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取构造器"><span class="toc-number">3.2.7.</span> <span class="toc-text">获取构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取方法"><span class="toc-number">3.2.8.</span> <span class="toc-text">获取方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取泛型父类"><span class="toc-number">3.2.9.</span> <span class="toc-text">获取泛型父类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取注解信息"><span class="toc-number">3.2.10.</span> <span class="toc-text">获取注解信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用反射生成并操作对象"><span class="toc-number">4.</span> <span class="toc-text">使用反射生成并操作对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用反射创建对象"><span class="toc-number">4.1.</span> <span class="toc-text">使用反射创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取或设置某个对象的属性值"><span class="toc-number">4.2.</span> <span class="toc-text">获取或设置某个对象的属性值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调用方法"><span class="toc-number">4.3.</span> <span class="toc-text">调用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作数组"><span class="toc-number">4.4.</span> <span class="toc-text">操作数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#动态代理"><span class="toc-number">5.</span> <span class="toc-text">动态代理</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/cover/java.jpeg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Uncle He</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="https://unclehe.gitee.io" target="_blank" rel="noopener"><i class="fa-fw fa fa-toolbox"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">反射</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-24 14:55:08"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-06-24</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-08 14:47:34"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-07-08</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%87%AA%E5%AD%A6Java/">自学Java</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%87%AA%E5%AD%A6Java/%E5%8F%8D%E5%B0%84/">反射</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon far fa-file-word" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">9.7k</span><span class="post-meta__separator">|</span><i class="post-meta__icon far fa-clock" aria-hidden="true"></i><span>阅读时长: 36 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon far fa-comments" aria-hidden="true"></i><span>评论数:</span><a href="/2020/06/24/java-reflex/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/06/24/java-reflex/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="类的加载、连接和初始化"><a href="#类的加载、连接和初始化" class="headerlink" title="类的加载、连接和初始化"></a>类的加载、连接和初始化</h1><p>当程序主动使用某个类时，如果该类还未被加载到JVM内存中，系统会通过加载、连接、初始化三个步骤来对该类进行初始化，如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/reflex1.png" alt="reflex"></p>
<h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><p>系统可能在第一次使用某个类时加载该类，但也可能采用预先加载机制来预加载某个类，不管怎样，类的加载必须由类加载器完成，类加载器通常由JVM提供，由JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。</p>
<p>通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源：</p>
<ol>
<li>从本地系统直接读取.class文件，这是绝大部分类的加载方法；</li>
<li>从zip，jar等归档文件中加载.class文件，这种方式也是很常见的；</li>
<li>通过网络下载.class文件或数据</li>
<li>从专有数据库中提取.class数据</li>
<li>将Java源文件数据上传到服务器中动态编译为.class数据，并执行加载；</li>
</ol>
<p>但是，不管类的字节码内容从哪里加载，加载的结果都一样，这些字节码内容加载到内存后，都会将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址），所有需要访问和使用类数据只能通过这个Class对象。</p>
<h2 id="类的连接"><a href="#类的连接" class="headerlink" title="类的连接"></a>类的连接</h2><p>当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段将会负责把类的二进制数据合并到JVM的运行状态之中。类连接又可以分为如下三个阶段：</p>
<ol>
<li>验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题</li>
<li>准备：正式为类变量（static）分配内存并设置类变量<strong>默认</strong>初始值的阶段，这些内存都将在方法区中进行分配</li>
<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程</li>
</ol>
<h2 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h2><p>类的初始化主要就是对静态的类变量进行初始化：</p>
<ol>
<li>执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中所有类变量的显式赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化</li>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = getNum();</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		++a;</span><br><span class="line">		System.out.println(<span class="string">"(2)a = "</span> + a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		++a;</span><br><span class="line">		System.out.println(<span class="string">"(3)a = "</span> + a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"(1)a = "</span> + a);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClinit</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b = getNum();</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		++b;</span><br><span class="line">		System.out.println(<span class="string">"(5)b = "</span> + b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		++b;</span><br><span class="line">		System.out.println(<span class="string">"(6)b = "</span> + b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"(4)b = "</span> + b);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(1)a = 0</span></span><br><span class="line"><span class="comment">(2)a = 2</span></span><br><span class="line"><span class="comment">(3)a = 3</span></span><br><span class="line"><span class="comment">(4)b = 0</span></span><br><span class="line"><span class="comment">(5)b = 2</span></span><br><span class="line"><span class="comment">(6)b = 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>虽然类的加载大多数时候和类初始化是一气呵成的，但其实类的加载不一定就会触发类的初始化，当Java程序<strong>首次</strong>通过下面5种方式来使用某个类时，系统就会初始化该类：</p>
<ul>
<li>会发生类的初始化：<ul>
<li>当虚拟机启动，先初始化main方法所在的类</li>
<li>new一个类的对象</li>
<li>调用该类的静态变量（final的常量除外）和静态方法</li>
<li>使用java.lang.reflect包的方法对类进行反射调用</li>
<li>当初始化一个类，如果其父类没有被初始化，则先会初始化他的父类</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当虚拟机启动，先初始化main方法所在的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"init...A"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//new一个类的对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"init...B"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> B();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用该类的静态变量（final的常量除外）和静态方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"init...C"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestC</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		C.test();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用该类的静态变量（final的常量除外）和静态方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"init...C"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestC</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(C.num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用java.lang.reflect包的方法对类进行反射调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"init...D"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestD</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">		ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">		cl.loadClass(<span class="string">"com.atguigu.loader.D"</span>);<span class="comment">//该句不会造成类初始化，只是加载类</span></span><br><span class="line">		System.out.println(<span class="string">"类加载已完成..."</span>);</span><br><span class="line">		Class.forName(<span class="string">"com.atguigu.loader.D"</span>);<span class="comment">//会导致类初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当初始化一个类，如果其父类没有被初始化，则先会初始化他的父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EBase</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类初始化"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestE</span> <span class="keyword">extends</span> <span class="title">EBase</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类初始化"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不会发生类的初始化：<ul>
<li>引用静态常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化<ul>
<li>当通过子类引用父类的静态变量或父类的静态方法，不会导致子类初始化</li>
</ul>
</li>
<li>通过数组定义类引用，不会触发此类的初始化</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用静态常量不会触发此类的初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NBase</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类初始化"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NSub</span> <span class="keyword">extends</span> <span class="title">NBase</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类初始化"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNoInitialize</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(NSub.MAX_VALUE);</span><br><span class="line">		System.out.println(NBase.MAX_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当访问一个静态域时，只有真正声明这个域的类才会被初始化</span></span><br><span class="line"><span class="comment">//   当通过子类引用父类的静态变量，不会导致子类初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NBase</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"父类初始化"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NSub</span> <span class="keyword">extends</span> <span class="title">NBase</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"子类初始化"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNoInitialize</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(NSub.num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过数组定义类引用，不会触发此类的初始化</span></span><br><span class="line">NSub[] arr = <span class="keyword">new</span> NSub[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>



<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>很多开发人员都遇到过java.lang.ClassNotFoundException或java.lang.NoClassDefError，想要更好的解决这类问题，或者在一些特殊的应用场景，比如需要支持类的动态加载或需要对编译后的字节码文件进行加密解密操作，那么需要你自定义类加载器，因此了解类加载器及其类加载机制也就成了每一个Java开发人员的必备技能之一。</p>
<h2 id="四种类加载器"><a href="#四种类加载器" class="headerlink" title="四种类加载器"></a>四种类加载器</h2><p>Java的类加载器由如下四种：</p>
<ol>
<li><p>引导类加载器（Bootstrap Classloader）：又称为根类加载器</p>
<p>它负责加载Java的核心库（JAVA_HOME/jre/lib/rt.jar等或sun.boot.class.path路径下的内容），是用原生代码（C/C++）来实现的，并不继承自java.lang.ClassLoder，所以通过Java代码获取引导类加载器对象将会得到null。</p>
</li>
<li><p>扩展类加载器（Extension ClassLoader）</p>
<p>它由sun.misc.Launcher$ExtClassLoader实现，是java.lang.ClassLoader的子类，负责加载Java的扩展库（JAVA_HOME/jre/ext/*.jar或java.ext.dirs路径下的内容）。</p>
</li>
<li><p>应用程序类加载器（Application Classloader）</p>
<p>它由sun.misc.Launcher$AppClassLoader实现，是java.lang.ClassLoader的子类，负责加载Java应用程序类路径（classpath、java.class.path）下的内容。</p>
</li>
<li><p>自定义类加载器</p>
<p>开发人员可以通过继承java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求，例如对字节码进行加密来避免class文件被反编译，或者加载特殊目录下的字节码数据。</p>
</li>
</ol>
<h2 id="经典委托模式"><a href="#经典委托模式" class="headerlink" title="经典委托模式"></a>经典委托模式</h2><p>类加载器负责加载所有的类，系统为所有被载入内存中的类生成一个java.lang.Class实例。一旦一个类被载入JVM中，同一个类就不会被再次载入了。</p>
<p>那么，怎么样算是“同一个类”呢？在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。换句话说，同一个类如果用两个类加载器分别加载，JVM将视为“不同的类”，它们互不兼容。</p>
<p>那么，我们的类加载器在执行类加载任务的时候，如何确保一个类的全局唯一性呢？Java虚拟机的设计者们通过一种称之为“双亲委派模型（Parent Delegation Model）”的委派机制来约定类加载器的加载机制。</p>
<p>按照双亲委派模型的规则，除了引导类加载器之外，程序中的每一个类加载器都应该拥有一个超类加载器，比如：ExtClassLoader的超类加载器是引导类加载器，而AppClassLoader的超类加载器是ExtClassLoader，而自定义类加载器的超类就是AppClassLoader。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/reflex2.png" alt="reflex"></p>
<p>那么当一个类加载器接收到一个类加载任务的时候，它并不会立即展开加载，先检测此类是否加载过，即在方法区寻找该类对应的Class对象是否存在，如果存在就是已经加载过了，直接返回该Class对象，否则会将加载任务委派给它的超类加载器去执行，每一层的类加载器都采用相同的方式，直至委派给最顶层的启动类加载器为止，如果超类加载器无法加载委派给它的类时，便会将类的加载任务退回给它的下一级类加载器去执行加载，如果所有的类加载器都加载失败，就会报java.lang.ClassNotFoundException或java.lang.NoClassDefFoundError。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/reflex3.png" alt="reflex"></p>
<p>在此大家需要注意，由于Java虚拟机规范并没有要求类加载器的加载机制一定要使用双亲委托模式，只是建议采用这种方式而已。比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器就接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。</p>
<p>说明：数组类型本身并不是由类加载器负责创建，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。因此，JVM会把数组元素类型的类加载器记录为数组类型的类加载器。</p>
<h2 id="java-lang-ClassLoader"><a href="#java-lang-ClassLoader" class="headerlink" title="java.lang.ClassLoader"></a>java.lang.ClassLoader</h2><p>ClassLoader 类是一个抽象类，ClassLoader的相关方法：</p>
<ul>
<li>public final ClassLoader getParent()：返回委托的父类加载器。一些实现可能使用 null 来表示引导类加载器。</li>
<li>public static ClassLoader getSystemClassLoader()：返回委托的系统类加载器。</li>
<li>public Class&lt;?&gt; loadClass(String name)：使用指定的二进制名称（类的全限定名）来加载类。例如：java.lang.String，注意内部类的名称：匿名内部类（外部类的全限定名$编号）、局部内部类（外部类的全限定名$编号+类名）、成员/静态内部类（外部类的全限定名$+类名）。</li>
<li>protected Class&lt;?&gt; findClass(String name)：使用指定的二进制名称（类的全限定名）来查找类。此方法应该被类加载器的实现重写，该实现按照委托模型来加载类。在通过父类加载器检查所请求的类后，此方法将被 loadClass 方法调用。</li>
<li>protected final Class&lt;?&gt; findLoadedClass(String name)：返回Class 对象，如果类没有被加载，则返回 null</li>
<li>protected final Class&lt;?&gt; defineClass(String name,byte[] b,int off,int len)：将一个 byte 数组转换为 Class 类的实例。</li>
</ul>
<p>自定义类加载器示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String rootDir;<span class="comment">//指定加载路径</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileClassLoader</span><span class="params">(String rootDir)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">		<span class="comment">//首先检查请求的类型是否已经被这个类装载器装载到命名空间中了，如果已经被装载，直接返回；</span></span><br><span class="line">		Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(c ==<span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="comment">//委派类加载器请求给父类加载器，如果父类加载器能够完成，则返回父类加载器加载的Class实例；</span></span><br><span class="line">			ClassLoader parent = <span class="keyword">this</span>.getParent();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				c = parent.loadClass(name);</span><br><span class="line">				<span class="comment">//加异常处理，父类加载不到，然后自己加载</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//调用本类加载器的findClass()方法，试图获取对应的字节码，如果获取的到，则调用defineClass()导入类型到方法区；</span></span><br><span class="line">			<span class="comment">//如果获取不到对应的字节码或其他原因失败，则异常，终止加载过程</span></span><br><span class="line">			<span class="keyword">if</span>(c == <span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">				<span class="keyword">if</span>(classData == <span class="keyword">null</span>)&#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					c = defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//把.class文件的内容读取到一个字节数组中</span></span><br><span class="line">	<span class="comment">//为什么要读取的字节数组中，因为protected final Class&lt;?&gt; defineClass(String name,byte[] b,int off,int len)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String name) &#123;</span><br><span class="line">		String path = rootDir + File.separator + name.replace(<span class="string">"."</span>, File.separator)+<span class="string">".class"</span>;</span><br><span class="line">		InputStream is = <span class="keyword">null</span>;</span><br><span class="line">		ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			is = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">			baos =<span class="keyword">new</span> ByteArrayOutputStream(); </span><br><span class="line">			<span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			<span class="keyword">int</span> len;</span><br><span class="line">			<span class="keyword">while</span>((len = is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">				baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(is!=<span class="keyword">null</span>)&#123;</span><br><span class="line">					is.close();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">		FileClassLoader fsc = <span class="keyword">new</span> FileClassLoader(<span class="string">"D:/atguigu/code"</span>);</span><br><span class="line">		Class&lt;?&gt; uc = fsc.loadClass(<span class="string">"com.atguigu.UserManager"</span>);</span><br><span class="line">		System.out.println(uc);</span><br><span class="line">		</span><br><span class="line">		Class&lt;?&gt; sc = fsc.loadClass(<span class="string">"java.lang.String"</span>);</span><br><span class="line">		System.out.println(sc);</span><br><span class="line">		System.out.println(sc.getClassLoader());<span class="comment">//null,因为委托给父类加载器...一直到引导类加载器</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用类加载器加载资源文件"><a href="#使用类加载器加载资源文件" class="headerlink" title="使用类加载器加载资源文件"></a>使用类加载器加载资源文件</h2><p>ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个Java类，即java.lang.Class类的一个实例。除此之外，ClassLoader还负责加载Java应用所需的资源，如图像文件和配置文件等。</p>
<p>加载类路径下（例如：src下）jdbc.properties资源文件的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">username=root</span><br><span class="line">password=<span class="number">123456</span></span><br><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLoaderProperties</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			pro.load(ClassLoader.getSystemResourceAsStream(<span class="string">"jdbc.properties"</span>));</span><br><span class="line">			System.out.println(pro);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果发布在tomcat中web应用，使用如上代码是无法加载src类路径下的资源文件的，src下的资源文件会随着类被发布到web应用的WEB-INF\classes目录下，而tomcat使用自定义类加载器加载该路径下的内容。那么就需要通过该路径下的类先获取到该自定义加载器对象，然后再调用getSystemResourceAsStream(String name)去加载。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ClassLoader loader = DBUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">  InputStream is = loader.getResourceAsStream(<span class="string">"druid.properties"</span>);</span><br><span class="line">  pro.load(is);</span><br><span class="line">  System.out.println(pro);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="通过反射查看类信息"><a href="#通过反射查看类信息" class="headerlink" title="通过反射查看类信息"></a>通过反射查看类信息</h1><p>Java程序中，所有的对象都有两种类型：编译时类型和运行时类型，而很多时候对象的编译时类型和运行时类型不一致。</p>
<p>例如：我们某些变量或形参的类型是Object类型，但是程序确需要调用该对象运行时类型的方法，该方法不是Object中方法，那么如何解决呢？</p>
<p>为了解决这些问题，程序需要在运行时发现对象和类的真实信息，我们有两种方法：</p>
<p>第一种是在编译和运行时都完全知道类型的具体信息，在这种情况下，我们可以直接先使用instanceof运算符进行判断，再利用强制类型转换符将其转换成运行时类型的变量即可。</p>
<p>第二种是编译时根本无法预知该对象和类的真实信息，程序只能依靠运行时信息来发现该对象和类的真实信息，这就必须使用反射。</p>
<p>因为加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</p>
<h2 id="java-lang-Class"><a href="#java-lang-Class" class="headerlink" title="java.lang.Class"></a>java.lang.Class</h2><h3 id="哪些类型有Class对象"><a href="#哪些类型有Class对象" class="headerlink" title="哪些类型有Class对象"></a>哪些类型有Class对象</h3><p>Class 类的实例表示正在运行的 Java 应用程序中的类和接口。事实上，所有类型都可以表示为Class的实例对象。</p>
<ol>
<li>class：外部类，内部类</li>
<li>interface：接口</li>
<li>[]：数组，所有具有相同元素类型和维数的数组共享同一个Class 对象</li>
<li>enum：枚举</li>
<li>annotation：注解@interface</li>
<li>primitive type：8种基本数据类型</li>
<li>void</li>
</ol>
<h3 id="获得Class对象"><a href="#获得Class对象" class="headerlink" title="获得Class对象"></a>获得Class对象</h3><p>Java程序中可以通过以下四种方式获得Class对象：</p>
<ul>
<li>类型名.class：适用于编译期间已知的任意类型；</li>
<li>调用任意对象的getClass()方法，可以获取该对象的运行时类型的Class对象；</li>
<li>使用Class类的forName(String name)静态方法，该方法需要传入一个字符串参数，该值是某个类的全限定名（全限定名即完整的包.类型名）；该方法适用于除了数组以外的任意引用数据类型；</li>
<li>调用类加载对象的loadClass(String name)该方法需要传入一个字符串参数，该值是某个类的全限定名（全限定名即完整的包.类型名）;</li>
</ul>
<p>方式（1）只适用于编译器间已知的类型，如果某个类型编译期间是已知的，优先考虑这种方式，代码更安全，效率更高；另外基本数据类型和也只能通过该方式获得Class对象；如果某个类型编译期间未知，我们只能通过某种方式获取该类型的全名称的字符串形式，那么就只能选择（3）和（4）了，但是该方法在运行期间仍然无法加载该类的话，会报ClassNotFoundException。对于基本数据类型和数组类型，无法通过第（3）和（4）方式获取。</p>
<p>示例代码：获取Class对象的四种方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</span><br><span class="line">  Class&lt;?&gt; c1 = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  Class&lt;?&gt; c2 = <span class="string">"hello"</span>.getClass();</span><br><span class="line">  Class&lt;?&gt; c3 = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">  Class&lt;?&gt; c4 = ClassLoader.getSystemClassLoader().loadClass(<span class="string">"java.lang.String"</span>);</span><br><span class="line">  System.out.println(c1 == c2);</span><br><span class="line">  System.out.println(c1 == c3);</span><br><span class="line">  System.out.println(c1 == c4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Class&lt;?&gt; c1 = <span class="keyword">int</span><span class="class">.<span class="keyword">class</span></span>;<span class="comment">//基本数据类型</span></span><br><span class="line">  Class&lt;?&gt; c2 = <span class="keyword">void</span><span class="class">.<span class="keyword">class</span></span>;<span class="comment">//void类型</span></span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; c3 = String<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//类</span></span><br><span class="line">  Class&lt;?&gt; c4 = Object<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//类</span></span><br><span class="line">  Class&lt;?&gt; c5 = Class<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//类</span></span><br><span class="line">  Class&lt;?&gt; c6 = Comparable<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//接口</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//只要元素类型与维度一样，就是同一个Class</span></span><br><span class="line">  Class&lt;?&gt; c7 = <span class="keyword">int</span>[]<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  <span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">  <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">  System.out.println(arr1.getClass() == c7);</span><br><span class="line">  System.out.println(arr2.getClass() == c7);</span><br><span class="line">  Class c9 = String[]<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  Class c10 = <span class="keyword">int</span>[][]<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  System.out.println(c7 == c9);</span><br><span class="line">  System.out.println(c7 == c10);</span><br><span class="line"></span><br><span class="line">  Class c11 = Override<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//注解</span></span><br><span class="line">  Class c12 = ElementType<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//枚举</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="从Class中获取信息"><a href="#从Class中获取信息" class="headerlink" title="从Class中获取信息"></a>从Class中获取信息</h2><p>Class类提供了大量实例方法来获取该Class对象所对应类的详细信息，Class类大致包含如下几种方法，下面每种方法都可能包含多个重载的版本。</p>
<p>例如：包、修饰符、类名、父类、父接口、注解，及成员（属性、构造器、方法）等</p>
<p>反射相关的API主要是java.lang.Class和java.lang.reflect包的内容。</p>
<h3 id="获取某个类的加载器"><a href="#获取某个类的加载器" class="headerlink" title="获取某个类的加载器"></a>获取某个类的加载器</h3><ul>
<li><p>public ClassLoader getClassLoader()</p>
<p>返回该类的类加载器。有些实现可能使用 null 来表示引导类加载器。如果此对象表示一个基本类型或 void，则返回 null。</p>
</li>
</ul>
<h3 id="获取包名和类型名"><a href="#获取包名和类型名" class="headerlink" title="获取包名和类型名"></a>获取包名和类型名</h3><ul>
<li><p>public Package getPackage()：获取此类的包。然后可以通过Package实例对象的getName()获取包名。</p>
</li>
<li><p>public String getName()：以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//java.lang.String</span></span><br><span class="line">  System.out.println(String<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">  <span class="comment">//int</span></span><br><span class="line">  System.out.println(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">  <span class="comment">//[I</span></span><br><span class="line">  System.out.println(<span class="keyword">int</span>[]<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">  <span class="comment">//[[[I</span></span><br><span class="line">  System.out.println(<span class="keyword">int</span>[][][]<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">  <span class="comment">//[Ljava.lang.Object;</span></span><br><span class="line">  System.out.println(Object[]<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果此类对象表示的是非数组类型的引用类型，则返回该类的二进制名称，即包.类名。</p>
<p>如果此类对象表示一个基本类型或 void，则返回该基本类型或 void 所对应的 Java 语言关键字相同的字符串名称。 </p>
<p>如果此类对象表示一个数组类，则名字的内部形式为：表示该数组嵌套深度的一个或多个 ‘[‘ 字符加元素类型名。元素类型名的编码如下： </p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Type    Encoding</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>B</td>
</tr>
<tr>
<td>short</td>
<td>S</td>
</tr>
<tr>
<td>int</td>
<td>I</td>
</tr>
<tr>
<td>long</td>
<td>L</td>
</tr>
<tr>
<td>float</td>
<td>F</td>
</tr>
<tr>
<td>double</td>
<td>D</td>
</tr>
<tr>
<td>boolean</td>
<td>Z</td>
</tr>
<tr>
<td>char</td>
<td>C</td>
</tr>
<tr>
<td>class or interface</td>
<td>Lclassname;</td>
</tr>
</tbody></table>
<h3 id="获取类型修饰符"><a href="#获取类型修饰符" class="headerlink" title="获取类型修饰符"></a>获取类型修饰符</h3><ul>
<li>public int getModifiers()：返回此类或接口以整数编码的 Java 语言修饰符。</li>
</ul>
<p>修饰符由 Java 虚拟机的 public、protected、private、final、static、abstract 和 interface 对应的常量组成；它们应当使用 Modifier 类的方法来解码。 </p>
<p>如果底层类是数组类，则其 public、private 和 protected 修饰符与其组件类型的修饰符相同。如果此 Class 表示一个基本类型或 void，则其 public 修饰符始终为 true，protected 和 private 修饰符始终为 false。如果此对象表示一个数组类、一个基本类型或 void，则其 final 修饰符始终为 true，其接口修饰符始终为 false。该规范没有给定其他修饰符的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Class&lt;?&gt; clazz = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  <span class="keyword">int</span> mod = clazz.getModifiers();</span><br><span class="line">  System.out.println(Modifier.toString(mod));<span class="comment">//public final</span></span><br><span class="line">  System.out.println(Modifier.isPublic(mod));<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取父类或父接口"><a href="#获取父类或父接口" class="headerlink" title="获取父类或父接口"></a>获取父类或父接口</h3><ul>
<li><p>public Class&lt;? super T&gt; getSuperclass()</p>
<p>返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。如果此 Class 表示 Object 类、一个接口、一个基本类型或 void，则返回 null。如果此对象表示一个数组类，则返回表示该 Object 类的 Class 对象。</p>
</li>
<li><p>public Class&lt;?&gt;[] getInterfaces()</p>
<p>确定此对象所表示的类或接口实现的接口。如果此对象表示一个类，则返回值是一个数组，它包含了表示该类所实现的所有接口的对象。数组中接口对象顺序与此对象所表示的类的声明的 implements 子句中接口名顺序一致。如果此对象表示一个接口，则该数组包含表示该接口扩展的所有接口的对象。数组中接口对象顺序与此对象所表示的接口的声明的 extends 子句中接口名顺序一致。 如果此对象表示一个不实现任何接口的类或接口，则此方法返回一个长度为 0 的数组。如果此对象表示一个基本类型或 void，则此方法返回一个长度为 0 的数组。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">  System.out.println(Integer<span class="class">.<span class="keyword">class</span>.<span class="title">getSuperclass</span>())</span>;<span class="comment">//Number</span></span><br><span class="line">  System.out.println(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>.<span class="title">getSuperclass</span>())</span>;<span class="comment">//null</span></span><br><span class="line">  System.out.println(Runnable<span class="class">.<span class="keyword">class</span>.<span class="title">getSuperclass</span>())</span>;<span class="comment">//null</span></span><br><span class="line">  System.out.println(<span class="keyword">int</span>[]<span class="class">.<span class="keyword">class</span>.<span class="title">getSuperclass</span>())</span>;<span class="comment">//Object</span></span><br><span class="line">  System.out.println(String[]<span class="class">.<span class="keyword">class</span>.<span class="title">getSuperclass</span>())</span>;<span class="comment">//Object</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Class&lt;?&gt; clazz = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line">  <span class="keyword">for</span> (Class&lt;?&gt; inter : interfaces) &#123;</span><br><span class="line">    System.out.println(inter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取内部类或外部类信息"><a href="#获取内部类或外部类信息" class="headerlink" title="获取内部类或外部类信息"></a>获取内部类或外部类信息</h3><ul>
<li><p>public Class&lt;?&gt;[] getClasses()</p>
<p>返回所有公共内部类和内部接口。包括从超类继承的公共类和接口成员以及该类声明的公共类和接口成员。</p>
</li>
<li><p>public Class&lt;?&gt;[] getDeclaredClasses()</p>
<p>返回 Class 对象的一个数组，这些对象反映声明为此 Class 对象所表示的类的成员的所有类和接口。包括该类所声明的公共、保护、默认（包）访问及私有类和接口，但不包括继承的类和接口。</p>
</li>
<li><p>public Class&lt;?&gt; getDeclaringClass()</p>
<p>如果此 Class 对象所表示的类或接口是一个内部类或内部接口，则返回它的外部类或外部接口，否则返回null。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Class&lt;?&gt; clazz = Map<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  Class&lt;?&gt;[] inners = clazz.getDeclaredClasses();</span><br><span class="line">  <span class="keyword">for</span> (Class&lt;?&gt; inner : inners) &#123;</span><br><span class="line">    System.out.println(inner);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; ec = Map.Entry<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  Class&lt;?&gt; outer = ec.getDeclaringClass();</span><br><span class="line">  System.out.println(outer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><p>四个方法用于访问Class对应类所包含的属性（Field）：</p>
<ul>
<li><p>public Field[] getFields()</p>
<p>返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段。返回数组中的元素没有排序，也没有任何特定的顺序。包括继承的公共字段。</p>
</li>
<li><p>public Field getField(String name)</p>
<p>返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段。包括继承的公共字段。name 参数是一个 String，用于指定所需字段的简称。</p>
</li>
<li><p>public Field[] getDeclaredFields()</p>
<p>返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段。包括公共、保护、默认（包）访问和私有字段，但不包括继承的字段。返回数组中的元素没有排序，也没有任何特定的顺序。</p>
</li>
<li><p>public Field getDeclaredField(String name)</p>
<p>返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Class&lt;?&gt; clazz = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">  <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    <span class="keyword">int</span> mod = field.getModifiers();</span><br><span class="line">    Class&lt;?&gt; type = field.getType();</span><br><span class="line">    String name = field.getName();</span><br><span class="line">    System.out.print(Modifier.toString(mod)+<span class="string">"\t"</span>);</span><br><span class="line">    System.out.println(type.getName()+<span class="string">"\t"</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取构造器"><a href="#获取构造器" class="headerlink" title="获取构造器"></a>获取构造器</h3><p>四个方法用于访问Class对应的类所包含的构造器（Constructor）：</p>
<ul>
<li><p>public Constructor<T> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</p>
<p>构造器名称无需指定，因为它和类名一致。parameterTypes 参数是 Class 对象的一个数组，它按声明顺序标识构造方法的形参类型。 如果此 Class 对象表示非静态上下文中声明的内部类，则形参类型作为第一个参数包括显示封闭的实例。</p>
</li>
<li><p>public Constructor&lt;?&gt;[] getDeclaredConstructors()</p>
<p>它们是公共、保护、默认（包）访问和私有构造方法。</p>
</li>
<li><p>public Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes)</p>
<p>指定公共构造方法</p>
</li>
<li><p>public Constructor&lt;?&gt;[] getConstructors()</p>
<p>所有公共构造方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConstructor</span></span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Outer<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();</span><br><span class="line">    System.out.println(constructor);<span class="comment">//无参构造</span></span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; c = Outer.Inner<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    <span class="comment">//因为Inner是非静态的内部类，所以它的构造器，默认第一个形参是外部类的实例对象</span></span><br><span class="line">    Constructor&lt;?&gt; cs = c.getDeclaredConstructor(Outer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(cs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Class&lt;?&gt; clazz = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  Constructor&lt;?&gt;[] constructors = clazz.getConstructors();</span><br><span class="line">  <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">    <span class="keyword">int</span> mod = constructor.getModifiers();</span><br><span class="line">    String name = constructor.getName();</span><br><span class="line">    Class&lt;?&gt;[] parameterTypes = constructor.getParameterTypes();</span><br><span class="line">    System.out.print(Modifier.toString(mod)+<span class="string">"\t"</span> + name + <span class="string">"("</span>);</span><br><span class="line">    System.out.println(Arrays.toString(parameterTypes)+<span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><p>四个方法用于访问Class对应的类所包含的方法（Method）：</p>
<ul>
<li><p>public Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes)</p>
<p>name 参数是一个 String，它指定所需方法的简称，parameterTypes 参数是 Class 对象的一个数组或0~n个Class对象，它按声明顺序标识该方法的<strong>形参类型</strong>。如果是无参方法，那么parameterTypes 可以不传或者传null。因为可能存在重载的方法，所以在一个类中唯一确定一个方法，需要方法名和形参类型列表。</p>
</li>
<li><p>public Method[] getDeclaredMethods()</p>
<p>包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</p>
</li>
<li><p>public Method getMethod(String name,Class&lt;?&gt;… parameterTypes)</p>
<p>指定的公共成员方法。包括继承的公共方法。</p>
</li>
<li><p>public Method[] getMethods()</p>
<p>所有公共成员方法。包括继承的公共方法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Class&lt;?&gt; clazz = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  Method[] methods = clazz.getMethods();</span><br><span class="line">  <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    <span class="keyword">int</span> mod = method.getModifiers();</span><br><span class="line">    Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">    String name = method.getName();</span><br><span class="line">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">    System.out.print(Modifier.toString(mod)+<span class="string">"\t"</span> + returnType + <span class="string">"\t"</span> + name + <span class="string">"("</span>);</span><br><span class="line">    System.out.println(Arrays.toString(parameterTypes)+<span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取泛型父类"><a href="#获取泛型父类" class="headerlink" title="获取泛型父类"></a>获取泛型父类</h3><p>JDK1.5引入的泛型，为了通过反射操作这些泛型，新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType几种类型来代表不能被归一到Class中的类型但是又和原始类型齐名的类型。</p>
<ul>
<li>ParameterizedType:    参数化类型    例如：Father&lt;Integer,String&gt;</li>
<li>GenericArrayType:       泛型数组类型   例如：T[]</li>
<li>TypeVariable:        类型变量    例如：T</li>
<li>WildcardType：    带？(通配符)的泛型的类型      例如： ArrayList&lt;?&gt; 或 ArrayList&lt;? super 下限&gt; 或 ArrayList&lt;? extends 上限&gt;</li>
</ul>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/reflex4.png" alt="reflex"></p>
<p>而在Class类、Field类、Method类等API中增加了很多关于获取泛型信息的方法，例如在Class类中就有很多，其中有一个获取泛型父类的方法：</p>
<ul>
<li>public Type getGenericSuperclass()：返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的直接超类的 Type。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGenericSuperClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; c = Base<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    TypeVariable&lt;?&gt;[] typeParameters = c.getTypeParameters();</span><br><span class="line">    <span class="keyword">for</span> (TypeVariable&lt;?&gt; typeVariable : typeParameters) &#123;</span><br><span class="line">      System.out.println(typeVariable + <span class="string">"，上限："</span> + typeVariable.getBounds()[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;Sub&gt; clazz = Sub<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    Type gs = clazz.getGenericSuperclass();</span><br><span class="line"></span><br><span class="line">    ParameterizedType gt = (ParameterizedType)gs;</span><br><span class="line">    Type[] types = gt.getActualTypeArguments();</span><br><span class="line">    <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">      System.out.println(type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取注解信息"><a href="#获取注解信息" class="headerlink" title="获取注解信息"></a>获取注解信息</h3><p>可以通过反射API，获得相关的注解信息。</p>
<ul>
<li><p>public Annotation[] getAnnotations() </p>
<p>返回此元素上存在的所有注释。</p>
</li>
<li><p>public Annotation[] getDeclaredAnnotations()</p>
<p>获取某元素上存在的所有注释。该方法将忽略继承的注释。</p>
</li>
<li><p>public <T extends Annotation> T getAnnotation(Class<T> annotationClass)</p>
<p>如果存在该元素的指定类型的注释，则返回这些注释，否则返回 null。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnnotation</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Class&lt;?&gt; clazz = MyClass<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		MyAnnotation my = clazz.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		System.out.println(my.value());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyAnnotation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "尚硅谷"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提示：要想通过反射获取到某个注解的信息，该注解声明时必须加@Retention(RetentionPolicy.<strong>RUNTIME</strong>)元注解，表明滞留注解信息到运行时。</p>
<h1 id="使用反射生成并操作对象"><a href="#使用反射生成并操作对象" class="headerlink" title="使用反射生成并操作对象"></a>使用反射生成并操作对象</h1><h2 id="使用反射创建对象"><a href="#使用反射创建对象" class="headerlink" title="使用反射创建对象"></a>使用反射创建对象</h2><p>通过反射来生成对象有如下两种方式：</p>
<p>方式一：使用Class对象的newInstance()方法来创建该Class对象对应类的实例，这种方式要求该Class对象的对应类有默认构造器，而执行newInstance()方法时实际上是利用默认构造器来创建该类的实例。</p>
<p>方式二：先使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance(Object… args)方法来创建该Class对象对应类的实例。通过这种方式可以选择使用某个类的指定构造器来创建实例。</p>
<p>通过第一种方式来创建对象是比较常见的情形，因为在很多JavaEE框架中都需要根据配置文件信息来创建实例对象，从配置文件读取的只是某个类的字符串类名，程序就需要根据该字符串来创建对应的实例，就必须使用反射。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNewInstance</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.unclehe.reflect.Student"</span>);</span><br><span class="line">		Object obj = clazz.newInstance();</span><br><span class="line">		System.out.println(obj);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.unclehe.reflect.Student"</span>);</span><br><span class="line">		Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		Object obj = constructor.newInstance(<span class="string">"佟刚"</span>);</span><br><span class="line">		System.out.println(obj);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Student [name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取或设置某个对象的属性值"><a href="#获取或设置某个对象的属性值" class="headerlink" title="获取或设置某个对象的属性值"></a>获取或设置某个对象的属性值</h2><p>通过Class对象的getFields()等方法可以获取该类所包括的全部Field（属性）或指定Field。而Field类除了提供获取属性的修饰符、属性类型、属性名等方法外，还提供了如下两组方法来访问属性：</p>
<ul>
<li><p>public xxx getXxx(Object obj)</p>
<p>获取obj对象该Field的属性值。此处的Xxx对应8种基本数据类型，如果该属性的类型是引用数据类型，则直接使用get(Object obj)方法。</p>
</li>
<li><p>public void setXxx(Object obj,Xxx value)</p>
<p>设置obj对象该Field的属性值为value。此处的Xxx对应8种基本数据类型，如果该属性的类型是引用数据类型，则直接使用set(Object obj, Object value)方法。</p>
</li>
<li><p>public void setAccessible(boolean flag)启动和禁用访问安全检查的开关。</p>
<ul>
<li>值为true则指示反射的对象在使用时应该取消Java语言访问检查。<ul>
<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true.</li>
<li>使得原本无法访问的私有成员也可以访问</li>
</ul>
</li>
<li>值为false则指示反射的对象应该实施Java语言访问检查。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestField</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.atguigu.reflect.Circle"</span>);</span><br><span class="line">		Object obj = clazz.newInstance();</span><br><span class="line">		Field field = clazz.getDeclaredField(<span class="string">"radius"</span>);</span><br><span class="line">		field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">		field.set(obj, <span class="number">1.2</span>);</span><br><span class="line">		Object value = field.get(obj);</span><br><span class="line">		System.out.println(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>当获得某个类对应的Class对象后，就可以通过该Class对象的getMethods()等方法获取全部方法或指定方法。每个Method对象对应一个方法，获得Method对象后，程序就可以通过该Method对象的invoke方法来调用对应方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.atguigu.reflect.Utils"</span>);</span><br><span class="line">    Object obj = clazz.newInstance();</span><br><span class="line">    Method method = clazz.getMethod(<span class="string">"check"</span>, String<span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    Object value = method.invoke(obj, <span class="string">"tong"</span>,<span class="string">"666"</span>);</span><br><span class="line">    System.out.println(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utils</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String user,String password)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"admin"</span>.equals(user) &amp;&amp; <span class="string">"123"</span>.equals(password))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="操作数组"><a href="#操作数组" class="headerlink" title="操作数组"></a>操作数组</h2><p>在java.lang.reflect包下还提供了一个Array类，Array对象可以代表所有的数组。程序可以通过使用Array类来动态的创建数组，操作数组元素等。</p>
<p>Array类提供了如下几个方法：</p>
<ul>
<li><p>public static Object newInstance(Class&lt;?&gt; componentType, int… dimensions)</p>
<p>创建一个具有指定的组件类型和维度的新数组。</p>
</li>
<li><p>public static void setXxx(Object array,int index,xxx value)</p>
<p>将array数组中[index]元素的值修改为value。此处的Xxx对应8种基本数据类型，如果该属性的类型是引用数据类型，则直接使用set(Object array,int index, Object value)方法。</p>
</li>
<li><p>public static xxx getXxx(Object array,int index,xxx value)</p>
<p>将array数组中[index]元素的值返回。此处的Xxx对应8种基本数据类型，如果该属性的类型是引用数据类型，则直接使用get(Object array,int index)方法。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArray</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Object arr = Array.newInstance(String<span class="class">.<span class="keyword">class</span>, 5)</span>;</span><br><span class="line">		Array.set(arr, <span class="number">0</span>, <span class="string">"哈哈哈"</span>);</span><br><span class="line">		Array.set(arr, <span class="number">1</span>, <span class="string">"嘻嘻"</span>);</span><br><span class="line">		System.out.println(Array.get(arr, <span class="number">0</span>));</span><br><span class="line">		System.out.println(Array.get(arr, <span class="number">1</span>));</span><br><span class="line">		System.out.println(Array.get(arr, <span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>在Java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口可以生成JDK动态代理类或动态代理对象。</p>
<p>Proxy提供用于创建动态代理类和代理对象的静态方法，它也是所有动态代理类的父类。如果我们在程序中为一个或多个接口动态地生成实现类，就可以使用Proxy来创建动态代理类或它们的实例。</p>
<ul>
<li><p>public static Class<?>  getProxyClass(ClassLoader loader, Class<?>… interfaces)</p>
<p>创建一个动态代理类所对应的Class对象</p>
</li>
<li><p>public static Object  newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</p>
<p>直接创建一个动态代理对象。第一个参数，被代理类的类加载器对象，第二个参数，被代理类实现的接口们，第三个参数，代理类代理工作处理器对象。</p>
</li>
</ul>
<p>InvocationHandler接口，有一个invoke方法需要实现，该invoke方法中三个参数分别是proxy，代表动态代理对象，method，代表正在执行的方法，args，代表执行代理对象的方法时传入的实参。</p>
<p>案例需求：我需要在所有的Dog，Person，Bird等接口的实现类所有实现方法加上统计方法的执行时间，并要求不修改这些实现类的代码。</p>
<p>接口们：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">think</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实现类们：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TibetanMastiff</span> <span class="keyword">implements</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"藏獒在叫"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"藏獒在跑"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"中国人在学习"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">think</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"中国人在思考"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Magpie</span> <span class="keyword">implements</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"喜鹊在跳来跳去"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"喜鹊飞来了"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理类处理器，必须实现InvocationHandler接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TimeInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"开始计时..."</span>);</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		Object returnValue = method.invoke(target, args);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">"方法执行时间："</span> + (end-start));</span><br><span class="line">		<span class="keyword">return</span> returnValue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态创建代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		TibetanMastiff target = <span class="keyword">new</span> TibetanMastiff();</span><br><span class="line">		Class&lt;?&gt; clazz = TibetanMastiff<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		TimeInvocationHandler handler = <span class="keyword">new</span> TimeInvocationHandler(target);</span><br><span class="line">		Dog dog = (Dog) Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), handler);</span><br><span class="line">		dog.bark();</span><br><span class="line">		dog.run();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Chinese target = <span class="keyword">new</span> Chinese();</span><br><span class="line">		Class&lt;?&gt; clazz = Chinese<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		TimeInvocationHandler handler = <span class="keyword">new</span> TimeInvocationHandler(target);</span><br><span class="line">		Person person = (Person) Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), handler);</span><br><span class="line">		person.study();</span><br><span class="line">		person.think();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Magpie target = <span class="keyword">new</span> Magpie();</span><br><span class="line">		Class&lt;?&gt; clazz = Magpie<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		TimeInvocationHandler handler = <span class="keyword">new</span> TimeInvocationHandler(target);</span><br><span class="line">		Bird bird = (Bird) Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), handler);</span><br><span class="line">		bird.jump();</span><br><span class="line">		bird.fly();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态代理对象需要实现一个或多个接口的方法时，它是如何知道怎么实现这些方法的呢？实际上它实现的方法体，其实就是执行InvocationHandler对象的invoke()方法。</p>
<p>不难发现，使用动态代理可以非常灵活的实现解耦合，这种动态代理在Spring框架体系的AOP（Aspect Orient Program，即面向切面编程）里被称为AOP代理，AOP代理可替代目标对象，AOP代理包含了目标对象的全部方法。但AOP代理中的方法与目标对象的方法存在差异：AOP代理里的方法可以在执行目标方法之前、后插入一下通用处理。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Uncle He</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.unclehe.net/2020/06/24/java-reflex/">https://www.unclehe.net/2020/06/24/java-reflex/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.unclehe.net" target="_blank">Uncle He</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8F%8D%E5%B0%84/">反射</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/cover/java.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/wechat.jpg" alt="wechat"/><div class="post-qr-code__desc">wechat</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/alipay.jpg" alt="alipay"/><div class="post-qr-code__desc">alipay</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/27/java-lambda/"><img class="prev_cover" data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/cover/java.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Lambda表达式与StreamAPI</div></div></a></div><div class="next-post pull_right"><a href="/2020/06/23/java-network-programming/"><img class="next_cover" data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/cover/java.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">网络编程</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'kJLrzEh54hbM7O4kjF6VhlAt-MdYXbMMI',
  appKey: 'wbsLMRTmGNJ2wpVv2Xtvo17B',
  notify: false,
  verify: false,
  placeholder: '昵称请填写QQ号会自动获取头像和昵称...',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: true,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/cover/java.jpeg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Uncle He</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://www.unclehe.net/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode far fa-moon" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/js/customjs.js"></script></body></html>