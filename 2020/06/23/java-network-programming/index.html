<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>网络编程 | Uncle He</title><meta name="description" content="网络编程的基本知识网络的概念和分类所谓计算机网络就是把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源。 生活在今天的我们，没有网络那是相当可怕的，我们每天几乎都在用所谓的云计算、云服务、云备份、搜索引擎检索信息、即时通信、在线支付…… 计算机网络有很多种，按照网络的传输介质划分：双绞线"><meta name="keywords" content="网络编程"><meta name="author" content="Uncle He"><meta name="copyright" content="Uncle He"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="网络编程"><meta name="twitter:description" content="网络编程的基本知识网络的概念和分类所谓计算机网络就是把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源。 生活在今天的我们，没有网络那是相当可怕的，我们每天几乎都在用所谓的云计算、云服务、云备份、搜索引擎检索信息、即时通信、在线支付…… 计算机网络有很多种，按照网络的传输介质划分：双绞线"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/java.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="网络编程"><meta property="og:url" content="https://www.unclehe.net/2020/06/23/java-network-programming/"><meta property="og:site_name" content="Uncle He"><meta property="og:description" content="网络编程的基本知识网络的概念和分类所谓计算机网络就是把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源。 生活在今天的我们，没有网络那是相当可怕的，我们每天几乎都在用所谓的云计算、云服务、云备份、搜索引擎检索信息、即时通信、在线支付…… 计算机网络有很多种，按照网络的传输介质划分：双绞线"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/java.jpeg"><meta property="article:published_time" content="2020-06-23T06:04:28.000Z"><meta property="article:modified_time" content="2020-06-24T03:59:00.041Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = 'false'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="https://www.unclehe.net/2020/06/23/java-network-programming/"><link rel="prev" title="反射" href="https://www.unclehe.net/2020/06/24/java-reflex/"><link rel="next" title="IO流" href="https://www.unclehe.net/2020/06/21/java-io/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://unclehe.net/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: Uncle He","link":"链接: ","source":"来源: Uncle He","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"top-right"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'true',
  isFontAwesomeV5: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/css/customcss.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="https://unclehe.gitee.io" target="_blank" rel="noopener"><i class="fa-fw fa fa-toolbox"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#网络编程的基本知识"><span class="toc-number">1.</span> <span class="toc-text">网络编程的基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#网络的概念和分类"><span class="toc-number">1.1.</span> <span class="toc-text">网络的概念和分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络协议"><span class="toc-number">1.2.</span> <span class="toc-text">网络协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP地址"><span class="toc-number">1.3.</span> <span class="toc-text">IP地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#端口号"><span class="toc-number">1.4.</span> <span class="toc-text">端口号</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基本的网络API"><span class="toc-number">2.</span> <span class="toc-text">基本的网络API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用InetAddress"><span class="toc-number">2.1.</span> <span class="toc-text">使用InetAddress</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用URL"><span class="toc-number">2.2.</span> <span class="toc-text">使用URL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用URLConnection"><span class="toc-number">2.3.</span> <span class="toc-text">使用URLConnection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket"><span class="toc-number">2.4.</span> <span class="toc-text">Socket</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基于TCP协议的网络编程"><span class="toc-number">3.</span> <span class="toc-text">基于TCP协议的网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基于TCP协议的网络通信程序结构"><span class="toc-number">3.1.</span> <span class="toc-text">基于TCP协议的网络通信程序结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP协议编程示例一"><span class="toc-number">3.2.</span> <span class="toc-text">TCP协议编程示例一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP协议编程示例二"><span class="toc-number">3.3.</span> <span class="toc-text">TCP协议编程示例二</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP协议编程示例三"><span class="toc-number">3.4.</span> <span class="toc-text">TCP协议编程示例三</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP协议编程示例四"><span class="toc-number">3.5.</span> <span class="toc-text">TCP协议编程示例四</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP协议编程示例五"><span class="toc-number">3.6.</span> <span class="toc-text">TCP协议编程示例五</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP协议编程示例六"><span class="toc-number">3.7.</span> <span class="toc-text">TCP协议编程示例六</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP协议编程示例七"><span class="toc-number">3.8.</span> <span class="toc-text">TCP协议编程示例七</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基于UDP协议的网络编程"><span class="toc-number">4.</span> <span class="toc-text">基于UDP协议的网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基于UDP协议的网络编程-1"><span class="toc-number">4.1.</span> <span class="toc-text">基于UDP协议的网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#“发送端”"><span class="toc-number">4.1.1.</span> <span class="toc-text">“发送端”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#“接收端”"><span class="toc-number">4.1.2.</span> <span class="toc-text">“接收端”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用MulticastSocket实现多点广播"><span class="toc-number">4.2.</span> <span class="toc-text">使用MulticastSocket实现多点广播</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/java.jpeg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Uncle He</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="https://unclehe.gitee.io" target="_blank" rel="noopener"><i class="fa-fw fa fa-toolbox"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">网络编程</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-23 14:04:28"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-06-23</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-06-24 11:59:00"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-06-24</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%87%AA%E5%AD%A6Java/">自学Java</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%87%AA%E5%AD%A6Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon far fa-file-word" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">12.5k</span><span class="post-meta__separator">|</span><i class="post-meta__icon far fa-clock" aria-hidden="true"></i><span>阅读时长: 47 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon far fa-comments" aria-hidden="true"></i><span>评论数:</span><a href="/2020/06/23/java-network-programming/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/06/23/java-network-programming/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="网络编程的基本知识"><a href="#网络编程的基本知识" class="headerlink" title="网络编程的基本知识"></a>网络编程的基本知识</h1><h2 id="网络的概念和分类"><a href="#网络的概念和分类" class="headerlink" title="网络的概念和分类"></a>网络的概念和分类</h2><p>所谓计算机网络就是把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源。</p>
<p>生活在今天的我们，没有网络那是相当可怕的，我们每天几乎都在用所谓的云计算、云服务、云备份、搜索引擎检索信息、即时通信、在线支付……</p>
<p>计算机网络有很多种，按照网络的传输介质划分：双绞线网、同轴电缆网、光纤网、卫星网等。还有无线传输的，例如Wifi的传输介质是红外线，蓝牙的传输介质是无线电波，都是电磁波的一种。</p>
<p>如果按照网络的拓扑结构来划分，可以分为星型网络、总线网络、环线网络、树型网络、网状网络、混合型网络等。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/network-programming1.png" alt="network-programming"></p>
<p>按照规模来分类</p>
<ul>
<li>局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。</li>
<li>城域网(Metropolitan Area Network，MAN)是在一个城市范围内所建立的计算机通信网，属宽带局域网。由于采用具有有源交换元件的局域网技术，网中传输时延较小，它的传输媒介主要采用光缆，传输速率在100兆比特/秒以上。MAN的一个重要用途是用作骨干网，通过它将位于同一城市内不同地点的主机、数据库，以及LAN等互相联接起来，这与WAN的作用有相似之处，但两者在实现方法与性能上有很大差别。</li>
<li>广域网（Wide Area Network， WAN），又称外网、公网，是连接不同地区局域网或城域网计算机通信的远程网。通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个地区、城市和国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。</li>
</ul>
<p><strong>那么什么是互联网、因特网、万维网呢？</strong></p>
<p>凡是由能彼此通信的设备组成的网络就叫互联网，即使仅有两台机器（计算机、手机等），不论用何种技术使其彼此通信，都叫互联网，所以，互联网有广域网、城域网及局域网之分。国际标准的互联网写法是internet，字母i小写！</p>
<p>而因特网是互联网中的一种，它可不是仅有两台机器组成的网络，而是由上千万台设备组成的网络（该网络具备一定规模）。国际标准的因特网写法是Internet，字母I大写！</p>
<p>因特网是基于TCP/IP协议实现的，TCP/IP协议由很多协议组成，不同类型的协议又被放在不同的层，其中，位于应用层的协议就有很多，比如FTP、SMTP、HTTP。所以，因特网提供的服务一般包括有：www（万维网）服务、电子邮件服务（outlook）、远程登录（QQ）服务、文件传输（FTP）服务、网络电话等等。只要应用层使用的是HTTP协议，就称为万维网(World Wide Web)。</p>
<h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>不管处于那种网络，那么通信是网络最基本的要求，而计算机网络中实现通信必须有一些约定，即通信协议。对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准。</p>
<p>网络通信必须有硬件和软件方面的支持，由于世界上大型计算机厂商推出各自不同的网络体系结构，影响了网络通信的统一性，因此国际标准化组织ISO于1978年提出了著名的OSI（Open System Interconnection）开放系统互连参考模型。它把计算机网络分成物理层、数据链路层、网络层、传输层、会话层、表示层、应用层等七层。</p>
<ul>
<li>应用层：网络服务与最终用户的一个接口。协议有：HTTP、FTP、SMTP、DNS、TELNET、HTTPS、POP3等等。</li>
<li>表示层：数据的表示、安全、压缩。格式有：JPEG、ASCll、DECOIC、加密格式等。</li>
<li>会话层：建立、管理、终止会话。对应主机进程，指本地主机与远程主机正在进行的会话</li>
<li>传输层：定义传输数据的协议端口号，以及流控和差错校验。协议有：TCP、UDP。</li>
<li>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。协议有：ICMP、IGMP、IP（IPV4 IPV6）、ARP、RARP。</li>
<li>数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正</li>
<li>物理层：建立、维护、断开物理连接。</li>
</ul>
<p>而IP协议是一种非常重要的协议。IP（internet protocal）又称为互联网协议。IP的责任就是把数据从源传送到目的地。它在源地址和目的地址之间传送一种称之为数据包的东西，它还提供对数据大小的重新组装功能，以适应不同网络对包大小的要求。经常与IP协议放在一起的还有TCP（Transmission Control Protocol）协议，即传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。而通常我们说的TCP/IP协议，其实是指TCP/IP协议族，因为该协议家族的两个最核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准，所以简称为TCP/IP协议。</p>
<p>按照TCP/IP协议模型，网络通常被分为四层：网络访问层、互联网层、传输层和应用层。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/network-programming2.png" alt="network-programming"></p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址用于标识网络中的一个通信实体，这个通信实体可以是一台计算机，也可以是一台打印机，或者是路由器的一个端口。而在基于IP协议网络中传输的数据包，都必须使用IP地址来进行标识。</p>
<p>如同我们写信，发快递一样，要标明收件人的通信地址和发件人的通信地址，而邮政人员和物流快递员则通过该地址决定信件、包裹的去向。</p>
<p>IP地址是一个32位的整数，但为了便于记忆，通常把它分为4个8位的二进制数组成，每8位之间用圆点隔开，格式：X.X.X.X，其中每个X表示地址中的8位，用十进制[0,255]之间值表示，因此我们看到的IP常常是：222.222.88.104。</p>
<p>Internet委员会定义了5种IP地址类型以适合不同容量的网络，即A类~E类。其中A、B、C这3类由Internet NIC在全球范围内统一分配，D、E类为特殊地址。</p>
<table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">最大网络数</th>
<th align="center">IP地址范围</th>
<th align="center">最大主机数</th>
<th align="center">私有IP地址范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">126(2^7-2)</td>
<td align="center">0.0.0.0-255.255.255.255</td>
<td align="center">16777214</td>
<td align="center">10.0.0.0-255.255.255.255</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">16384(2^14)</td>
<td align="center">128.0.0.0-191.255.255.255</td>
<td align="center">65534</td>
<td align="center">172.16.0.0-172.31.255.255</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">2097152(2^21)</td>
<td align="center">192.0.0.0-223.255.255.255</td>
<td align="center">254</td>
<td align="center">192.168.0.0-192.168.255.255</td>
</tr>
</tbody></table>
<p>IP地址还分为IPV4和IPV6。由于IPv4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。IPv6是IETF（Internet Engineering Task Force）设计的用于替代现行版本IP协议（IPv4）的下一代IP协议，号称可以为全世界的每一粒沙子编上一个网址。IPv4和IPv6地址格式不相同，因此在很长一段时间里，互联网中出现IPv4和IPv6长期共存的局面。2012年6月6日，国际互联网协会举行了世界IPv6启动纪念日，这一天，全球IPv6网络正式启动。多家知名网站，如Google、Facebook和Yahoo等，于当天全球标准时间0点（北京时间8点整）开始永久性支持IPv6访问。2018年6月，三大运营商联合阿里云宣布，将全面对外提供IPv6服务，并计划在2025年前助推中国互联网真正实现“IPv6 Only”。 7月，百度云制定了中国的IPv6改造方案。8月3日，工信部通信司在北京召开IPv6规模部署及专项督查工作全国电视电话会议，中国将分阶段有序推进规模建设IPv6网络，实现下一代互联网在经济社会各领域深度融合。</p>
<p>IPv6的地址长度为128位，是IPv4地址长度的4倍，格式为X:X:X:X:X:X:X:X，其中每个X表示地址中的16位，以十六进制表示。</p>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>IP地址可以唯一的确定网络上的一个通信实体，但是一个通信实体可以有多个通信程序同时提供网络服务，此时还需要使用端口。IP地址就好比通信的街道和门牌号，我们通过IP地址可以找到房子，但是要具体找到某个人，还需要房间号或名字。</p>
<p>端口号是一个16位的整数，即在[0,65535]之间，通常它可以分为三类：</p>
<ol>
<li><p>公认端口（Well-Known Ports）范围从0到1023，这些端口号一般固定分配给一些服务。比如21端口分配给FTP(文件传输协议)服务，25端口分配给SMTP（简单邮件传输协议）服务，80端口分配给HTTP服务。</p>
</li>
<li><p>注册端口（Registered Ports）：端口号从1024到49151。它们松散地绑定于一些服务。例如：Tomcat(8080)，JBOSS(8080)，Oracle（1521）,MySQL(3306)，SQL Server(1433)，QQ（1080）。</p>
</li>
<li><p>动态/私有端口（Dynamic and/Private Ports）：端口的范围从49152到65535，这些端口号一般不固定分配给某个服务。只要运行的程序向系统提出访问网络的申请，那么系统就可以从这些端口号中分配一个供该程序使用。理论上，不应为服务分配这些端口。</p>
</li>
</ol>
<p>然而实际生活中，要常人识记IP地址还是有些困难的，所以就有了域名。例如：服务器IP地址是222.222.88.113，为了让大家便于记忆和访问，我们注册了域名。域名和IP地址是相对应的，网域名称系统（DNS，Domain Name System）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址数串。</p>
<h1 id="基本的网络API"><a href="#基本的网络API" class="headerlink" title="基本的网络API"></a>基本的网络API</h1><h2 id="使用InetAddress"><a href="#使用InetAddress" class="headerlink" title="使用InetAddress"></a>使用InetAddress</h2><p>此类表示互联网协议 (IP) 地址，它有两个子类Inet4Address和Inet6Address，分别对应IPV4和IPV6。InetAddress类没有提供公共的构造器，而是提供了如下几个静态方法来获取InetAddress实例。</p>
<p><strong>静态方法：</strong></p>
<ul>
<li>public static InetAddress getLocalHost()</li>
<li>public static InetAddress getByAddress(byte[] addr)</li>
<li>public static InetAddress getByName(String host)</li>
</ul>
<p><strong>InetAddress提供了如下几个常用的方法：</strong></p>
<ul>
<li>public String getHostAddress()：返回 IP 地址字符串（以文本表现形式）</li>
<li>public String getHostName()：获取此 IP 地址的主机名</li>
<li>public String getCanonicalHostName()：获取此 IP 地址的完全限定域名</li>
<li>public boolean isReachable(int timeout)：测试是否可以达到该地址。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.ip;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInetAddress</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		InetAddress ip1 = InetAddress.getLocalHost();</span><br><span class="line">		System.out.println(ip1);<span class="comment">//Irene-PC/192.168.1.107</span></span><br><span class="line">		</span><br><span class="line">		InetAddress ip2 = InetAddress.getByName(<span class="string">"www.unclehe.net"</span>);</span><br><span class="line">		System.out.println(ip2);<span class="comment">//www.unclehe.net/222.222.88.102</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">byte</span>[] ip = &#123;(<span class="keyword">byte</span>)<span class="number">222</span>,(<span class="keyword">byte</span>)<span class="number">222</span>,<span class="number">88</span>,<span class="number">102</span>&#125;;</span><br><span class="line">		InetAddress ip3 = InetAddress.getByAddress(ip);</span><br><span class="line">		System.out.println(ip3);<span class="comment">//输出ip而不是域名。如果这个IP地址不存在或DNS服务器不允许进行ip--&gt;域名的映射，getHostName()方法就直接返回这个IP地址</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用URL"><a href="#使用URL" class="headerlink" title="使用URL"></a>使用URL</h2><p>URI(Uniform resource identifier)：表示一个统一资源标识符 (URI) 引用，用来唯一的标识一个资源。</p>
<p>URL(Uniform Resource Locator)：类 URL 代表一个统一资源定位符，它是指向互联网“资源”的指针。资源可以是简单的文件或目录，也可以是对更为复杂的对象的引用，例如对数据库或搜索引擎的查询。它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。URI不能用于定位任何资源，它的唯一作用是解析，而URL则包含一个可打开到达该资源的输入流。 URL的基本结构由5部分组成：</p>
<p>&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名</p>
<p>&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;?参数列表</p>
<p>其中#片段名：即锚点，例如看小说，直接定位到章节</p>
<p>例如：<a href="http://java.sun.com/index.html#chapter1" target="_blank" rel="noopener">http://java.sun.com/index.html#chapter1</a></p>
<p>参数列表格式：参数名=参数值&amp;参数名=参数值….</p>
<p>例如：<a href="http://192.168.1.100:8080/helloworld/index.jsp?username=admin&amp;password=123" target="_blank" rel="noopener">http://192.168.1.100:8080/helloworld/index.jsp?username=admin&amp;password=123</a></p>
<p><strong>URL构造方法：</strong></p>
<ul>
<li><p>public URL (String spec)：通过一个表示URL地址的字符串可以构造一个URL对象。</p>
<p>例如：URL url = new URL (“<a href="http://www.unclehe.net/&quot;">http://www.unclehe.net/&quot;</a>);</p>
</li>
<li><p>public URL(URL context, String spec)：通过基 URL 和相对 URL 构造一个 URL 对象。</p>
<p>例如：URL downloadUrl = new URL(url, “download.html”)</p>
</li>
<li><p>public URL(String protocol, String host, String file); </p>
<p>例如：new URL(“http”, “<a href="http://www.unclehe.net&quot;" target="_blank" rel="noopener">www.unclehe.net&quot;</a>, “download. html”);</p>
</li>
<li><p>public URL(String protocol, String host, int port, String file); </p>
<p>例如: URL gamelan = new URL(“http”, “<a href="http://www.unclehe.net&quot;" target="_blank" rel="noopener">www.unclehe.net&quot;</a>, 80, “download.html”);</p>
</li>
</ul>
<p><strong>URL的常用方法：</strong></p>
<ul>
<li>public String getProtocol()：获取该URL的协议名</li>
<li>public String getHost()：获取该URL的主机名</li>
<li>public String getPort()：获取该URL的端口号</li>
<li>public String getPath()：获取该URL的文件路径，即tomcat的webapps目录下级目录名也就是资源路径名</li>
<li>public String getFile()：获取该URL的文件名</li>
<li>public String getRef()：获取该URL在文件中的相对位置</li>
<li>public String getQuery()：获取该URL的查询名</li>
<li>public final InputStream openStream()：返回一个用于从该连接读入的 InputStream。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestURL</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">		URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com:80/index.html?keyword=java"</span>);</span><br><span class="line">		System.out.println(<span class="string">"协议："</span> + url.getProtocol());</span><br><span class="line">		System.out.println(<span class="string">"主机名："</span> + url.getHost());</span><br><span class="line">		System.out.println(<span class="string">"端口号："</span> + url.getPort());</span><br><span class="line">		System.out.println(<span class="string">"路径名："</span> + url.getPath());</span><br><span class="line">		System.out.println(<span class="string">"文件名："</span> + url.getFile());</span><br><span class="line">		System.out.println(<span class="string">"锚点："</span> + url.getRef());</span><br><span class="line">		System.out.println(<span class="string">"查询名："</span> + url.getQuery());<span class="comment">//注意如果存在锚点，那么查询名返回null，因为#后面全部当做锚点了</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestURLRead</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com/index.html"</span>);</span><br><span class="line">		<span class="comment">/*html标签（格式化数据）、css：皮肤（美化数据）、js：互动（交互数据）、数据：*/</span></span><br><span class="line">		InputStream input = url.openStream();</span><br><span class="line">		<span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">		<span class="keyword">while</span>((len=input.read(data))!=-<span class="number">1</span>)&#123;</span><br><span class="line">			System.out.println(<span class="keyword">new</span> String(data,<span class="number">0</span>,len,<span class="string">"UTF-8"</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		input.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用URLConnection"><a href="#使用URLConnection" class="headerlink" title="使用URLConnection"></a>使用URLConnection</h2><p>URL的方法openStream()，能从网络上读取数据，但是无法给服务器端发送数据，若希望给服务器端发送数据，则需URLConnection。</p>
<p>它代表应用程序和 URL 之间的通信链接。此类的实例可用于读取和写入此 URL 引用的资源。通常，创建一个到 URL 的连接需要几个步骤：</p>
<ol>
<li>通过 URL对象调用 openConnection 方法创建URLConnection连接对象。</li>
<li>处理设置参数和一般请求属性。</li>
<li>使用 connect 方法建立到远程对象的实际连接。</li>
<li>远程对象变为可用。远程对象的头字段和内容变为可访问。</li>
</ol>
<p><strong>URLConnection的常用方法：</strong></p>
<ul>
<li>public void setDoOutput(boolean dooutput)如果打算使用 URL 连接进行输出，例如给服务器传递请求参数，则将 DoOutput 标志设置为 true；如果不打算使用，则设置为 false。默认值为 false。 <code>必须在所有getXXX()和connect()方法之前。</code></li>
<li>public String getContentEncoding()：返回 content-encoding 头字段的值。</li>
<li>public int getContentLength()：返回 content-length 头字段的值。</li>
<li>public String getContentType()：返回 content-type 头字段的值。</li>
<li>public long getDate()：返回 date 头字段的值。</li>
<li>public long getLastModified()：返回 last-modified 头字段的值。结果为距离格林威治标准时间 1970 年 1 月 1 日的毫秒数。</li>
<li>public String getHeaderField(String name)：返回指定的头字段的值。</li>
<li>public InputStream getInputStream()返回从此打开的连接读取的输入流。</li>
<li>public OutputStream getOutputStream()返回写入到此连接的输出流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestURLConnection</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		URL url = <span class="keyword">new</span> URL(<span class="string">"http://localhost/web1/denglu"</span>);</span><br><span class="line">		<span class="comment">//通过 URL对象调用 openConnection 方法创建URLConnection连接对象</span></span><br><span class="line">		URLConnection uc = url.openConnection();</span><br><span class="line">		<span class="comment">//处理设置参数</span></span><br><span class="line">		uc.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">		<span class="comment">//给服务器发送请求参数</span></span><br><span class="line">		uc.getOutputStream().write(<span class="string">"username=admin&amp;password=123"</span>.getBytes());</span><br><span class="line">		<span class="comment">//使用 connect 方法建立到远程对象的实际连接。</span></span><br><span class="line">		uc.connect();</span><br><span class="line">		<span class="comment">//获取资源</span></span><br><span class="line">		InputStream is = uc.getInputStream();</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is,<span class="string">"UTF-8"</span>));</span><br><span class="line">		String str;</span><br><span class="line">		<span class="keyword">while</span>((str=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">		br.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>通信的两端都要有Socket（也可以叫“套接字”），是两台机器间通信的端点。网络通信其实就是Socket间的通信。Socket可以分为：</p>
<ul>
<li>流套接字（stream socket）：使用TCP提供可依赖的字节流服务</li>
<li>数据报套接字（datagram socket）：使用UDP提供“尽力而为”的数据报服务</li>
</ul>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/network-programming3.png" alt="network-programming"></p>
<p><strong>Socket类的常用构造方法：</strong></p>
<ul>
<li>public Socket(InetAddress address,int port)：创建一个流套接字并将其连接到指定 IP 地址的指定端口号。</li>
<li>public Socket(String host,int port)：创建一个流套接字并将其连接到指定主机上的指定端口号。</li>
</ul>
<p><strong>Socket类的常用方法：</strong></p>
<ul>
<li>public InputStream getInputStream()：返回此套接字的输入流，可以用于接收消息</li>
<li>public OutputStream getOutputStream()：返回此套接字的输出流，可以用于发送消息</li>
<li>public InetAddress getInetAddress()：此套接字连接到的远程 IP 地址；如果套接字是未连接的，则返回 null。</li>
<li>public InetAddress getLocalAddress()：获取套接字绑定的本地地址。</li>
<li>public int getPort()：此套接字连接到的远程端口号；如果尚未连接套接字，则返回 0。</li>
<li>public int getLocalPort()：返回此套接字绑定到的本地端口。如果尚未绑定套接字，则返回 -1。</li>
<li>public void close()：关闭此套接字。套接字被关闭后，便不可在以后的网络连接中使用（即无法重新连接或重新绑定）。需要创建新的套接字对象。 关闭此套接字也将会关闭该套接字的 InputStream 和 OutputStream。</li>
<li>public void shutdownInput()：如果在套接字上调用 shutdownInput() 后从套接字输入流读取内容，则流将返回 EOF（文件结束符）。 即不能在从此套接字的输入流中接收任何数据。</li>
<li>public void shutdownOutput()：禁用此套接字的输出流。对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 如果在套接字上调用 shutdownOutput() 后写入套接字输出流，则该流将抛出 IOException。 即不能通过此套接字的输出流发送任何数据。</li>
</ul>
<p>注意：先后调用Socket的shutdownInput()和shutdownOutput()方法，仅仅关闭了输入流和输出流，并不等于调用Socket的close()方法。在通信结束后，仍然要调用Scoket的close()方法，因为只有该方法才会释放Socket占用的资源，比如占用的本地端口号等。</p>
<h1 id="基于TCP协议的网络编程"><a href="#基于TCP协议的网络编程" class="headerlink" title="基于TCP协议的网络编程"></a>基于TCP协议的网络编程</h1><p>TCP(Transmission Control Protocol，传输控制协议)被称作一种端对端协议。是一种面向连接的、可靠的、基于字节流的传输层的通信协议，可以连续传输大量的数据。类似于打电话的效果。</p>
<p>这是因为它为当一台计算机需要与另一台远程计算机连接时，TCP协议会采用“三次握手”方式让它们建立一个连接，用于发送和接收数据的虚拟链路。数据传输完毕TCP协议会采用“四次挥手”方式断开连接。</p>
<p>TCP协议负责收集这些信息包，并将其按适当的次序放好传送，在接收端收到后再将其正确的还原。TCP协议保证了数据包在传送中准确无误。TCP协议使用重发机制，当一个通信实体发送一个消息给另一个通信实体后，需要收到另一个通信实体确认信息，如果没有收到另一个通信实体确认信息，则会再次重复刚才发送的消息。</p>
<h2 id="基于TCP协议的网络通信程序结构"><a href="#基于TCP协议的网络通信程序结构" class="headerlink" title="基于TCP协议的网络通信程序结构"></a>基于TCP协议的网络通信程序结构</h2><p>Java语言的基于套接字TCP编程分为服务端编程和客户端编程</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/network-programming4.png" alt="network-programming"></p>
<p><strong>服务器程序的工作过程包含以下五个基本的步骤：</strong></p>
<ol>
<li>使用 ServerSocket(int port) ：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。</li>
<li>调用 accept()方法：监听连接请求，如果客户端请求连接，则接受连接，创建与该客户端的通信套接字对象。否则该方法将一直处于等待状态。</li>
<li>调用 该Socket对象的 getOutputStream() 和 getInputStream ()：获取输出流和输入流，开始网络数据的发送和接收。</li>
<li>关闭Socket对象：某客户端访问结束，关闭与之通信的套接字。</li>
<li>关闭ServerSocket：如果不再接收任何客户端的连接的话，调用close()进行关闭。</li>
</ol>
<p><strong>客户端Socket的工作过程包含以下四个基本的步骤：</strong></p>
<ol>
<li>创建 Socket：根据指定服务端的 IP 地址或端口号构造 Socket 类对象，创建的同时会自动向服务器方发起连接。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。</li>
<li>打开连接到Socket 的输入/出流：使用 getInputStream()方法获得输入流，使用 getOutputStream()方法获得输出流，进行数据传输。</li>
<li>进行读/写操作：通过输入流读取服务器发送的信息，通过输出流将信息发送给服务器。</li>
<li>关闭 Socket：断开客户端到服务器的连接</li>
</ol>
<p>注意：客户端和服务器端在获取输入流和输出流时要对应，否则容易死锁。例如：客户端先获取字节输出流（即先写），那么服务器端就先获取字节输入流（即先读）；反过来客户端先获取字节输入流（即先读），那么服务器端就先获取字节输出流（即先写）。</p>
<h2 id="TCP协议编程示例一"><a href="#TCP协议编程示例一" class="headerlink" title="TCP协议编程示例一"></a>TCP协议编程示例一</h2><p>一个客户端连接服务器，连接成功后，服务器给客户端发送“欢迎你登录”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TCP：面向连接，可靠的，基于字节流的</span></span><br><span class="line"><span class="comment"> * 		服务器：等待被连接的过程</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * ServerSocket：只负责接受和建立连接，不负责数据的传输</span></span><br><span class="line"><span class="comment"> * Socket：负责数据的传输</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 步骤：</span></span><br><span class="line"><span class="comment"> * 1、开启服务器</span></span><br><span class="line"><span class="comment"> * 	  指定服务器监听的端口号</span></span><br><span class="line"><span class="comment"> * 2、等待客户端并接受客户端的连接</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3、接受/发送数据</span></span><br><span class="line"><span class="comment"> * 发送方：输出流</span></span><br><span class="line"><span class="comment"> * 接受方：输入流</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4、断开连接</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 5、关闭服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1、开启服务器：网卡驱动就监听9999端口号的数据</span></span><br><span class="line">		ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2、等待客户端并接受客户端的连接</span></span><br><span class="line">		Socket socket = server.accept();<span class="comment">//这句代码执行一次，就接受一个客户端连接</span></span><br><span class="line">		System.out.println(<span class="string">"一个客户端连接成功!"</span>);</span><br><span class="line">		<span class="comment">//3、例如：发送数据</span></span><br><span class="line">		<span class="comment">//发送：欢迎你登录</span></span><br><span class="line">		<span class="comment">//字节流，输出流  OutputStream</span></span><br><span class="line">		<span class="comment">//(1)获取输出流</span></span><br><span class="line">		OutputStream out = socket.getOutputStream();</span><br><span class="line">		<span class="comment">//(2)发送数据</span></span><br><span class="line">		out.write(<span class="string">"欢迎你登录"</span>.getBytes());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4、断开连接</span></span><br><span class="line">		socket.close();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//5、关闭服务器</span></span><br><span class="line">		server.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TCP：</span></span><br><span class="line"><span class="comment"> * 	 客户端，主动连接服务器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Socket(InetAddress address, int port) </span></span><br><span class="line"><span class="comment"> * Socket(String host, int port)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 步骤：</span></span><br><span class="line"><span class="comment"> * 1、连接服务器</span></span><br><span class="line"><span class="comment"> * Socket socket = new Socket("192.168.30.142",9999);</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2、发送或接受数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3、断开连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//		1、连接服务器</span></span><br><span class="line">		Socket socket = <span class="keyword">new</span> Socket(<span class="string">"192.168.30.142"</span>,<span class="number">9999</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2、例如：接受数据</span></span><br><span class="line">		<span class="comment">//字节流，输入流，InputStream</span></span><br><span class="line">		InputStream in = socket.getInputStream();</span><br><span class="line">		<span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">		<span class="keyword">while</span>((len = in.read(data)) != -<span class="number">1</span>)&#123;</span><br><span class="line">			System.out.println(<span class="keyword">new</span> String(data,<span class="number">0</span>,len));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3、断开</span></span><br><span class="line">		socket.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TCP协议编程示例二"><a href="#TCP协议编程示例二" class="headerlink" title="TCP协议编程示例二"></a>TCP协议编程示例二</h2><p>一个客户端连接服务器，连接成功后，客户端给服务器先传一个“你好”，服务器给客户端返回“欢迎你登录”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1、开启服务器：网卡驱动就监听9999端口号的数据</span></span><br><span class="line">		ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2、等待客户端并接受客户端的连接</span></span><br><span class="line">		Socket socket = server.accept();<span class="comment">//这句代码执行一次，就接受一个客户端连接</span></span><br><span class="line">		System.out.println(<span class="string">"一个客户端连接成功!"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3、接受数据</span></span><br><span class="line">		InputStream in = socket.getInputStream();</span><br><span class="line">		<span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">		System.out.println(<span class="string">"服务器收到："</span>);</span><br><span class="line">		<span class="keyword">while</span>((len = in.read(data)) != -<span class="number">1</span>)&#123;</span><br><span class="line">			System.out.println(<span class="keyword">new</span> String(data,<span class="number">0</span>,len));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4、例如：发送数据</span></span><br><span class="line">		<span class="comment">//发送：欢迎你登录</span></span><br><span class="line">		<span class="comment">//字节流，输出流  OutputStream</span></span><br><span class="line">		<span class="comment">//(1)获取输出流</span></span><br><span class="line">		OutputStream out = socket.getOutputStream();</span><br><span class="line">		<span class="comment">//(2)发送数据</span></span><br><span class="line">		out.write(<span class="string">"欢迎你登录"</span>.getBytes());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4、断开连接</span></span><br><span class="line">		socket.close();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//5、关闭服务器</span></span><br><span class="line">		server.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//		1、连接服务器</span></span><br><span class="line">		Socket socket = <span class="keyword">new</span> Socket(<span class="string">"192.168.30.142"</span>,<span class="number">9999</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2、例如：发送你好</span></span><br><span class="line">		OutputStream out = socket.getOutputStream();</span><br><span class="line">		out.write(<span class="string">"你好"</span>.getBytes());</span><br><span class="line"><span class="comment">//		out.close();//错误的，如果调用out.close()会导致socket的close()</span></span><br><span class="line">		<span class="comment">//如果仅仅表示不发送了，还要接收，那么选择半关闭，只关闭输出通道</span></span><br><span class="line">		socket.shutdownOutput();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3、例如：接受数据</span></span><br><span class="line">		<span class="comment">//字节流，输入流，InputStream</span></span><br><span class="line">		System.out.println(<span class="string">"客户端收到："</span>);</span><br><span class="line">		InputStream in = socket.getInputStream();</span><br><span class="line">		<span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">		<span class="keyword">while</span>((len = in.read(data)) != -<span class="number">1</span>)&#123;</span><br><span class="line">			System.out.println(<span class="keyword">new</span> String(data,<span class="number">0</span>,len));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3、断开</span></span><br><span class="line">		socket.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TCP协议编程示例三"><a href="#TCP协议编程示例三" class="headerlink" title="TCP协议编程示例三"></a>TCP协议编程示例三</h2><p>一个客户端连接服务器，连接成功后：</p>
<ol>
<li>客户端从键盘输入词语，给服务器发送，直到bye为止；</li>
<li>服务器每次手动词语，反转词语 ，然后返回给客户端，直到接收到bye为止</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 服务器端：</span></span><br><span class="line"><span class="comment"> * 	(1)接收客户端的连接</span></span><br><span class="line"><span class="comment"> *  (2)接收客户端的词语</span></span><br><span class="line"><span class="comment"> *  (3)把词语“反转”返回给客户端</span></span><br><span class="line"><span class="comment"> *  (2)(3)多次，直到客户端发送"bye"为止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1、开启服务器</span></span><br><span class="line">		ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8989</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2、接收一个客户端的连接</span></span><br><span class="line">		Socket socket = server.accept();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3、先获取输入流和输出流</span></span><br><span class="line">		InputStream in = socket.getInputStream();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 因为是接收一个词语，反转一个，返回一个</span></span><br><span class="line"><span class="comment">		 * 那么如果仅仅使用字节流，不好区分词语</span></span><br><span class="line"><span class="comment">		 * 需要用到字符流</span></span><br><span class="line"><span class="comment">		 * 那么就意味着需要把字节流转为字符流</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);<span class="comment">//这里不涉及编码问题，仅仅为了转换流的类型</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 字符流中几个字符是一个词语</span></span><br><span class="line"><span class="comment">		 * 那么我们这里选择“换行符”来作为词语的分割</span></span><br><span class="line"><span class="comment">		 * 意味着我们可以按行读取Scanner或BufferedReader</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">		</span><br><span class="line">		OutputStream out = socket.getOutputStream();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 客户端收到字节，同样不方便处理几个字节是一个词语，仍然要把字节输出流转为字符流</span></span><br><span class="line"><span class="comment">		 * 而且字符之间也不好区分，那么也选择“换行符”进行区别词语</span></span><br><span class="line"><span class="comment">		 * 我们现在需要把OutputStream转为一个可以按行写的字符流或其他的处理流</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 可以按行写的：BufferedWriter(newLine())</span></span><br><span class="line"><span class="comment">		 * 		   PrintStream(println())</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		PrintStream ps = <span class="keyword">new</span> PrintStream(out);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//从客户端接收词语</span></span><br><span class="line">		String word;</span><br><span class="line">		<span class="keyword">while</span>((word = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="string">"bye"</span>.equals(word))&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//如果不是bye，要反转，并且返回</span></span><br><span class="line">			StringBuilder sb = <span class="keyword">new</span> StringBuilder(word);</span><br><span class="line">			sb.reverse();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//返回给客户端</span></span><br><span class="line">			ps.println(sb.toString());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4、断开</span></span><br><span class="line">		socket.close();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//5、关闭服务器</span></span><br><span class="line">		server.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 客户端：</span></span><br><span class="line"><span class="comment"> * （1）从键盘输入词语</span></span><br><span class="line"><span class="comment"> * （2）发送给服务器</span></span><br><span class="line"><span class="comment"> * （3）接收服务器返回的结果</span></span><br><span class="line"><span class="comment"> * （1）（2）（3）多次进行，直到键盘输入bye并发送给发服务器之后就结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1、连接服务器</span></span><br><span class="line">		Socket socket = <span class="keyword">new</span> Socket(<span class="string">"192.168.30.142"</span>,<span class="number">8989</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *  * （1）从键盘输入词语</span></span><br><span class="line"><span class="comment">		 * （2）发送给服务器</span></span><br><span class="line"><span class="comment">		 * （3）接收服务器返回的结果</span></span><br><span class="line"><span class="comment">		 * （1）（2）（3）多次进行，直到键盘输入bye并发送给发服务器之后就结束</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 同样考虑到发送词语，以及词语之间分割问题，那我们选择PrintStream和BufferedReader</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="comment">//从键盘输入词语</span></span><br><span class="line">			System.out.print(<span class="string">"请输入词语："</span>);</span><br><span class="line">			String word = input.next();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//发送给服务器端</span></span><br><span class="line">			ps.println(word);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(<span class="string">"bye"</span>.equals(word))&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//接收服务器返回的结果</span></span><br><span class="line">			String result = br.readLine();</span><br><span class="line">			System.out.println(<span class="string">"服务器返回的反转后的结果："</span> + result);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		input.close();</span><br><span class="line">		socket.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TCP协议编程示例四"><a href="#TCP协议编程示例四" class="headerlink" title="TCP协议编程示例四"></a>TCP协议编程示例四</h2><p><strong>多个客户端</strong>同时连接服务器，连接成功后：</p>
<ol>
<li>客户端从键盘输入词语，给服务器发送，直到bye为止；</li>
<li>服务器每次手动词语，反转词语 ，然后返回给客户端，直到接收到bye为止</li>
</ol>
<p>示意图：</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/network-programming5.png" alt="network-programming"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 服务器端：</span></span><br><span class="line"><span class="comment"> * 	(1)接收客户端的连接</span></span><br><span class="line"><span class="comment"> *  (2)接收客户端的词语</span></span><br><span class="line"><span class="comment"> *  (3)把词语“反转”返回给客户端</span></span><br><span class="line"><span class="comment"> *  (2)(3)多次，直到客户端发送"bye"为止</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  加一个条件，服务器端可以同时接收n个客户端连接</span></span><br><span class="line"><span class="comment"> *  服务器端得加多线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1、开启服务器</span></span><br><span class="line">		ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8989</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">while</span>(flag)&#123;</span><br><span class="line">			<span class="comment">//2、接收一个客户端的连接</span></span><br><span class="line">			Socket socket = server.accept();<span class="comment">//每个客户端的socket是独立的</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//为没一个客户端开启一个独立的线程维护它的通信</span></span><br><span class="line">			MessageHandler mh = <span class="keyword">new</span> MessageHandler(socket);</span><br><span class="line">			mh.start();</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		<span class="comment">//5、关闭服务器</span></span><br><span class="line">		server.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Socket socket;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MessageHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.socket = socket;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//3、先获取输入流和输出流</span></span><br><span class="line">			InputStream in = socket.getInputStream();</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 因为是接收一个词语，反转一个，返回一个</span></span><br><span class="line"><span class="comment">			 * 那么如果仅仅使用字节流，不好区分词语</span></span><br><span class="line"><span class="comment">			 * 需要用到字符流</span></span><br><span class="line"><span class="comment">			 * 那么就意味着需要把字节流转为字符流</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);<span class="comment">//这里不涉及编码问题，仅仅为了转换流的类型</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 字符流中几个字符是一个词语</span></span><br><span class="line"><span class="comment">			 * 那么我们这里选择“换行符”来作为词语的分割</span></span><br><span class="line"><span class="comment">			 * 意味着我们可以按行读取Scanner或BufferedReader</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">			</span><br><span class="line">			OutputStream out = socket.getOutputStream();</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 客户端收到字节，同样不方便处理几个字节是一个词语，仍然要把字节输出流转为字符流</span></span><br><span class="line"><span class="comment">			 * 而且字符之间也不好区分，那么也选择“换行符”进行区别词语</span></span><br><span class="line"><span class="comment">			 * 我们现在需要把OutputStream转为一个可以按行写的字符流或其他的处理流</span></span><br><span class="line"><span class="comment">			 * </span></span><br><span class="line"><span class="comment">			 * 可以按行写的：BufferedWriter(newLine())</span></span><br><span class="line"><span class="comment">			 * 		   PrintStream(println())</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			PrintStream ps = <span class="keyword">new</span> PrintStream(out);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//从客户端接收词语</span></span><br><span class="line">			String word;</span><br><span class="line">			<span class="keyword">while</span>((word = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="string">"bye"</span>.equals(word))&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//如果不是bye，要反转，并且返回</span></span><br><span class="line">				StringBuilder sb = <span class="keyword">new</span> StringBuilder(word);</span><br><span class="line">				sb.reverse();</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//返回给客户端</span></span><br><span class="line">				ps.println(sb.toString());</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//4、断开</span></span><br><span class="line">				socket.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 客户端：</span></span><br><span class="line"><span class="comment"> * （1）从键盘输入词语</span></span><br><span class="line"><span class="comment"> * （2）发送给服务器</span></span><br><span class="line"><span class="comment"> * （3）接收服务器返回的结果</span></span><br><span class="line"><span class="comment"> * （1）（2）（3）多次进行，直到键盘输入bye并发送给发服务器之后就结束</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 加一个条件，服务器端可以同时接收n个客户端连接</span></span><br><span class="line"><span class="comment"> * 客户端代码不用修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1、连接服务器</span></span><br><span class="line">		Socket socket = <span class="keyword">new</span> Socket(<span class="string">"192.168.30.142"</span>,<span class="number">8989</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * （1）从键盘输入词语</span></span><br><span class="line"><span class="comment">		 * （2）发送给服务器</span></span><br><span class="line"><span class="comment">		 * （3）接收服务器返回的结果</span></span><br><span class="line"><span class="comment">		 * （1）（2）（3）多次进行，直到键盘输入bye并发送给发服务器之后就结束</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 同样考虑到发送词语，以及词语之间分割问题，那我们选择PrintStream和BufferedReader</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="comment">//从键盘输入词语</span></span><br><span class="line">			System.out.print(<span class="string">"请输入词语："</span>);</span><br><span class="line">			String word = input.next();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//发送给服务器端</span></span><br><span class="line">			ps.println(word);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(<span class="string">"bye"</span>.equals(word))&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//接收服务器返回的结果</span></span><br><span class="line">			String result = br.readLine();</span><br><span class="line">			System.out.println(<span class="string">"服务器返回的反转后的结果："</span> + result);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		input.close();</span><br><span class="line">		socket.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TCP协议编程示例五"><a href="#TCP协议编程示例五" class="headerlink" title="TCP协议编程示例五"></a>TCP协议编程示例五</h2><p>一个客户端连接服务器，连接成功后，给服务器上传一个文件，服务器接收到文件后存到upload的文件夹中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从客户端发送文件到服务器端</span></span><br><span class="line"><span class="comment"> * (1)接收客户端的连接</span></span><br><span class="line"><span class="comment"> * (2)接收文件名.后缀名</span></span><br><span class="line"><span class="comment"> * 思考：</span></span><br><span class="line"><span class="comment"> * 	 存哪里   ①在当前项目中找一个位置存储，例如：upload文件夹</span></span><br><span class="line"><span class="comment"> *  ②如何解决文件名重名的问题         文件名需要处理，加入时间戳或其他的唯一编码的UUID等值</span></span><br><span class="line"><span class="comment"> *  ③.后缀名需要保留，因为它代表文件的类型</span></span><br><span class="line"><span class="comment"> * (3)接收文件内容</span></span><br><span class="line"><span class="comment"> * (4)反馈结果</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 思考：</span></span><br><span class="line"><span class="comment"> * 		这里既要接收文件名.后缀名，又要接收文件内容。</span></span><br><span class="line"><span class="comment"> * 		这里既有  文本信息“文件名.后缀名”，又有其他类型的数据“文件内容”，只能选择字节流。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 		如何区别，文件名.后缀名   与  文件内容呢</span></span><br><span class="line"><span class="comment"> * 		想哪种字节输入流，可以处理字符串，和字节类型的数据。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 		FileInputStream</span></span><br><span class="line"><span class="comment"> * 		BufferedInputStream</span></span><br><span class="line"><span class="comment"> * 		DataInputStream</span></span><br><span class="line"><span class="comment"> * 		ObjectInputStream</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 		这些里面：DataInputStream：readUTF() 和  read(byte[])</span></span><br><span class="line"><span class="comment"> * 				ObjectInputStream也可以，但是麻烦，我这里选择DataInputStream</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1、开启服务器</span></span><br><span class="line">		ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2、接收客户端的连接</span></span><br><span class="line">		Socket socket = server.accept();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3、获取输入流</span></span><br><span class="line">		InputStream in = socket.getInputStream();</span><br><span class="line">		DataInputStream dis = <span class="keyword">new</span> DataInputStream(in);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//接收文件名.后缀名</span></span><br><span class="line">		String fileName = dis.readUTF();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//处理文件名</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 希望我要在服务器存储的文件名：   原来的文件名 + 时间戳</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">long</span> timestamp = System.currentTimeMillis();</span><br><span class="line">		<span class="comment">//.的下标</span></span><br><span class="line">		<span class="keyword">int</span> index = fileName.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">		<span class="comment">//后缀名</span></span><br><span class="line">		String ext = fileName.substring(index);</span><br><span class="line">		<span class="comment">// 原来的文件名</span></span><br><span class="line">		String name = fileName.substring(<span class="number">0</span>, index);</span><br><span class="line">		<span class="comment">//新文件名</span></span><br><span class="line">		String newFileName = <span class="string">"upload/"</span> + name + timestamp + ext;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建文件输出流，把接收到的文件内容，写入新文件</span></span><br><span class="line">		FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(newFileName);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//接收文件内容</span></span><br><span class="line">		<span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">		<span class="keyword">while</span>((len = dis.read(data))!=-<span class="number">1</span>)&#123;</span><br><span class="line">			fos.write(data, <span class="number">0</span>, len);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//还可以给客户端反馈：文件接收完毕</span></span><br><span class="line">		OutputStream out = socket.getOutputStream();</span><br><span class="line">		PrintStream ps = <span class="keyword">new</span> PrintStream(out);</span><br><span class="line">		ps.println(<span class="string">"文件接收完毕!"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//断开</span></span><br><span class="line">		fos.close();</span><br><span class="line">		socket.close();</span><br><span class="line">		server.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从客户端发送文件到服务器端</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 客户端：</span></span><br><span class="line"><span class="comment"> * （1）从键盘输入文件的路径名，即选择要发送的文件</span></span><br><span class="line"><span class="comment"> * （2）给服务器先把“文件名.后缀名"</span></span><br><span class="line"><span class="comment"> * （3）发送文件内容</span></span><br><span class="line"><span class="comment"> * （4）接收服务器的反馈结果</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这里同样因为既要发送“文件名.后缀名"，又要发送“文件内容”，选择字节流，选择DataOutputStream</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1、连接服务器</span></span><br><span class="line">		Socket socket = <span class="keyword">new</span> Socket(<span class="string">"192.168.30.142"</span>,<span class="number">9999</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2、从键盘输入文件的路径名，即选择要发送的文件</span></span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.print(<span class="string">"请选择你要发送的文件（例如：D:/JavaSE/资料.rar）："</span>);</span><br><span class="line">		String fileName = input.nextLine();</span><br><span class="line">		File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3、给服务器发送“文件名.后缀名"</span></span><br><span class="line">		OutputStream out = socket.getOutputStream();</span><br><span class="line">		DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(out);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//发送“文件名.后缀名"</span></span><br><span class="line">		dos.writeUTF(file.getName());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4、发送文件内容</span></span><br><span class="line">		<span class="comment">//先从file文件读取内容</span></span><br><span class="line">		FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">		<span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">		<span class="keyword">while</span>((len = fis.read(data)) != -<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="comment">//一边读，一边给服务器发送</span></span><br><span class="line">			dos.write(data,<span class="number">0</span>,len);</span><br><span class="line">		&#125;</span><br><span class="line">		socket.shutdownOutput();<span class="comment">//表示发送完毕了</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//5、接收反馈</span></span><br><span class="line">		InputStream in = socket.getInputStream();</span><br><span class="line">		InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">		String result = br.readLine();</span><br><span class="line">		System.out.println(<span class="string">"结果："</span> + result);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//6、关闭</span></span><br><span class="line">		socket.close();</span><br><span class="line">		fis.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TCP协议编程示例六"><a href="#TCP协议编程示例六" class="headerlink" title="TCP协议编程示例六"></a>TCP协议编程示例六</h2><p>多个客户端连接服务器，连接成功后，给服务器上传一个文件，服务器接收到文件后存到upload的文件夹中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test15;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1、开启服务器</span></span><br><span class="line">		ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="comment">//2、接收客户端的连接</span></span><br><span class="line">			Socket socket = server.accept();</span><br><span class="line">			</span><br><span class="line">			FileUploadThread ft = <span class="keyword">new</span> FileUploadThread(socket);</span><br><span class="line">			ft.start();</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		server.close();//不关闭服务器</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileUploadThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Socket socket;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileUploadThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.socket = socket;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//3、获取输入流</span></span><br><span class="line">			InputStream in = socket.getInputStream();</span><br><span class="line">			DataInputStream dis = <span class="keyword">new</span> DataInputStream(in);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//接收文件名.后缀名</span></span><br><span class="line">			String fileName = dis.readUTF();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//处理文件名</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 希望我要在服务器存储的文件名：   原来的文件名 + 时间戳</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">long</span> timestamp = System.currentTimeMillis();</span><br><span class="line">			<span class="comment">//.的下标</span></span><br><span class="line">			<span class="keyword">int</span> index = fileName.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">			<span class="comment">//后缀名</span></span><br><span class="line">			String ext = fileName.substring(index);</span><br><span class="line">			<span class="comment">// 原来的文件名</span></span><br><span class="line">			String name = fileName.substring(<span class="number">0</span>, index);</span><br><span class="line">			<span class="comment">//新文件名</span></span><br><span class="line">			String newFileName = <span class="string">"upload/"</span> + name + timestamp + ext;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//创建文件输出流，把接收到的文件内容，写入新文件</span></span><br><span class="line">			FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(newFileName);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//接收文件内容</span></span><br><span class="line">			<span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			<span class="keyword">int</span> len;</span><br><span class="line">			<span class="keyword">while</span>((len = dis.read(data))!=-<span class="number">1</span>)&#123;</span><br><span class="line">				fos.write(data, <span class="number">0</span>, len);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//还可以给客户端反馈：文件接收完毕</span></span><br><span class="line">			OutputStream out = socket.getOutputStream();</span><br><span class="line">			PrintStream ps = <span class="keyword">new</span> PrintStream(out);</span><br><span class="line">			ps.println(<span class="string">"文件接收完毕!"</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//断开</span></span><br><span class="line">			fos.close();</span><br><span class="line">			socket.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test15;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1、连接服务器</span></span><br><span class="line">		Socket socket = <span class="keyword">new</span> Socket(<span class="string">"192.168.30.142"</span>,<span class="number">9999</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2、从键盘输入文件的路径名，即选择要发送的文件</span></span><br><span class="line">		Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.print(<span class="string">"请选择你要发送的文件（例如：D:/尚硅谷_190513班_柴林燕_JavaSE/开学典礼所发资料.rar）："</span>);</span><br><span class="line">		String fileName = input.nextLine();</span><br><span class="line">		File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3、给服务器发送“文件名.后缀名"</span></span><br><span class="line">		OutputStream out = socket.getOutputStream();</span><br><span class="line">		DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(out);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//发送“文件名.后缀名"</span></span><br><span class="line">		dos.writeUTF(file.getName());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//4、发送文件内容</span></span><br><span class="line">		<span class="comment">//先从file文件读取内容</span></span><br><span class="line">		FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">		<span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">		<span class="keyword">while</span>((len = fis.read(data)) != -<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="comment">//一边读，一边给服务器发送</span></span><br><span class="line">			dos.write(data,<span class="number">0</span>,len);</span><br><span class="line">		&#125;</span><br><span class="line">		socket.shutdownOutput();<span class="comment">//表示发送完毕了</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//5、接收反馈</span></span><br><span class="line">		InputStream in = socket.getInputStream();</span><br><span class="line">		InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">		BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">		String result = br.readLine();</span><br><span class="line">		System.out.println(<span class="string">"结果："</span> + result);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//6、关闭</span></span><br><span class="line">		socket.close();</span><br><span class="line">		fis.close();</span><br><span class="line">		input.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="TCP协议编程示例七"><a href="#TCP协议编程示例七" class="headerlink" title="TCP协议编程示例七"></a>TCP协议编程示例七</h2><p>群聊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Socket&gt; online = <span class="keyword">new</span> ArrayList&lt;Socket&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1、开启服务器</span></span><br><span class="line">		ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="comment">//2、接收客户端的连接</span></span><br><span class="line">			Socket socket = server.accept();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//把这个客户端加入到online中</span></span><br><span class="line">			online.add(socket);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//每一个客户端独立的线程</span></span><br><span class="line">			MessageHandler mh = <span class="keyword">new</span> MessageHandler(socket);</span><br><span class="line">			mh.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//私有的静态的内部类</span></span><br><span class="line">	<span class="comment">//这里用内部类的原因，是为了用上面的online集合</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Socket socket;</span><br><span class="line">		<span class="keyword">private</span> String ip;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MessageHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>();</span><br><span class="line">			<span class="keyword">this</span>.socket = socket;</span><br><span class="line">			<span class="keyword">this</span>.ip = socket.getInetAddress().getHostAddress();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="comment">//这个客户端的一连接成功，线程一启动，就可以告诉其他人我上线了</span></span><br><span class="line">			sendToOthers(ip+<span class="string">"上线了"</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * （1）接收当前的客户端发送的消息</span></span><br><span class="line"><span class="comment">			 * （2）给其他在线的客户端转发</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="comment">//（1）接收当前的客户端发送的消息</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				InputStream in = socket.getInputStream();</span><br><span class="line">				InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">				BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">				</span><br><span class="line">				String content;</span><br><span class="line">				<span class="keyword">while</span>((content = br.readLine()) !=<span class="keyword">null</span>)&#123;</span><br><span class="line">					<span class="keyword">if</span>(<span class="string">"bye"</span>.equals(content))&#123;</span><br><span class="line">						<span class="comment">//给自己发一句bye</span></span><br><span class="line">						OutputStream out = socket.getOutputStream();</span><br><span class="line">						PrintStream ps = <span class="keyword">new</span> PrintStream(out);</span><br><span class="line">						ps.println(<span class="string">"bye"</span>);</span><br><span class="line">						</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					<span class="comment">//收到一句，转发一句</span></span><br><span class="line">					sendToOthers(ip+<span class="string">"说:"</span> + content);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				sendToOthers(ip+<span class="string">"下线了"</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				sendToOthers(ip+<span class="string">"掉线了"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//因为转发的代码也很长，独立为一个方法</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendToOthers</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">			<span class="comment">//遍历所有online的客户端</span></span><br><span class="line">			Iterator&lt;Socket&gt; iterator = online.iterator();</span><br><span class="line">			<span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">				Socket on = iterator.next();</span><br><span class="line">				<span class="keyword">if</span>(!on.equals(socket))&#123;<span class="comment">//只给其他客户端转发</span></span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						OutputStream out = on.getOutputStream();</span><br><span class="line">						PrintStream ps = <span class="keyword">new</span> PrintStream(out);</span><br><span class="line">						</span><br><span class="line">						ps.println(str);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">						<span class="comment">//说明on这个客户端要么下线了，要么掉线了</span></span><br><span class="line">						iterator.remove();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 群聊</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1、连接服务器</span></span><br><span class="line">		Socket socket = <span class="keyword">new</span> Socket(<span class="string">"192.168.30.142"</span>,<span class="number">9999</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2、开启两个线程，一个收消息，一个发消息</span></span><br><span class="line">		SendThread st = <span class="keyword">new</span> SendThread(socket);</span><br><span class="line">		ReceiveThread rt = <span class="keyword">new</span> ReceiveThread(socket);</span><br><span class="line">		</span><br><span class="line">		st.start();</span><br><span class="line">		rt.start();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//等发送线程停下来再往下走</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			st.join();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//让接收数据的线程停下</span></span><br><span class="line">		rt.setFlag(<span class="keyword">false</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//等接收线程停下来，再往下走，断开连接</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			rt.join();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		socket.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Socket socket;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SendThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.socket = socket;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//键盘输入</span></span><br><span class="line">			Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">			OutputStream out = socket.getOutputStream();</span><br><span class="line">			PrintStream ps = <span class="keyword">new</span> PrintStream(out);</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">				<span class="comment">//从键盘输入</span></span><br><span class="line">				System.out.print(<span class="string">"请输入要发送的消息："</span>);</span><br><span class="line">				String content = input.nextLine();</span><br><span class="line">				System.out.println(<span class="string">"content:"</span> + content);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//给服务器发送</span></span><br><span class="line">				ps.println(content);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//如果bye，就结束发送</span></span><br><span class="line">				<span class="keyword">if</span>(<span class="string">"bye"</span>.equals(content))&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			input.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiveThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Socket socket;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ReceiveThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.socket = socket;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			InputStream in = socket.getInputStream();</span><br><span class="line">			InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">			BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span>(flag)&#123;</span><br><span class="line">				String line = br.readLine();</span><br><span class="line">				System.out.println(line);</span><br><span class="line">				<span class="keyword">if</span>(<span class="string">"bye"</span>.equals(line))&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.flag = flag;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="基于UDP协议的网络编程"><a href="#基于UDP协议的网络编程" class="headerlink" title="基于UDP协议的网络编程"></a>基于UDP协议的网络编程</h1><p>UDP(User Datagram Protocol，用户数据报协议)：是一个无连接的传输层协议、提供面向事务的简单不可靠的信息传送服务，类似于短信。</p>
<p>UDP协议是一种<strong>面向非连接</strong>的协议，面向非连接指的是在正式通信前不必与对方先建立连接，不管对方状态就直接发送，至于对方是否可以接收到这些数据内容，UDP协议无法控制，因此说，UDP协议是一种<strong>不可靠的</strong>协议。无连接的好处就是快，省内存空间和流量，因为维护连接需要创建大量的数据结构。UDP会尽最大努力交付数据，但不保证可靠交付，没有TCP的确认机制、重传机制，如果因为网络原因没有传送到对端，UDP也不会给应用层返回错误信息。</p>
<p>UDP协议是面向数据报文的信息传送服务。UDP在发送端没有缓冲区，对于应用层交付下来的报文在添加了首部之后就直接交付于ip层，不会进行合并，也不会进行拆分，而是一次交付一个完整的报文。比如我们要发送100个字节的报文，我们调用一次send()方法就会发送100字节，接收方也需要用receive()方法一次性接收100字节，不能使用循环每次获取10个字节，获取十次这样的做法。</p>
<p>UDP协议没有拥塞控制，所以当网络出现的拥塞不会导致主机发送数据的速率降低。虽然UDP的接收端有缓冲区，但是这个缓冲区只负责接收，并不会保证UDP报文的到达顺序是否和发送的顺序一致。因为网络传输的时候，由于网络拥塞的存在是很大的可能导致先发的报文比后发的报文晚到达。如果此时缓冲区满了，后面到达的报文将直接被丢弃。这个对实时应用来说很重要，比如：视频通话、直播等应用。</p>
<p>因此UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境，数据报大小限制在64K以下。</p>
<h2 id="基于UDP协议的网络编程-1"><a href="#基于UDP协议的网络编程-1" class="headerlink" title="基于UDP协议的网络编程"></a>基于UDP协议的网络编程</h2><p>基于UDP协议的网络编程仍然需要在通信实例的两端各建立一个Socket，但这两个Socket之间并没有虚拟链路，这两个Socket只是发送、接收数据报的对象，Java提供了DatagramSocket对象作为基于UDP协议的Socket，使用DatagramPacket代表DatagramSocket发送、接收的数据报。</p>
<p><strong>DatagramSocket 类的常用方法：</strong></p>
<ul>
<li>public DatagramSocket(int port)创建数据报套接字并将其绑定到本地主机上的指定端口。套接字将被绑定到通配符地址，IP 地址由内核来选择。</li>
<li>public DatagramSocket(int port,InetAddress laddr)创建数据报套接字，将其绑定到指定的本地地址。本地端口必须在 0 到 65535 之间（包括两者）。如果 IP 地址为 0.0.0.0，套接字将被绑定到通配符地址，IP 地址由内核选择。</li>
<li>public void close()关闭此数据报套接字。</li>
<li>public void send(DatagramPacket p)从此套接字发送数据报包。DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号。</li>
<li>public void receive(DatagramPacket p)从此套接字接收数据报包。当此方法返回时，DatagramPacket 的缓冲区填充了接收的数据。数据报包也包含发送方的 IP 地址和发送方机器上的端口号。 此方法在接收到数据报前一直阻塞。数据报包对象的 length 字段包含所接收信息的长度。如果信息比包的长度长，该信息将被截短。</li>
</ul>
<p><strong>DatagramPacket类的常用方法：</strong></p>
<ul>
<li>public DatagramPacket(byte[] buf,int length)构造 DatagramPacket，用来接收长度为 length 的数据包。 length 参数必须小于等于 buf.length。</li>
<li>public DatagramPacket(byte[] buf,int length,InetAddress address,int port)构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。length 参数必须小于等于 buf.length。</li>
<li>public int getLength()返回将要发送或接收到的数据的长度。</li>
</ul>
<h3 id="“发送端”"><a href="#“发送端”" class="headerlink" title="“发送端”"></a>“发送端”</h3><p>步骤流程：</p>
<ol>
<li>建立发送端的DatagramSocket，需要指定本端的端口号</li>
<li>建立数据包DatagramPacket<ul>
<li>数据</li>
<li>接收端的IP地址</li>
<li>接收端的端口号</li>
</ul>
</li>
<li>调用DatagramSocket的发送方法</li>
<li>关闭DatagramSocket</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//		1、建立发送端的DatagramSocket</span></span><br><span class="line">		DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//要发送的数据</span></span><br><span class="line">		ArrayList&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		all.add(<span class="string">"你只管努力！"</span>);</span><br><span class="line">		all.add(<span class="string">"剩下的交给天意！"</span>);</span><br><span class="line">		all.add(<span class="string">"当你的才华撑不起你的野心的时候！"</span>);</span><br><span class="line">		all.add(<span class="string">"那就必须静下心来学习！"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//接收方的IP地址</span></span><br><span class="line">		InetAddress ip = InetAddress.getByName(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">		<span class="comment">//接收方的监听端口号</span></span><br><span class="line">		<span class="keyword">int</span> port = <span class="number">9999</span>;</span><br><span class="line">         <span class="comment">//发送多个数据报</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all.size(); i++) &#123;</span><br><span class="line"><span class="comment">//			2、建立数据包DatagramPacket</span></span><br><span class="line">			<span class="keyword">byte</span>[] data = all.get(i).getBytes();</span><br><span class="line">			DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(data, data.length, ip, port);</span><br><span class="line"><span class="comment">//			3、调用Socket的发送方法</span></span><br><span class="line">			ds.send(dp);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		4、关闭Socket</span></span><br><span class="line">		ds.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="“接收端”"><a href="#“接收端”" class="headerlink" title="“接收端”"></a>“接收端”</h3><p>步骤流程：</p>
<ol>
<li><p>建立接收端的DatagramSocket，需要指定本端的IP地址和端口号</p>
</li>
<li><p>建立数据包DatagramPacket</p>
<ul>
<li>需要指定装数据的数组</li>
</ul>
</li>
<li><p>调用Socket的接收方法</p>
</li>
<li><p>拆封数据</p>
</li>
<li><p>关闭Socket</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receive</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//		1、建立接收端的DatagramSocket，需要指定本端的监听端口号</span></span><br><span class="line">		DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">9999</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//一直监听数据</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	<span class="comment">//		2、建立数据包DatagramPacket</span></span><br><span class="line">			<span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line">			DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buffer , buffer.length);</span><br><span class="line">			</span><br><span class="line">	<span class="comment">//		3、调用Socket的接收方法</span></span><br><span class="line">			ds.receive(dp);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//4、拆封数据</span></span><br><span class="line">			String str = <span class="keyword">new</span> String(buffer,<span class="number">0</span>,dp.getLength());</span><br><span class="line">			System.out.println(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="使用MulticastSocket实现多点广播"><a href="#使用MulticastSocket实现多点广播" class="headerlink" title="使用MulticastSocket实现多点广播"></a>使用MulticastSocket实现多点广播</h2><p>Datagram只允许数据报发送给指定的目标地址，而MulticastSocket可以将数据报以广播方式发送到数量不等的多个客户端。</p>
<p>IP协议为多点广播提供了这批特殊的IP地址，这些IP地址的范围是224.0.0.0至239.255.255.255。</p>
<p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/network-programming6.png" alt="network-programming"></p>
<p><strong>MulticastSocket常用的方法：</strong></p>
<ul>
<li>MulticastSocket(int port) ：创建多播套接字并将其绑定到特定端口。创建一个MulticastSocket对象后，还需要将该MulticastSocket加入到指定的多点广播地址，如果结束也需要脱离多点广播地址。</li>
<li>void joinGroup(InetAddress mcastaddr) ：加入多播组。</li>
<li>void leaveGroup(InetAddress mcastaddr) ：离开多播组。</li>
<li>void setLoopbackMode(boolean disable) ：启用/禁用多播数据报的本地回送。true 表示禁用 LoopbackMode。</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Uncle He</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.unclehe.net/2020/06/23/java-network-programming/">https://www.unclehe.net/2020/06/23/java-network-programming/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.unclehe.net" target="_blank">Uncle He</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/java.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/wechat.jpg" alt="wechat"/><div class="post-qr-code__desc">wechat</div></li><li class="reward-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/alipay.jpg" alt="alipay"/><div class="post-qr-code__desc">alipay</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/24/java-reflex/"><img class="prev_cover" data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/java.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">反射</div></div></a></div><div class="next-post pull_right"><a href="/2020/06/21/java-io/"><img class="next_cover" data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/java.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">IO流</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'kJLrzEh54hbM7O4kjF6VhlAt-MdYXbMMI',
  appKey: 'wbsLMRTmGNJ2wpVv2Xtvo17B',
  notify: false,
  verify: false,
  placeholder: '昵称请填写QQ号会自动获取头像和昵称...',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: true,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/java.jpeg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Uncle He</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://www.unclehe.net/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">简</a><i class="darkmode far fa-moon" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/js/customjs.js"></script></body></html>