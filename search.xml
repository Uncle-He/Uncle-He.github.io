<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JDBC</title>
      <link href="/2020/07/03/java-jdbc/"/>
      <url>/2020/07/03/java-jdbc/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在Java中，数据库存取技术可分为如下几类：</p><ul><li>JDBC直接访问数据库</li><li>JDO技术（Java Data Object）</li><li>第三方O/R工具，如Hibernate, Mybatis 等</li></ul><p>JDBC是java访问数据库的基石，JDO, Hibernate等只是更好的封装了JDBC。</p><h2 id="什么是JDBC"><a href="#什么是JDBC" class="headerlink" title="什么是JDBC"></a>什么是JDBC</h2><p>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统（DBMS）、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，使用这个类库可以以一种标准的方法、方便地访问数据库资源</p><p>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</p><p>DBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</p><p>如果没有JDBC，那么Java程序访问数据库时是这样的：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc1.png" alt="jdbc"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc2.png" alt="jdbc"></p><p><strong>结论：</strong></p><p>JDBC是SUN公司（Oracle公司甲骨文）提供一套用于数据库操作的接口API，Java程序员只需要面向这套接口编程即可。</p><p>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。</p><h2 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h2><p>JDBC API是一系列的接口，它统一和规范了应用程序与数据库的连接、执行SQL语句，并到得到返回结果等各类操作。声明在java.sql与javax.sql包中。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc3.png" alt="jdbc"></p><h2 id="JDBC程序编写步骤"><a href="#JDBC程序编写步骤" class="headerlink" title="JDBC程序编写步骤"></a>JDBC程序编写步骤</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc4.png" alt="jdbc"></p><h1 id="获取数据库连接"><a href="#获取数据库连接" class="headerlink" title="获取数据库连接"></a>获取数据库连接</h1><h2 id="引入JDBC驱动程序"><a href="#引入JDBC驱动程序" class="headerlink" title="引入JDBC驱动程序"></a>引入JDBC驱动程序</h2><p>驱动程序由数据库提供商提供下载。 MySQL的驱动下载地址：<a href="http://dev.mysql.com/downloads/" target="_blank" rel="noopener">http://dev.mysql.com/downloads/</a></p><p>如何在Java Project项目应用中添加数据库驱动jar：</p><ol><li>将下载好的数据库驱动拷贝到项目中的一个目录中</li></ol><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc5.png" alt="jdbc"></p><ol start="2"><li><p>添加到项目的类路径下</p><p>在驱动jar上右键–&gt;Build Path–&gt;Add to Build Path</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc6.png" alt="jdbc"></p></li></ol><p><strong>注意：</strong>如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc7.png" alt="jdbc"></p><h2 id="加载并注册驱动"><a href="#加载并注册驱动" class="headerlink" title="加载并注册驱动"></a>加载并注册驱动</h2><p>加载并注册驱动：</p><p>加载驱动，把驱动类加载到内存</p><p>注册驱动，把驱动类的对象交给DriverManager管理，用于后面创建连接等使用。</p><h3 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName()"></a>Class.forName()</h3><p>因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例，所以可以换一种方式来加载驱动。（即只要想办法让驱动类的这段静态代码块执行即可注册驱动类，而要让这段静态代码块执行，只要让该类被类加载器加载即可）</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc8.png" alt="jdbc"></p><p>调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射，加载与注册驱动类，解耦合（不直接依赖）</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br></pre></td></tr></table></figure><h3 id="服务提供者框架（例如：JDBC的驱动程序）自动注册（有版本要求）"><a href="#服务提供者框架（例如：JDBC的驱动程序）自动注册（有版本要求）" class="headerlink" title="服务提供者框架（例如：JDBC的驱动程序）自动注册（有版本要求）"></a>服务提供者框架（例如：JDBC的驱动程序）自动注册（有版本要求）</h3><p>符合JDBC 4.0规范的驱动程序包含了一个文件META-INF/services/java.sql.Driver，在这个文件中提供了JDBC驱动实现的类名。例如：mysql-connector-java-5.1.40-bin.jar文件中就可以找到java.sql.Driver文件，用文本编辑器打开文件就可以看到：com.mysql.jdbc.Driver类。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc9.png" alt="jdbc"></p><p>JVM的服务提供者框架在启动应用时就会注册服务，例如：MySQL的JDBC驱动就会被注册，而原代码中的Class.forName(“com.mysql.jdbc.Driver”)仍然可以存在，但是不会起作用。</p><p><strong>但是注意mysql-connector-java-5.0.8-bin.jar版本的jar中没有，如下</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc10.png" alt="jdbc"></p><h2 id="获取数据库链接"><a href="#获取数据库链接" class="headerlink" title="获取数据库链接"></a>获取数据库链接</h2><p>可以通过 DriverManager 类建立到数据库的连接Connection：</p><p>DriverManager 试图从<strong>已注册</strong>的 JDBC 驱动程序集中选择一个<strong>适当的</strong>驱动程序。</p><ul><li><p>public static Connection getConnection(String url)</p></li><li><p>public static Connection getConnection(String url,String user, String password)</p></li><li><p>public static Connection getConnection(String url,Properties info)</p><p>其中Properties info通常至少应该包括 “user” 和 “password” 属性</p></li></ul><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。JDBC URL的标准由三部分组成，各部分间用冒号分隔。 </p><p>jdbc:&lt;子协议&gt;:&lt;子名称&gt;</p><ul><li>协议：JDBC URL中的协议总是jdbc</li><li>子协议：子协议用于标识一个数据库驱动程序</li><li>子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了<strong>定位数据库</strong>提供足够的信息 </li></ul><p>例如：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc11.png" alt="jdbc"></p><ul><li>MySQL的连接URL编写方式：<ul><li>jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值</li><li>jdbc:mysql://localhost:3306/testdb</li><li>jdbc:mysql://localhost:3306/testdb<strong>?useUnicode=true&amp;characterEncoding=utf8（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</strong></li><li>jdbc:mysql://localhost:3306/testdb?user=root&amp;password=123456</li></ul></li><li>Oracle9i:<ul><li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li><li>jdbc:oracle:thin:@localhost:1521:testdb</li></ul></li><li>SQLServer:<ul><li>jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称</li><li>jdbc:sqlserver://localhost:1433:DatabaseName=testdb</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、加载与注册驱动</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、获取数据库连接</span></span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br></pre></td></tr></table></figure><h2 id="操作或访问数据库"><a href="#操作或访问数据库" class="headerlink" title="操作或访问数据库"></a>操作或访问数据库</h2><p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。</p><p>其实一个数据库连接就是一个Socket连接。</p><p>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</p><ul><li>Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。<ul><li>PrepatedStatement：SQL 语句被预编译并存储在此对象中，然后可以使用此对象多次高效地执行该语句。<ul><li>CallableStatement：用于执行 SQL 存储过程</li></ul></li></ul></li></ul><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><p>通过调用 Connection 对象的 createStatement() 方法创建该对象</p><p>该对象用于执行静态的 SQL 语句，并且返回执行结果</p><p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p><ul><li><p>int excuteUpdate(String sql)：执行更新操作INSERT、UPDATE、DELETE</p></li><li><p>ResultSet excuteQuery(String sql)：执行查询操作SELECT</p></li></ul><h3 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h3><p>通过调用 Statement 对象的 excuteQuery() 方法创建该对象</p><p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商实现</p><p>ResultSet 对象维护了一个指向当前数据行的<strong>游标</strong>，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行</p><p>ResultSet 接口的常用方法：</p><ul><li><p>boolean next()</p></li><li><p>getXxx(String columnLabel)：columnLabel使用 SQL AS 子句指定的列标签。如果未指定 SQL AS 子句，则标签是列名称</p></li><li><p>getXxx(int index) :索引从1开始</p><p>…</p></li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc12.png" alt="jdbc"></p><h2 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h2><p>Connection、Statement、ResultSet都是应用程序和数据库服务器的连接资源，使用后一定要关闭，可以在finally中关闭</p><p>演示未关闭后果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConnectionClose</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//1、加载与注册驱动</span></span><br><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获取数据库连接</span></span><br><span class="line">    String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//my.ini中max_connections=10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">      Connection conn = DriverManager.getConnection(url,<span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br><span class="line">      System.out.println(conn);</span><br><span class="line">      <span class="comment">//没有关闭，资源一直没有释放</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增、删、改、查示例代码"><a href="#增、删、改、查示例代码" class="headerlink" title="增、删、改、查示例代码"></a>增、删、改、查示例代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 网络编程：tcp</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 服务器端：</span></span><br><span class="line"><span class="comment"> * 1、ServerSocket server = new ServerSocket(3306);</span></span><br><span class="line"><span class="comment"> * 2、Socket socket = server.accept();</span></span><br><span class="line"><span class="comment"> * 3、InputStream input = socket.getInputStream();//接收sql，客户端传过来的</span></span><br><span class="line"><span class="comment"> * 4、在服务器执行sql</span></span><br><span class="line"><span class="comment"> * 5、把结果给客户端</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 客户端：</span></span><br><span class="line"><span class="comment"> * 1、Socket socket = new Socket(服务器的IP地址，3306);</span></span><br><span class="line"><span class="comment"> * 2、传sql</span></span><br><span class="line"><span class="comment"> * 3、OutputStream out = socket.getOutputStream();</span></span><br><span class="line"><span class="comment"> * 4、out.write(sql);</span></span><br><span class="line"><span class="comment"> * 5、接收结果</span></span><br><span class="line"><span class="comment"> * 6、断开连接  out.close();socket.close();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatement</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">    String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line">    String user = <span class="string">"root"</span>;</span><br><span class="line">    String password = <span class="string">"123456"</span>;</span><br><span class="line">    Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">    Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">    String sql = <span class="string">"INSERT INTO t_department(dname,description) VALUES('财务部','负责发钱工作')"</span>;</span><br><span class="line">    <span class="keyword">int</span> len = st.executeUpdate(sql);<span class="comment">//把insert,update,delete都用这个方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">"添加成功"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"添加失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st.close();</span><br><span class="line">    conn.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">    String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line">    String user = <span class="string">"root"</span>;</span><br><span class="line">    String password = <span class="string">"123456"</span>;</span><br><span class="line">    Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">    Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">    String sql = <span class="string">"UPDATE t_department SET description = '负责发工资、社保、公积金工作' WHERE dname ='财务部'"</span>;</span><br><span class="line">    <span class="keyword">int</span> len = st.executeUpdate(sql);<span class="comment">//把insert,update,delete都用这个方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">"修改成功"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"修改失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st.close();</span><br><span class="line">    conn.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">    String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line">    String user = <span class="string">"root"</span>;</span><br><span class="line">    String password = <span class="string">"123456"</span>;</span><br><span class="line">    Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">    Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">    String sql = <span class="string">"DELETE FROM t_department WHERE did =6"</span>;</span><br><span class="line">    <span class="keyword">int</span> len = st.executeUpdate(sql);<span class="comment">//把insert,update,delete都用这个方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      System.out.println(<span class="string">"删除成功"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"删除失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    st.close();</span><br><span class="line">    conn.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">    String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line">    String user = <span class="string">"root"</span>;</span><br><span class="line">    String password = <span class="string">"123456"</span>;</span><br><span class="line">    Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">    Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">    String sql = <span class="string">"SELECT * FROM t_department"</span>;</span><br><span class="line">    ResultSet rs = st.executeQuery(sql);<span class="comment">//select语句用query方法</span></span><br><span class="line">    <span class="keyword">while</span>(rs.next())&#123;<span class="comment">//是否有下一行</span></span><br><span class="line">      <span class="comment">//取这一行的单元格</span></span><br><span class="line">      <span class="keyword">int</span> id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">      String name = rs.getString(<span class="number">2</span>);</span><br><span class="line">      String desc = rs.getString(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(id+<span class="string">"\t"</span> + name + <span class="string">"\t"</span> + desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rs.close();</span><br><span class="line">    st.close();</span><br><span class="line">    conn.close();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect2</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">    String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line">    String user = <span class="string">"root"</span>;</span><br><span class="line">    String password = <span class="string">"123456"</span>;</span><br><span class="line">    Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">    Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">    String sql = <span class="string">"SELECT did,dname FROM t_department"</span>;</span><br><span class="line">    ResultSet rs = st.executeQuery(sql);<span class="comment">//select语句用query方法</span></span><br><span class="line">    <span class="keyword">while</span>(rs.next())&#123;<span class="comment">//是否有下一行</span></span><br><span class="line">      <span class="comment">//取这一行的单元格</span></span><br><span class="line">      <span class="keyword">int</span> id = rs.getInt(<span class="string">"did"</span>);</span><br><span class="line">      String name = rs.getString(<span class="string">"dname"</span>);</span><br><span class="line">      System.out.println(id+<span class="string">"\t"</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rs.close();</span><br><span class="line">    st.close();</span><br><span class="line">    conn.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h1><h2 id="Statement的不足"><a href="#Statement的不足" class="headerlink" title="Statement的不足"></a>Statement的不足</h2><ol><li><p>SQL拼接</p></li><li><p>SQL注入</p><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令，从而利用系统的 SQL 引擎完成恶意行为的做法。对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement 取代 Statement 就可以了。</p></li><li><p>处理Blob类型的数据</p><p>BLOB (binary large object)，二进制大对象，BLOB常常是数据库中用来存储二进制文件的字段类型。</p><p>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</p><p>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</p></li></ol><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc13.png" alt="jdbc"></p><blockquote><p>如果还是报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数：</p><p> max_allowed_packet=16M</p><p>注意：修改了my.ini文件，一定要重新启动服务</p></blockquote><p>实际使用中根据需要存入的数据大小定义不同的BLOB类型。<br>需要注意的是：如果存储的文件过大，数据库的性能会下降。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;user&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;username&#96; varchar(20) COLLATE utf8_unicode_ci DEFAULT NULL,</span><br><span class="line">  &#96;head_picture&#96; mediumblob,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;3 DEFAULT CHARSET&#x3D;utf8 COLLATE&#x3D;utf8_unicode_ci;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Statement：</span></span><br><span class="line"><span class="comment"> * 1、SQL拼接</span></span><br><span class="line"><span class="comment"> * 2、SQL注入</span></span><br><span class="line"><span class="comment"> * 3、处理不了Blob类型的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatementProblem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">"请输入姓名："</span>);</span><br><span class="line">    String name = input.nextLine();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"请输入领导编号："</span>);</span><br><span class="line">    <span class="keyword">int</span> mid = input.nextInt();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"请输入部门编号："</span>);</span><br><span class="line">    <span class="keyword">int</span> did = input.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、连接数据库</span></span><br><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">    String url = <span class="string">"jdbc:mysql://localhost:3306/1221db"</span>;</span><br><span class="line">    String user = <span class="string">"root"</span>;</span><br><span class="line">    String password = <span class="string">"123456"</span>;</span><br><span class="line">    Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、创建Statement对象</span></span><br><span class="line">    Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、编写sql</span></span><br><span class="line">    String sql = <span class="string">"INSERT INTO emp (ename,`mid`,did) VALUES('"</span> + name+<span class="string">"',"</span> + mid + <span class="string">","</span> + did + <span class="string">")"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、执行sql</span></span><br><span class="line">    <span class="keyword">int</span> update = st.executeUpdate(sql);</span><br><span class="line">    System.out.println(update&gt;<span class="number">0</span>?<span class="string">"添加成功"</span>:<span class="string">"添加失败"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、释放资源</span></span><br><span class="line">    st.close();</span><br><span class="line">    conn.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">"请输入姓名："</span>);</span><br><span class="line">    String name = input.nextLine();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、连接数据库</span></span><br><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">    String url = <span class="string">"jdbc:mysql://localhost:3306/1221db"</span>;</span><br><span class="line">    String user = <span class="string">"root"</span>;</span><br><span class="line">    String password = <span class="string">"123456"</span>;</span><br><span class="line">    Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、写sql</span></span><br><span class="line">    <span class="comment">//孙红雷  ' or '1' = '1</span></span><br><span class="line">    String sql = <span class="string">"SELECT eid,ename,tel,gender,salary FROM t_employee WHERE ename = '"</span> + name + <span class="string">"'"</span>;</span><br><span class="line">    System.out.println(sql);</span><br><span class="line">    <span class="comment">//SELECT eid,ename,tel,gender,salary FROM t_employee WHERE ename = '孙红雷  ' or '1' = '1'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、用Statement执行</span></span><br><span class="line">    Statement st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、执行查询sql</span></span><br><span class="line">    ResultSet rs = st.executeQuery(sql);</span><br><span class="line">    <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">      <span class="keyword">int</span> id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">      String ename = rs.getString(<span class="number">2</span>);</span><br><span class="line">      String tel = rs.getString(<span class="number">3</span>);</span><br><span class="line">      String gender =rs.getString(<span class="number">4</span>);</span><br><span class="line">      <span class="keyword">double</span> salary = rs.getDouble(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(id+<span class="string">"\t"</span> + ename + <span class="string">"\t"</span> + tel + <span class="string">"\t"</span> + gender + <span class="string">"\t"</span> +salary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、释放资源</span></span><br><span class="line">    st.close();</span><br><span class="line">    conn.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAddBlob</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String sql = <span class="string">"INSERT INTO `user` (username,`password`,photo)VALUES('chai','123',没法在String中处理Blob类型的数据);"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PreparedStatement概述"><a href="#PreparedStatement概述" class="headerlink" title="PreparedStatement概述"></a>PreparedStatement概述</h2><p>可以通过调用 Connection 对象的 preparedStatement(<strong>String sql</strong>) 方法获取 PreparedStatement 对象</p><p>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</p><ul><li>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</li><li>ResultSet executeQuery()执行查询，并返回该查询生成的 ResultSet 对象。</li><li>int executeUpdate()：执行更新，包括增、删、该</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PreparedStatement：是Statement子接口</span></span><br><span class="line"><span class="comment"> * 1、SQL不需要拼接</span></span><br><span class="line"><span class="comment"> * 2、SQL不会出现注入</span></span><br><span class="line"><span class="comment"> * 3、可以处理Blob类型的数据</span></span><br><span class="line"><span class="comment"> * tinyblob：255字节以内</span></span><br><span class="line"><span class="comment"> * blob：65K以内</span></span><br><span class="line"><span class="comment"> * mediumblob:16M以内</span></span><br><span class="line"><span class="comment"> * longblob：4G以内</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如果还是报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数：</span></span><br><span class="line"><span class="comment"> * max_allowed_packet=16M</span></span><br><span class="line"><span class="comment"> * 注意：修改了my.ini文件，一定要重新启动服务</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPreparedStatement</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">"请输入姓名："</span>);</span><br><span class="line">    String name = input.nextLine();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"请输入手机号码："</span>);</span><br><span class="line">    String tel = input.nextLine();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"请输入性别："</span>);</span><br><span class="line">    String gender = input.nextLine();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"请输入薪资："</span>);</span><br><span class="line">    <span class="keyword">double</span> salary = input.nextDouble();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"请输入部门编号："</span>);</span><br><span class="line">    <span class="keyword">int</span> did = input.nextInt();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、连接数据库</span></span><br><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">    String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line">    String user = <span class="string">"root"</span>;</span><br><span class="line">    String password = <span class="string">"123456"</span>;</span><br><span class="line">    Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、编写带？的SQL</span></span><br><span class="line">    String sql = <span class="string">"INSERT INTO t_employee (ename,tel,gender,salary,did) VALUES(?,?,?,?,?)"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、准备一个PreparedStatement：预编译sql</span></span><br><span class="line">    PreparedStatement pst = conn.prepareStatement(sql);<span class="comment">// 对带？的sql进行预编译</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、把?用具体的值进行代替</span></span><br><span class="line">    pst.setString(<span class="number">1</span>, name);</span><br><span class="line">    pst.setString(<span class="number">2</span>, tel);</span><br><span class="line">    pst.setString(<span class="number">3</span>, gender);</span><br><span class="line">    pst.setDouble(<span class="number">4</span>, salary);</span><br><span class="line">    pst.setInt(<span class="number">5</span>, did);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、执行sql</span></span><br><span class="line">    <span class="keyword">int</span> len = pst.executeUpdate();</span><br><span class="line">    System.out.println(len&gt;<span class="number">0</span>?<span class="string">"添加成功"</span>:<span class="string">"添加失败"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6、释放资源</span></span><br><span class="line">    pst.close();</span><br><span class="line">    conn.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">"请输入姓名："</span>);</span><br><span class="line">    String name = input.nextLine();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、连接数据库</span></span><br><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">    String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line">    String user = <span class="string">"root"</span>;</span><br><span class="line">    String password = <span class="string">"123456"</span>;</span><br><span class="line">    Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、编写带?的sql</span></span><br><span class="line">    <span class="comment">//孙红雷  ' or '1' = '1</span></span><br><span class="line">    String sql = <span class="string">"SELECT eid,ename,tel,gender,salary FROM t_employee WHERE ename = ?"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、把带？的sql语句进行预编译</span></span><br><span class="line">    PreparedStatement pst = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、把？用具体的变量的赋值</span></span><br><span class="line">    pst.setString(<span class="number">1</span>, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、执行sql</span></span><br><span class="line">    ResultSet rs = pst.executeQuery();</span><br><span class="line">    <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">      <span class="keyword">int</span> id = rs.getInt(<span class="string">"eid"</span>);</span><br><span class="line">      String ename = rs.getString(<span class="string">"ename"</span>);</span><br><span class="line">      String tel = rs.getString(<span class="string">"tel"</span>);</span><br><span class="line">      String gender = rs.getString(<span class="string">"gender"</span>);</span><br><span class="line">      <span class="keyword">double</span> salary = rs.getDouble(<span class="string">"salary"</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(id + <span class="string">"\t"</span> + ename + <span class="string">"\t"</span> + tel + <span class="string">"\t"</span> + gender + <span class="string">"\t"</span> + salary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6、释放资源</span></span><br><span class="line">    rs.close();</span><br><span class="line">    pst.close();</span><br><span class="line">    conn.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBlob</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(<span class="string">"请输入用户名："</span>);</span><br><span class="line">    String username = input.nextLine();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"请输入密码："</span>);</span><br><span class="line">    String pwd = input.nextLine();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"请指定照片的路径："</span>);</span><br><span class="line">    String photoPath = input.nextLine();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、连接数据库</span></span><br><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">    String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line">    String user = <span class="string">"root"</span>;</span><br><span class="line">    String password = <span class="string">"123456"</span>;</span><br><span class="line">    Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、 INSERT INTO `user` VALUES(NULL,用户名,密码,照片)</span></span><br><span class="line">    String sql = <span class="string">"INSERT INTO `user` (username,`password`,head_picture)VALUES(?,?,?)"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、准备一个PreparedStatement：预编译sql</span></span><br><span class="line">    PreparedStatement pst = conn.prepareStatement(sql);<span class="comment">// 对带？的sql进行预编译</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、对？进行设置</span></span><br><span class="line">    pst.setString(<span class="number">1</span>, username);</span><br><span class="line">    pst.setString(<span class="number">2</span>, pwd);</span><br><span class="line">    pst.setBlob(<span class="number">3</span>, <span class="keyword">new</span> FileInputStream(photoPath));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5、执行sql</span></span><br><span class="line">    <span class="keyword">int</span> len = pst.executeUpdate();</span><br><span class="line">    System.out.println(len &gt; <span class="number">0</span> ? <span class="string">"添加成功"</span> : <span class="string">"添加失败"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6、释放资源</span></span><br><span class="line">    pst.close();</span><br><span class="line">    conn.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PreparedStatement-VS-Statement"><a href="#PreparedStatement-VS-Statement" class="headerlink" title="PreparedStatement VS Statement"></a>PreparedStatement VS Statement</h2><ul><li>代码的可读性和可维护性. Statement的sql拼接是个难题。</li><li>PreparedStatement 可以防止 SQL 注入</li><li>PreparedStatement 可以处理Blob类型的数据</li><li>PreparedStatement 能最大可能提高性能：（Oracle和PostgreSQL8是这样，但是对于MySQL不一定比Statement高）<ul><li>DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</li></ul></li></ul><h2 id="JDBC-取得数据库自动生成的主键"><a href="#JDBC-取得数据库自动生成的主键" class="headerlink" title="JDBC 取得数据库自动生成的主键"></a>JDBC 取得数据库自动生成的主键</h2><p>获取自增长的键值：</p><ol><li>在创建PreparedStatement对象时</li></ol><p>原来：</p><blockquote><p> PreparedStatement pst = conn.preparedStatement(sql);</p></blockquote><p>现在：</p><blockquote><p>PreparedStatement pst = conn.prepareStatement(orderInsert,Statement.RETURN_GENERATED_KEYS);</p></blockquote><ol start="2"><li>原来执行更新</li></ol><p>原来：</p><blockquote><p>int len = pst.executeUpdate();    </p></blockquote><p> 现在：</p><blockquote><p>int len = pst.executeUpdate();    </p><p>ResultSet rs = pst.getGeneratedKeys();</p><p>if(rs.next()){</p><p>​     Object key = rs.getObject(第几列);//获取自增长的键值</p><p>}    </p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGenerateKey</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">"请输入姓名："</span>);</span><br><span class="line">String name = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"请输入手机号码："</span>);</span><br><span class="line">String tel = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"请输入性别："</span>);</span><br><span class="line">String gender = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"请输入薪资："</span>);</span><br><span class="line"><span class="keyword">double</span> salary = input.nextDouble();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"请输入部门编号："</span>);</span><br><span class="line"><span class="keyword">int</span> did = input.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、连接数据库</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line">String user = <span class="string">"root"</span>;</span><br><span class="line">String password = <span class="string">"123456"</span>;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、编写带？的SQL</span></span><br><span class="line">String sql = <span class="string">"INSERT INTO t_employee (ename,tel,gender,salary,did) VALUES(?,?,?,?,?)"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、准备一个PreparedStatement：预编译sql</span></span><br><span class="line"><span class="comment">//执行添加语句，如果需要获取自增长的键值，那么在此处要告知mysql服务器，在创建PreparedStatement对象时，增加一个参数</span></span><br><span class="line"><span class="comment">//autoGeneratedKeys - 指示是否应该返回自动生成的键的标志，它是 Statement.RETURN_GENERATED_KEYS 或 Statement.NO_GENERATED_KEYS 之一</span></span><br><span class="line">PreparedStatement pst = conn.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4、把?用具体的值进行代替</span></span><br><span class="line">pst.setString(<span class="number">1</span>, name);</span><br><span class="line">pst.setString(<span class="number">2</span>, tel);</span><br><span class="line">pst.setString(<span class="number">3</span>, gender);</span><br><span class="line">pst.setDouble(<span class="number">4</span>, salary);</span><br><span class="line">pst.setInt(<span class="number">5</span>, did);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5、执行sql</span></span><br><span class="line"><span class="keyword">int</span> len = pst.executeUpdate();</span><br><span class="line">System.out.println(len&gt;<span class="number">0</span>?<span class="string">"添加成功"</span>:<span class="string">"添加失败"</span>);</span><br><span class="line"></span><br><span class="line">ResultSet rs = pst.getGeneratedKeys();</span><br><span class="line"><span class="keyword">if</span>(rs.next())&#123;</span><br><span class="line">System.out.println(<span class="string">"新员工编号是："</span> + rs.getObject(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6、释放资源</span></span><br><span class="line">pst.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>当需要成批插入或者更新记录时。可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。</p><p>JDBC的批量处理语句包括下面两个方法：</p><ul><li>addBatch()：添加需要批量处理的SQL语句或参数</li><li>executeBatch()：执行批量处理语句；</li></ul><p>通常我们会遇到两种批量执行SQL语句的情况：</p><ul><li>多条SQL语句的批量处理；</li><li>一个SQL语句的批量传参；</li></ul><p>注意：</p><p><strong>JDBC连接MySQL时，如果要使用批处理功能，请再url中加参数?rewriteBatchedStatements=true PreparedStatement作批处理插入时使用values（使用value没有效果）</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestBatch &#123;</span><br><span class="line">@Test</span><br><span class="line">public void noBatch()throws Exception&#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test&quot;;</span><br><span class="line">String user &#x3D; &quot;root&quot;;</span><br><span class="line">String password &#x3D; &quot;123456&quot;;</span><br><span class="line">Connection conn &#x3D; DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String sql &#x3D; &quot;INSERT INTO t_department(dname,description) VALUES(?,?)&quot;;</span><br><span class="line">        PreparedStatement st &#x3D; conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0; i&lt;1000; i++)&#123;</span><br><span class="line">        st.setString(1, &quot;测试部门&quot; + i);</span><br><span class="line">        st.setString(2, &quot;测试部门描述&quot;  + i);</span><br><span class="line"></span><br><span class="line">        st.executeUpdate();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void useBatch()throws Exception&#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?rewriteBatchedStatements&#x3D;true&quot;;</span><br><span class="line">String user &#x3D; &quot;root&quot;;</span><br><span class="line">String password &#x3D; &quot;123456&quot;;</span><br><span class="line">Connection conn &#x3D; DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        String sql &#x3D; &quot;INSERT INTO t_department(dname,description) VALUES(?,?)&quot;;</span><br><span class="line">        PreparedStatement st &#x3D; conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0; i&lt;1000; i++)&#123;</span><br><span class="line">        st.setString(1, &quot;测试部门&quot; + i);</span><br><span class="line">        st.setString(2, &quot;测试部门描述&quot;  + i);</span><br><span class="line"></span><br><span class="line">        st.addBatch();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        st.executeBatch();</span><br><span class="line"></span><br><span class="line">st.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>JDBC程序中当<strong>一个连接对象</strong>被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</p><p>JDBC程序中为了让多个 SQL 语句作为一个事务执行：（重点）</p><ul><li><p>调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务</p></li><li><p>在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务</p></li><li><p>在其中某个操作失败或出现异常时，调用 rollback(); 方法回滚事务</p></li><li><p>若此时 Connection 没有被关闭, 则需要恢复其自动提交状态 setAutoCommit(true);</p></li></ul><p><strong>注意：</strong></p><p><strong>如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTransaction</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//1、连接数据库</span></span><br><span class="line">      Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">      String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line">      String user = <span class="string">"root"</span>;</span><br><span class="line">      String password = <span class="string">"123456"</span>;</span><br><span class="line">      conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">      <span class="comment">//设置手动提交</span></span><br><span class="line">      conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">      String sql1 = <span class="string">"update t_department set description = ? where did = ?"</span>;</span><br><span class="line">      PreparedStatement pst1 = conn.prepareStatement(sql1);</span><br><span class="line">      pst1.setObject(<span class="number">1</span>, <span class="string">"挣大钱的"</span>);</span><br><span class="line">      pst1.setObject(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">int</span> len1 = pst1.executeUpdate();</span><br><span class="line">      System.out.println(len1&gt;<span class="number">0</span>?<span class="string">"更新部门信息成功"</span>:<span class="string">"更新部门信息失败"</span>);</span><br><span class="line">      pst1.close();</span><br><span class="line"></span><br><span class="line">      String sql2 = <span class="string">"update t_employee set salary = salary + ? where did = ?"</span>;</span><br><span class="line">      PreparedStatement pst2 = conn.prepareStatement(sql2);</span><br><span class="line">      pst2.setObject(<span class="number">1</span>, <span class="number">20000</span>);</span><br><span class="line">      pst2.setObject(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">int</span> len2 = pst2.executeUpdate();</span><br><span class="line">      System.out.println(len2&gt;<span class="number">0</span>?<span class="string">"更新部门信息成功"</span>:<span class="string">"更新部门信息失败"</span>);</span><br><span class="line">      pst2.close();</span><br><span class="line"></span><br><span class="line">      conn.commit();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          conn.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="comment">//恢复自动提交</span></span><br><span class="line">          conn.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">          <span class="comment">//释放连接</span></span><br><span class="line">          conn.close();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><h2 id="数据库连接池-1"><a href="#数据库连接池-1" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><h3 id="数据库连接池的必要性"><a href="#数据库连接池的必要性" class="headerlink" title="数据库连接池的必要性"></a>数据库连接池的必要性</h3><p>不使用数据库连接池存在的问题:</p><ul><li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证IP地址，用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用</strong>.若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li><li>对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而<strong>未能关闭</strong>，将会导致<strong>数据库系统中的内存泄漏</strong>，最终将导致重启数据库。</li><li>这种开发不能控制被创建的<strong>连接对象数</strong>，系统资源会被毫无顾及的分配出去，如连接<strong>过多</strong>，也可能导致<strong>内存泄漏，服务器崩溃</strong>。</li></ul><p>为解决传统开发中的数据库连接问题，可以采用<strong>数据库连接池技术（connection pool）</strong>。</p><p><strong>数据库连接池的基本思想</strong>就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。数据库连接池负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc14.png" alt="jdbc"></p><p>数据库连接池技术的优点：</p><ul><li><p><strong>资源重用：</strong></p><p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p></li><li><p><strong>更快的系统反应速度</strong></p><p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p></li><li><p><strong>新的资源分配手段</strong></p><p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p></li><li><p><strong>统一的连接管理，避免数据库连接泄露</strong></p><p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p></li></ul><h3 id="多种开源的数据库连接池"><a href="#多种开源的数据库连接池" class="headerlink" title="多种开源的数据库连接池"></a>多种开源的数据库连接池</h3><p>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：</p><ul><li>DBCP 是Apache提供的数据库连接池，速度相对c3p0较快，但因自身存在BUG，Hibernate3已不再提供支持</li><li>C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以</li><li>Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点</li><li>BoneCP 是一个开源组织提供的数据库连接池，速度快</li><li>Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不知道是否有BoneCP快</li></ul><p>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池</p><p>注意：</p><ul><li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li></ul><h3 id="Druid（德鲁伊）数据源"><a href="#Druid（德鲁伊）数据源" class="headerlink" title="Druid（德鲁伊）数据源"></a>Druid（德鲁伊）数据源</h3><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，据说是目前最好的连接池。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDruid</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">pro.load(TestDruid.class.getClassLoader().getResourceAsStream("druid.properties"));</span><br><span class="line">DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">Connection conn = ds.getConnection();</span><br><span class="line">System.out.println(conn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test?rewriteBatchedStatements=true</span></span><br><span class="line">username=root</span><br><span class="line">password=<span class="number">123456</span></span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">initialSize=<span class="number">10</span></span><br><span class="line">maxActive=<span class="number">20</span></span><br><span class="line">maxWait=<span class="number">1000</span></span><br><span class="line">filters=wall</span><br></pre></td></tr></table></figure><p>详细配置参数：</p><table><thead><tr><th>配置</th><th>缺省</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td></td><td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。 如果没有配置，将会生成一个名字，格式是：”DataSource-” + System.identityHashCode(this)</td></tr><tr><td>jdbcUrl</td><td></td><td>连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td></tr><tr><td>username</td><td></td><td>连接数据库的用户名</td></tr><tr><td>password</td><td></td><td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/使用ConfigFilter" target="_blank" rel="noopener">https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</a></td></tr><tr><td>driverClassName</td><td></td><td>根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td></tr><tr><td>initialSize</td><td>0</td><td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td></tr><tr><td>maxActive</td><td>8</td><td>最大连接池数量</td></tr><tr><td>maxIdle</td><td>8</td><td>已经不再使用，配置了也没效果</td></tr><tr><td>minIdle</td><td></td><td>最小连接池数量</td></tr><tr><td>maxWait</td><td></td><td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td></tr><tr><td>maxOpenPreparedStatements</td><td>-1</td><td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td></tr><tr><td>validationQuery</td><td></td><td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td></tr><tr><td>testOnBorrow</td><td>true</td><td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td></tr><tr><td>testOnReturn</td><td>false</td><td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td></tr><tr><td>testWhileIdle</td><td>false</td><td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td></tr><tr><td>timeBetweenEvictionRunsMillis</td><td></td><td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td></tr><tr><td>numTestsPerEvictionRun</td><td></td><td>不再使用，一个DruidDataSource只支持一个EvictionRun</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td></td></tr><tr><td>connectionInitSqls</td><td></td><td>物理连接初始化的时候执行的sql</td></tr><tr><td>exceptionSorter</td><td></td><td>根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接</td></tr><tr><td>filters</td><td></td><td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td></tr><tr><td>proxyFilters</td><td></td><td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td></tr></tbody></table><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>JDK 1.2的版本中就提供java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。</p><p>ThreadLocal用于保存某个线程共享变量，原因是在Java中，每一个线程中都有一个ThreadLocalMap&lt;ThreadLocal, Object&gt;，其key就是一个ThreadLocal，而Object即为该线程的共享变量。而这个map是通过ThreadLocal的set和get方法操作的。对于同一个staticThreadLocal，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。</p><ol><li>ThreadLocal.get: 获取ThreadLocal中当前线程共享变量的值。</li><li>ThreadLocal.set: 设置ThreadLocal中当前线程共享变量的值。</li><li>ThreadLocal.remove: 移除ThreadLocal中当前线程共享变量的值。</li><li>ThreadLocal.initialValue: ThreadLocal没有被当前线程赋值时或当前线程刚调用remove方法后调用get方法，返回此方法值。</li></ol><h2 id="封装JDBCTools"><a href="#封装JDBCTools" class="headerlink" title="封装JDBCTools"></a>封装JDBCTools</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取连接或释放连接的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCTools</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1、数据源,即连接池</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2、ThreadLocal对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; threadLocal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//1、读取druip.properties文件</span></span><br><span class="line">      Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">      pro.load(JDBCTools.class.getClassLoader().getResourceAsStream("druid.properties"));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2、连接连接池</span></span><br><span class="line">      dataSource = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3、创建线程池</span></span><br><span class="line">      threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取连接的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从当前线程中获取连接</span></span><br><span class="line">    Connection connection = threadLocal.get();</span><br><span class="line">    <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 从连接池中获取一个连接</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        connection = dataSource.getConnection();</span><br><span class="line">        <span class="comment">// 将连接与当前线程绑定</span></span><br><span class="line">        threadLocal.set(connection);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放连接的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> connection</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releaseConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程中的连接</span></span><br><span class="line">    Connection connection = threadLocal.get();</span><br><span class="line">    <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        connection.close();</span><br><span class="line">        <span class="comment">// 将已经关闭的连接从当前线程中移除</span></span><br><span class="line">        threadLocal.remove();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Apache—DBUtils简介"><a href="#Apache—DBUtils简介" class="headerlink" title="Apache—DBUtils简介"></a>Apache—DBUtils简介</h1><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</p><h2 id="DbUtils类"><a href="#DbUtils类" class="headerlink" title="DbUtils类"></a>DbUtils类</h2><p>DbUtils提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：</p><ul><li>public static void close(…) throws java.sql.SQLException：DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li><li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li><li>public static void commitAndClose(Connection conn)throws SQLException 用来提交连接的事务，然后关闭连接</li><li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接的事务，然后关闭连接，并且在关闭连接时不抛出SQL异常。</li><li>public static void rollback(Connection conn)throws SQLException允许conn为null，因为方法内部做了判断</li><li>public static void rollbackAndClose(Connection conn)throws SQLException</li><li>rollbackAndCloseQuietly(Connection)</li><li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li></ul><h2 id="QueryRunner类"><a href="#QueryRunner类" class="headerlink" title="QueryRunner类"></a>QueryRunner类</h2><p>该类封装了SQL的执行，是线程安全的。</p><ol><li>可以实现增、删、改、查、批处理</li><li>考虑了事务处理需要共用Connection</li><li>该类最主要的就是简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量</li></ol><p>QueryRunner类提供了两个构造方法：</p><ul><li>QueryRunner()：默认的构造方法</li><li>QueryRunner(DataSource ds)：需要一个 javax.sql.DataSource 来作参数的构造方法</li></ul><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><ul><li><p>public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</p><p>……</p></li></ul><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul><li><p>public &lt;T&gt; T insert(Connection conn,String sql,ResultSetHandler&lt;T&gt; rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值</p><p>……</p></li></ul><h3 id="批处理-1"><a href="#批处理-1" class="headerlink" title="批处理"></a>批处理</h3><ul><li><p>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句</p></li><li><p>public &lt;T&gt; T insertBatch(Connection conn,String sql,ResultSetHandler&lt;T&gt; rsh,Object[][] params)throws SQLException：只支持INSERT语句</p><p>……</p></li></ul><h3 id="使用QueryRunner类实现查询"><a href="#使用QueryRunner类实现查询" class="headerlink" title="使用QueryRunner类实现查询"></a>使用QueryRunner类实现查询</h3><ul><li><p>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</p><p>……</p></li></ul><h2 id="ResultSetHandler接口"><a href="#ResultSetHandler接口" class="headerlink" title="ResultSetHandler接口"></a>ResultSetHandler接口</h2><p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet  rs)该方法的返回值将作为QueryRunner类的query()方法的返回值。</p><p>该接口有如下实现类可以使用：</p><ul><li>ArrayHandler：把结果集中的第一行数据转成对象数组。</li><li>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</li><li>BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。</li><li>BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</li><li>ColumnListHandler：将结果集中某一列的数据存放到List中。</li><li>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</li><li>MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</li><li>MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List</li></ul><h2 id="表与JavaBean"><a href="#表与JavaBean" class="headerlink" title="表与JavaBean"></a>表与JavaBean</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc15.png" alt="jdbc"></p><p>int,double等在Java中都用包装类，因为mysql中的所有类型都可能是NULL，而Java只有引用数据类型才有NULL值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer eid;</span><br><span class="line"><span class="keyword">private</span> String ename;</span><br><span class="line"><span class="keyword">private</span> String tel;</span><br><span class="line"><span class="keyword">private</span> String gender;<span class="comment">//mysql中用char,在Java中也要用String</span></span><br><span class="line"><span class="keyword">private</span> Double salary;</span><br><span class="line"><span class="keyword">private</span> Double commissionPct;</span><br><span class="line"><span class="keyword">private</span> Date birthday;<span class="comment">//此处用String或Date</span></span><br><span class="line"><span class="keyword">private</span> Date hiredate;</span><br><span class="line"><span class="keyword">private</span> Integer jobId;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"><span class="keyword">private</span> Integer mid;</span><br><span class="line"><span class="keyword">private</span> String address;</span><br><span class="line"><span class="keyword">private</span> String nativePlace;</span><br><span class="line"><span class="keyword">private</span> Integer did;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过给列取别名的方式，来告知数据库的列名与其对应实体的属性名</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc16.png" alt="jdbc"></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDBUtils</span> </span>&#123;</span><br><span class="line">  QueryRunner qr = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Book book = <span class="keyword">new</span> Book(<span class="number">0</span>, <span class="string">"红楼梦"</span>, <span class="string">"曹雪芹"</span>, <span class="number">88.8</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 写sql语句</span></span><br><span class="line">    String sql = <span class="string">"insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)"</span>;</span><br><span class="line">    qr.update(JDBCTools.getConnection(), sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(),</span><br><span class="line">              book.getStock(), book.getImgPath());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Book book = <span class="keyword">new</span> Book(<span class="number">0</span>, <span class="string">"红楼梦"</span>, <span class="string">"曹雪芹"</span>, <span class="number">88.8</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 写sql语句</span></span><br><span class="line">    String sql = <span class="string">"insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)"</span>;</span><br><span class="line">    Long id = qr.insert(JDBCTools.getConnection(), sql, <span class="keyword">new</span> ScalarHandler&lt;Long&gt;(), book.getTitle(),</span><br><span class="line">                        book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getImgPath());</span><br><span class="line">    System.out.println(<span class="string">"新书编号："</span> + id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Object[][] params = <span class="keyword">new</span> Object[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    params[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    params[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    params[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    params[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    params[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    params[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    String sql = <span class="string">"update books set sales = sales + ? , stock = stock - ? where id = ?"</span>;</span><br><span class="line">    qr.batch(JDBCTools.getConnection(), sql, params);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 写sql语句</span></span><br><span class="line">    <span class="comment">// 当JavaBean的属性名与字段名不一致时，可以通过指定别名告知属性名</span></span><br><span class="line">    String sql = <span class="string">"select id,title,author,price,sales,stock,img_path imgPath from books where id = ?"</span>;</span><br><span class="line">    Book b = qr.query(JDBCTools.getConnection(), sql, <span class="keyword">new</span> BeanHandler&lt;Book&gt;(Book<span class="class">.<span class="keyword">class</span>), 2)</span>;</span><br><span class="line">    System.out.println(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetBeanList</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 写sql语句</span></span><br><span class="line">    <span class="comment">// 当JavaBean的属性名与字段名不一致时，可以通过指定别名告知属性名</span></span><br><span class="line">    String sql = <span class="string">"select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? "</span>;</span><br><span class="line">    List&lt;Book&gt; list = qr.query(JDBCTools.getConnection(), sql, <span class="keyword">new</span> BeanListHandler&lt;Book&gt;(Book<span class="class">.<span class="keyword">class</span>), 10, 20)</span>;</span><br><span class="line">    <span class="keyword">for</span> (Book b : list) &#123;</span><br><span class="line">      System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetSingleValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line">    String sql = <span class="string">"select count(*) from books"</span>;</span><br><span class="line">    Long count = qr.query(JDBCTools.getConnection(), sql,  <span class="keyword">new</span> ScalarHandler&lt;Long&gt;());</span><br><span class="line">    System.out.println(count);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetMap</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String sql = <span class="string">"SELECT user_id userId,COUNT(*) FROM `orders` GROUP BY user_id"</span>;</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = qr.query(JDBCTools.getConnection(), sql, <span class="keyword">new</span> MapListHandler());</span><br><span class="line">    <span class="keyword">for</span> (Map&lt;String, Object&gt; map : list) &#123;</span><br><span class="line">      System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  <span class="keyword">private</span> String author;</span><br><span class="line">  <span class="keyword">private</span> Double price;</span><br><span class="line">  <span class="keyword">private</span> Integer sales;</span><br><span class="line">  <span class="keyword">private</span> Integer stock;</span><br><span class="line">  <span class="keyword">private</span> String imgPath =<span class="string">"static/img/default.jpg"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(Integer id, String title, String author, Double price, Integer sales, Integer stock, String imgPath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">    <span class="keyword">this</span>.author = author;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">    <span class="keyword">this</span>.sales = sales;</span><br><span class="line">    <span class="keyword">this</span>.stock = stock;</span><br><span class="line">    <span class="keyword">if</span>(imgPath != <span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">this</span>.imgPath = imgPath;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> author;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(String author)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.author = author;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Double <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> price;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(Double price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.price = price;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getSales</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sales;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSales</span><span class="params">(Integer sales)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sales = sales;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stock;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStock</span><span class="params">(Integer stock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.stock = stock;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getImgPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> imgPath;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImgPath</span><span class="params">(String imgPath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.imgPath = imgPath;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Book [id="</span> + id + <span class="string">", title="</span> + title + <span class="string">", author="</span> + author + <span class="string">", price="</span> + price + <span class="string">", sales="</span> + sales + <span class="string">", stock="</span> + stock + <span class="string">", imgPath="</span> + imgPath + <span class="string">"]"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DAO和增删改查通用方法"><a href="#DAO和增删改查通用方法" class="headerlink" title="DAO和增删改查通用方法"></a>DAO和增删改查通用方法</h1><p>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息</p><p>作用：为了实现功能的模块化，更有利于代码的维护和升级。</p><table><thead><tr><th><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc17.png" alt="jdbc"></th><th><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc18.png" alt="jdbc"></th></tr></thead><tbody><tr><td><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc19.png" alt="jdbc"></td><td><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jdbc20.png" alt="jdbc"></td></tr></tbody></table><h2 id="DAO接口"><a href="#DAO接口" class="headerlink" title="DAO接口"></a>DAO接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDAO</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据用户名和密码获取数据库中的记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> User：用户名和密码正确 null：用户名或密码不正确</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据用户名获取数据库中的记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true：用户名已存在， false：用户名可用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUserName</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将用户保存到数据库</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDAO</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所有图书的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBooks</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加图书的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据图书的id删除图书的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据图书的id获取图书信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Book <span class="title">getBookById</span><span class="params">(String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新图书信息的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Book book)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量更新图书的库存和销量</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchUpdateSalesAndStock</span><span class="params">(Object[][] params)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderDAO</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存订单的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> order</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOrder</span><span class="params">(Order order)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所用订单的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Order&gt; <span class="title">getOrders</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取我的订单的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Order&gt; <span class="title">getMyOrders</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新订单的状态的方法，例如已发货、确认收货等</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> orderId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> state</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateOrderState</span><span class="params">(String orderId, <span class="keyword">int</span> state)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderItemDAO</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据订单号获取对应的订单项</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> orderId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;OrderItem&gt; <span class="title">getOrderItemsByOrderId</span><span class="params">(String orderId)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量插入订单项的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchInsertOrderItems</span><span class="params">(Object[][] params)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BasicDAOImpl"><a href="#BasicDAOImpl" class="headerlink" title="BasicDAOImpl"></a>BasicDAOImpl</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个用来被继承的对数据库进行基本操作的Dao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicDAOImpl</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用的增删改操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String sql, Object... params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    Connection connection = JDBCTools.getConnection();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      count = queryRunner.update(connection, sql, params);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      <span class="comment">//将编译时异常转换为运行时异常向上抛</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; type,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    Connection connection = JDBCTools.getConnection();</span><br><span class="line">    T t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      t = queryRunner.query(connection, sql, <span class="keyword">new</span> BeanHandler&lt;T&gt;(type), params);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      <span class="comment">//将编译时异常转换为运行时异常向上抛</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所有对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">getBeanList</span><span class="params">(Class&lt;T&gt; type,String sql, Object... params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    Connection connection = JDBCTools.getConnection();</span><br><span class="line">    List&lt;T&gt; list = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      list = queryRunner.query(connection, sql, <span class="keyword">new</span> BeanListHandler&lt;T&gt;(type), params);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      <span class="comment">//将编译时异常转换为运行时异常向上抛</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个单一值的方法，专门用来执行像select count(*)... 这样的sql语句</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getSingleValue</span><span class="params">(String sql, Object... params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    Connection connection = JDBCTools.getConnection();</span><br><span class="line">    Object value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = queryRunner.query(connection, sql, <span class="keyword">new</span> ScalarHandler(), params);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      <span class="comment">//将编译时异常转换为运行时异常向上抛</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行批处理的方法</span></span><br><span class="line"><span class="comment"> * 关于二维数组Object[][] params</span></span><br><span class="line"><span class="comment"> * 二维数组的第一维是sql语句要执行的次数</span></span><br><span class="line"><span class="comment"> * 二维数组的第二维就是每条sql语句中要填充的占位符</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchUpdate</span><span class="params">(String sql , Object[][] params)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取连接</span></span><br><span class="line">    Connection connection = JDBCTools.getConnection();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      queryRunner.batch(connection ,sql, params);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      <span class="comment">//将编译时异常转换为运行时异常向上抛</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DAO实现类"><a href="#DAO实现类" class="headerlink" title="DAO实现类"></a>DAO实现类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDAOImpl</span> <span class="keyword">extends</span> <span class="title">BasicDAOImpl</span> <span class="keyword">implements</span> <span class="title">UserDAO</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 写查询数据库的sql语句</span></span><br><span class="line">    String sql = <span class="string">"select id , username , password , email from users where username = ? and password = ?"</span>;</span><br><span class="line">    <span class="comment">// 调用BaseDao中的getBean方法</span></span><br><span class="line">    User bean = getBean(User<span class="class">.<span class="keyword">class</span>, <span class="title">sql</span>, <span class="title">user</span>.<span class="title">getUsername</span>(), <span class="title">user</span>.<span class="title">getPassword</span>())</span>;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUserName</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 写查询数据库的sql语句</span></span><br><span class="line">    String sql = <span class="string">"select id , username , password , email from users where username = ?"</span>;</span><br><span class="line">    <span class="comment">// 调用BaseDao中的getBean方法</span></span><br><span class="line">    User bean = getBean(User<span class="class">.<span class="keyword">class</span>, <span class="title">sql</span>, <span class="title">user</span>.<span class="title">getUsername</span>())</span>;</span><br><span class="line">    <span class="keyword">return</span> bean!=<span class="keyword">null</span>;<span class="comment">//不为空，说明已存在，返回true，如果bEan是空的，没找到，bean!=null返回false，说明不存在</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//写添加数据到数据库的sql语句</span></span><br><span class="line">    String sql = <span class="string">"insert into users(username,password,email) values(?,?,?)"</span>;</span><br><span class="line">    <span class="comment">//调用BaseDao中通用的增删改的方法</span></span><br><span class="line">    update(sql, user.getUsername(),user.getPassword(),user.getEmail());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2020/06/29/java-mysql/"/>
      <url>/2020/06/29/java-mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL的使用"><a href="#MySQL的使用" class="headerlink" title="MySQL的使用"></a>MySQL的使用</h1><h2 id="启动和停止服务"><a href="#启动和停止服务" class="headerlink" title="启动和停止服务"></a>启动和停止服务</h2><p>关系型数据库分为桌面文件共享型数据库，例如Access，和C/S架构的网络共享型数据库，例如：MySQL，Oracle等。MySQL软件的服务器端必须先启动，客户端才可以连接和使用使用数据库。</p><h3 id="图形化方式"><a href="#图形化方式" class="headerlink" title="图形化方式"></a>图形化方式</h3><p>Windows：</p><ul><li><p>“我的电脑/计算机”–&gt;右键–&gt;“管理”–&gt;“服务”–&gt;启动和关闭MySQL</p></li><li><p>“开始菜单”–&gt;“控制面板”–&gt;“管理工具”–&gt;“服务”–&gt;启动和关闭MySQL</p></li><li><p>“任务管理器”–&gt;“服务”–&gt;启动和关闭MySQL</p></li></ul><p>Mac：</p><ul><li>打开MySQL软件，进行启动和关闭</li></ul><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><p>Windows：</p><ul><li>net  start  MySQL服务名</li><li>net  stop  MySQL服务名</li></ul><p>Mac：</p><ul><li>mysql.server start    启动MySQL</li><li>mysql.server stop    关闭MySQL</li><li>mysql.server status    查看MySQL状态</li></ul><h2 id="客户端命令行登录"><a href="#客户端命令行登录" class="headerlink" title="客户端命令行登录"></a>客户端命令行登录</h2><blockquote><p>mysql -h 主机名 -P 端口号 -u 用户名 -p密码</p></blockquote><p>例如：mysql -h localhost -P 3306 -u root -proot</p><p><strong>注意：</strong></p><ol><li><p>-p与密码之间不能有空格，其他参数名与参数值之间可以有空格也可以没有空格</p><p>mysql -hlocalhost -P3306 -uroot -proot</p></li><li><p>密码建议在下一行输入</p><p>mysql -h localhost -P 3306 -u root -p</p><p>Enter password:</p></li><li><p>如果是连本机：-hlocalhost就可以省略，如果端口号没有修改：-P3306也可以省略</p><p>简写成：mysql -u root -p</p><p>Enter password:</p></li></ol><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql1.png" alt="mysql"></p><h2 id="获取MySQL版本"><a href="#获取MySQL版本" class="headerlink" title="获取MySQL版本"></a>获取MySQL版本</h2><ol><li><p>登录成功后，有关于MySQL Server服务版本的信息，还有第几次连接的id标识。</p></li><li><p>或<strong>登录</strong>后，通过以下方式查看当前版本信息：</p></li></ol><ul><li>SELECT VERSION();</li></ul><ol start="3"><li>也可以在命令行通过以下方式获取MySQL Server服务版本的信息</li></ol><ul><li>mysql –version    获取MySQL版本信息</li></ul><h2 id="导入和导出数据"><a href="#导入和导出数据" class="headerlink" title="导入和导出数据"></a>导入和导出数据</h2><h3 id="单个数据库备份"><a href="#单个数据库备份" class="headerlink" title="单个数据库备份"></a>单个数据库备份</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32&gt; mysqldump -h主机地址 -P端口号 -u用户名 -p密码 --database 数据名 &gt; 文件路径&#x2F;文件名.sql</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32&gt;mysqldump -hlocalhost -P3306 -uroot -p123456 --database test &gt; d:&#x2F;test.sql</span><br></pre></td></tr></table></figure><h3 id="导入执行备份的sql脚本"><a href="#导入执行备份的sql脚本" class="headerlink" title="导入执行备份的sql脚本"></a>导入执行备份的sql脚本</h3><p>先登录mysql，然后执行如下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; source  sql脚本路径名.sql</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt;source d:&#x2F;test.sql;</span><br></pre></td></tr></table></figure><h1 id="Mysql的逻辑架构与存储引擎"><a href="#Mysql的逻辑架构与存储引擎" class="headerlink" title="Mysql的逻辑架构与存储引擎"></a>Mysql的逻辑架构与存储引擎</h1><h2 id="MySQL的逻辑架构"><a href="#MySQL的逻辑架构" class="headerlink" title="MySQL的逻辑架构"></a>MySQL的逻辑架构</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql2.png" alt="mysql"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql3.png" alt="mysql"></p><h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h2><p>MySQL最重要、最与众不同的特性是它的<strong>存储引擎架构</strong>，这种架构的设计将查询处理（Query Processing）及其他系统任务（Server Task）和数据的存储/提取相分离。这种处理和存储分离的设计可以在使用时根据性能、特性，以及其他需求来选择数据存储的方式。</p><p>MySQL中同一个数据库，不同的表格可以选择不同的存储引擎。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql4.png" alt="mysql"></p><ul><li>MyISAM不支持事务、也不支持外键，其优势是访问的速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应用。每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。</li><li>InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保存数据和索引。InnoDB：所有的表都保存在同一个数据文件中，InnoDB表的大小只受限于操作系统文件的大小限制。Myisam只缓存索引，不缓存真实数据；Innodb不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响。</li><li>MEMORY存储引擎使用存在于内存中的内容来创建表。MEMORY类型的表访问非常的快，因为它的数据是放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失。主要用于那些内容变化不频繁的代码表或者作为统计操作的中间结果表。</li></ul><h2 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h2><ul><li>SHOW ENGINES;     查看当前mysql数据库管理软件支持的存储引擎</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql5.png" alt="mysql"></p><ul><li>SHOW VARIABLES LIKE ‘%storage_engine%’;    查看默认存储引擎和当前选择的存储引擎</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql6.png" alt="mysql"></p><p>创建新表时如果不指定存储引擎，那么系统就会使用默认存储引擎，MySQL5.5之前的默认存储引擎是MyISAM，5.5之后改为了InnoDB。</p><ul><li>SHOW CREATE TABLE 表名称;    查看已经创建的表格的存储引擎</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql7.png" alt="mysql"></p><h1 id="简单的SQL示例"><a href="#简单的SQL示例" class="headerlink" title="简单的SQL示例"></a>简单的SQL示例</h1><h2 id="示例小demo"><a href="#示例小demo" class="headerlink" title="示例小demo"></a>示例小demo</h2><p>查看当前的MySQL服务器中有哪些数据库</p><ul><li>SHOW DATABASES;</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line"></span><br><span class="line">+--------------------+</span><br><span class="line"></span><br><span class="line">| Database      |</span><br><span class="line"></span><br><span class="line">+--------------------+</span><br><span class="line"></span><br><span class="line">| information_schema |</span><br><span class="line"></span><br><span class="line">| mysql        |</span><br><span class="line"></span><br><span class="line">| performance_schema |</span><br><span class="line"></span><br><span class="line">| test        |</span><br><span class="line"></span><br><span class="line">+--------------------+</span><br><span class="line"></span><br><span class="line">4 rows in set (0.05 sec)</span><br></pre></td></tr></table></figure><p>使用test数据库</p><ul><li>USE 数据库名;</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; USE test;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure><p>创建表</p><ul><li>CREATE TABLE 表名(列…);</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t_stu(</span><br><span class="line">    -&gt;  sid INT,</span><br><span class="line">    -&gt;  sname VARCHAR(100),</span><br><span class="line">    -&gt;  gender CHAR</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.14 sec)</span><br></pre></td></tr></table></figure><p>查看表结构</p><ul><li>DESC 表名;</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; DESC t_stu;</span><br><span class="line">+--------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type         | Null | Key | Default | Extra |</span><br><span class="line">+--------+--------------+------+-----+---------+-------+</span><br><span class="line">| sid    | int(11)      | YES  |     | NULL    |       |</span><br><span class="line">| sname  | varchar(100) | YES  |     | NULL    |       |</span><br><span class="line">| gender | char(1)      | YES  |     | NULL    |       |</span><br><span class="line">+--------+--------------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure><p>插入记录</p><ul><li>INSERT INTO 表名 VALUES(列值…);</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT INTO t_stu VALUES(1,&#39;张三&#39;,&#39;男&#39;);</span><br><span class="line">Query OK, 1 row affected (0.06 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO t_stu VALUES(2,&#39;李四&#39;,&#39;男&#39;);</span><br><span class="line">Query OK, 1 row affected (0.09 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO t_stu VALUES(3,&#39;王五&#39;,&#39;男&#39;);</span><br><span class="line">Query OK, 1 row affected (0.06 sec)</span><br></pre></td></tr></table></figure><p>查看记录</p><ul><li>SELECT * FROM 表名;</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t_stu;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| sid  | sname | gender |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">|    1 | 张三      | 男       |</span><br><span class="line">|    2 | 李四      | 男       |</span><br><span class="line">|    3 | 王五      | 男       |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>修改记录</p><ul><li>UPDATE 表名 SET 列名 = 值 WHERE 条件;</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; UPDATE t_stu SET sname &#x3D; &#39;张三丰&#39; WHERE sid &#x3D; 1;</span><br><span class="line">Query OK, 1 row affected (0.08 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM t_stu;</span><br><span class="line">+------+--------+--------+</span><br><span class="line">| sid  | sname  | gender |</span><br><span class="line">+------+--------+--------+</span><br><span class="line">|    1 | 张三丰       | 男       |</span><br><span class="line">|    2 | 李四       | 男       |</span><br><span class="line">|    3 | 王五       | 男       |</span><br><span class="line">+------+--------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>删除记录</p><ul><li>DELETE FROM 表名 WHERE 条件;</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; DELETE FROM t_stu WHERE sid &#x3D; 1;</span><br><span class="line">Query OK, 1 row affected (0.08 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM t_stu;</span><br><span class="line">+------+-------+--------+</span><br><span class="line">| sid  | sname | gender |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">|    2 | 李四      | 男       |</span><br><span class="line">|    3 | 王五      | 男       |</span><br><span class="line">+------+-------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="错误ERROR-：没有选择数据库就操作表格和数据"><a href="#错误ERROR-：没有选择数据库就操作表格和数据" class="headerlink" title="错误ERROR ：没有选择数据库就操作表格和数据"></a>错误ERROR ：没有选择数据库就操作表格和数据</h2><blockquote><p>ERROR 1046 (3D000): No database selected</p><p>解决方案一：就是使用“USE 数据库名;”语句，这样接下来的语句就默认针对这个数据库进行操作</p><p>解决方案二：就是所有的表对象前面都加上“数据库.”</p></blockquote><h2 id="命令行客户端的字符集问题"><a href="#命令行客户端的字符集问题" class="headerlink" title="命令行客户端的字符集问题"></a>命令行客户端的字符集问题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT INTO t_stu VALUES(1,&#39;张三&#39;,&#39;男&#39;);</span><br><span class="line">ERROR 1366 (HY000): Incorrect string value: &#39;\xD5\xC5\xC8\xFD&#39; for column &#39;sname&#39; at row 1</span><br></pre></td></tr></table></figure><p>原因：服务器端认为你的客户端的字符集是utf-8，而实际上你的客户端的字符集是GBK</p><ul><li>SHOW VARIABLES LIKE ‘character_set_%’;    查看所有字符集</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql8.png" alt="mysql"></p><ul><li>SET NAMES GBK;    设置当前连接的客户端字符集</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql9.png" alt="mysql"></p><h2 id="查看字符集和校对规则"><a href="#查看字符集和校对规则" class="headerlink" title="查看字符集和校对规则"></a>查看字符集和校对规则</h2><p>关于SQL的关键字和函数名等不区分大小写，但是对于数据值是否区分大小写，和字符集与校对规则有关。</p><p>_ci（大小写不敏感），_cs（大小写敏感），_bin（二元，即比较是基于字符编码的值而与language无关）</p><h3 id="查看所有字符集和校对规则"><a href="#查看所有字符集和校对规则" class="headerlink" title="查看所有字符集和校对规则"></a>查看所有字符集和校对规则</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql10.png" alt="mysql"></p><h3 id="查看GBK和UTF-8字符集的校对规则"><a href="#查看GBK和UTF-8字符集的校对规则" class="headerlink" title="查看GBK和UTF-8字符集的校对规则"></a>查看GBK和UTF-8字符集的校对规则</h3><ul><li>show collation like ‘gbk%’;</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql11.png" alt="mysql"></p><ul><li>show collation like ‘utf8%’;</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql12.png" alt="mysql"></p><p>utf8_unicode_ci和utf8_general_ci对中、英文来说没有实质的差别。<br>utf8_general_ci 校对速度快，但准确度稍差。<br>utf8_unicode_ci 准确度高，但校对速度稍慢。</p><p>如果你的应用有德语、法语或者俄语，请一定使用utf8_unicode_ci。一般用utf8_general_ci就够了。</p><h3 id="查看服务器的字符集和校对规则"><a href="#查看服务器的字符集和校对规则" class="headerlink" title="查看服务器的字符集和校对规则"></a>查看服务器的字符集和校对规则</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql13.png" alt="mysql"></p><h3 id="查看和修改某个数据库的字符集和校对规则"><a href="#查看和修改某个数据库的字符集和校对规则" class="headerlink" title="查看和修改某个数据库的字符集和校对规则"></a>查看和修改某个数据库的字符集和校对规则</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql14.png" alt="mysql"></p><p>或</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql15.png" alt="mysql"></p><p>修改数据库的字符集和校对规则：</p><p>ALTER DATABASE 数据库名称 DEFAULT CHARACTER SET 字符集名称 【COLLATE 校对规则名称】;</p><p>例如：</p><p>ALTER DATABASE ceshi_db DEFAULT CHARACTER SET utf8 collate utf8_general_ci;</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql16.png" alt="mysql"></p><p>注意：修改了数据库的默认字符集和校对规则后，原来已经创建的表格的字符集和校对规则并不会改变，如果需要，那么需要单独修改。</p><h3 id="查看某个表格的字符集和校对规则"><a href="#查看某个表格的字符集和校对规则" class="headerlink" title="查看某个表格的字符集和校对规则"></a>查看某个表格的字符集和校对规则</h3><ul><li>show create table users;    查看字符集</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql17.png" alt="mysql"></p><ul><li>show table status from bookstore like ‘%users%’ ;    查看校对规则</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql18.png" alt="mysql"></p><p>修改某个表格的字符集和校对规则：</p><p>修改表的默认字符集：</p><p>ALTER TABLE 表名称 DEFAULT CHARACTER SET 字符集名称 【COLLATE 校对规则名称】;</p><p>把表默认的字符集和所有字符列（CHAR,VARCHAR,TEXT）改为新的字符集：</p><p>ALTER TABLE 表名称 CONVERT TO CHARACTER SET 字符集名称 【COLLATE 校对规则名称】;</p><p>例如：ALTER TABLE ceshi_table DEFAULT CHARACTER SET gbk collate gbk_chinese_ci;</p><h1 id="MySQL的数据类型"><a href="#MySQL的数据类型" class="headerlink" title="MySQL的数据类型"></a>MySQL的数据类型</h1><p>常用的数据类型有：</p><ul><li>整型（xxxint）</li><li>位类型(bit)</li><li>浮点型（float和double、real）</li><li>定点数（decimal,numeric）</li><li>日期时间类型（date,time,datetime,year）</li><li>字符串（char,varchar,xxxtext）</li><li>二进制数据（xxxBlob、xxbinary）</li><li>枚举（enum）</li><li>集合（set）</li></ul><h2 id="整数（xxxint）"><a href="#整数（xxxint）" class="headerlink" title="整数（xxxint）"></a>整数（xxxint）</h2><table><thead><tr><th>整数类型</th><th>字节</th><th>最小值（有符号/无符号）</th><th>最大值（有符号/无符号）</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128/0</td><td>127/255</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768/0</td><td>32767/65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>-8388608/0</td><td>8388607/1677215</td></tr><tr><td>INT、INTEGER</td><td>4</td><td>-2147483648/0</td><td>2147483647/4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-9223372036854775808/0</td><td>9223372036854775807/18446744073709551615</td></tr></tbody></table><p>整数列的可选属性有三个：</p><ul><li>M: 宽度(在0填充的时候才有意义，否则不需要指定)</li><li>unsigned: 无符号类型(非负)</li><li>zerofill: 0填充,(如果某列是zerofill，那么默认就是无符号)，如果指定了zerofill只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可</li></ul><p>原来，在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3)、int(4)、int(8) 在磁盘上都是占用 4 bytes 的存储空间。</p><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>对于浮点列类型，在MySQL中单精度值使用4个字节，双精度值使用8个字节</p><ul><li>MySQL允许使用非标准语法（其他数据库未必支持，因此如果设计到数据迁移，则最好不要这么用）：FLOAT(M,D)或DOUBLE(M,D)。这里，(M,D)表示该值一共显示M位，其中D表示小数点后几位，M和D又称为精度和标度。例如，定义为FLOAT(5,2)的一个列可以显示为-999.99-999.99。M取值范围为0<del>255。D取值范围为0</del>30，同时必须&lt;=M。</li><li>如果存储时，整数部分超出了范围（如上面的例子中，添加数值为1000.01），MySql就会报错，不允许存这样的值。如果存储时，小数点部分若超出范围，就分以下情况：若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存，例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。若四舍五入后，整数部分超出范围，则MySql报错，并拒绝处理。如999.995和-999.995都会报错。</li><li>说明：小数类型，也可以加unsigned，但是不会改变数据范围，例如：float(3,2) unsigned仍然只能表示0-9.99的范围。</li><li>float和double在不指定精度时，默认会按照实际的精度（由实际的硬件和操作系统决定）来显示</li><li>REAL就是DOUBLE ，如果SQL服务器模式包括REAL_AS_FLOAT选项，REAL是FLOAT的同义词而不是DOUBLE的同义词。</li></ul><p>注意：在编程中，如果用到浮点数，要特别注意误差问题，因为浮点数是不准确的，所以我们要避免使用“=”来判断两个数是否相等。如果希望保证值比较准确，推荐使用定点数数据类型。</p><h2 id="定点型"><a href="#定点型" class="headerlink" title="定点型"></a>定点型</h2><ul><li>DECIMAL在MySQL内部以字符串形式存放，比浮点数更精确。定点类型占M+2个字节</li><li>DECIMAL(M,D)与浮点型一样处理规则。M的取值范围为0<del>65，D的取值范围为0</del>30，而且必须&lt;=M，超出范围会报错。</li><li>DECIMAL如果指定精度时，默认的整数位是10，默认的小数位为0。</li><li>NUMERIC等价于DECIMAL。</li></ul><h2 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a>日期时间类型</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql19.png" alt="mysql"></p><ul><li>对于year类型，可以输入4位数，例如2018，也可以输入两位数，例如18，如果输入的是两位，“00-68”表示2000-2069年，“70-99”表示1970-1999年。</li><li>‘YYYY-MM-DD HH:MM:SS’或’YY-MM-DD HH:MM:SS’，’YYYY-MM-DD’或’YY-MM-DD’格式的字符串。允许“不严格”语法：任何标点符都可以用做日期部分或时间部分之间的间割符。例如，’98-12-31 11:30:45’、’98.12.31 11+30+45’、’98/12/31 11<em>30</em>45’和‘98@12@31 11^30^45’是等价的。</li><li>‘YYYYMMDD’或’YYMMDD’格式的没有间割符的字符串，假定字符串对于日期类型是有意义的。例如，’19970523’和’970523’被解释为 ‘1997-05-23’，但’971332’是不合法的(它有一个没有意义的月和日部分)，将变为’0000-00-00’。</li><li>对于包括日期部分间割符的字符串值，如果日和月的值小于10，不需要指定两位数。’1979-6-9’与’1979-06-09’是相同的。同样，对于包括时间部分间割符的字符串值，如果时、分和秒的值小于10，不需要指定两位数。’1979-10-30 1:2:3’与’1979-10-30 01:02:03’相同。</li><li>数字值应为6、8、12或者14位长。如果一个数值是8或14位长，则假定为YYYYMMDD或YYYYMMDDHHMMSS格式，前4位数表示年。如果数字 是6或12位长，则假定为YYMMDD或YYMMDDHHMMSS格式，前2位数表示年。其它数字被解释为仿佛用零填充到了最近的长度。</li><li>一般存注册时间、商品发布时间等，不建议使用datetime存储，而是使用时间戳，因为datetime虽然直观，但不便于计算。而且timestamp还有一个重要特点，就是和时区有关。还有如果插入NULL，会自动设置为当前系统时间。</li></ul><h2 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h2><table><thead><tr><th>类型</th><th>说明</th><th>典型声明方式</th><th>范围</th></tr></thead><tbody><tr><td>char</td><td>定长字符串</td><td>gender Char(1)</td><td>Char(M) 0&lt;=M&lt;=255</td></tr><tr><td>Varchar</td><td>变长字符串</td><td>email varchar(20)</td><td>Varchar(M) 0&lt;=M&lt;=65535 (约2W-6W个字符受字符集影响)</td></tr><tr><td>text</td><td>文本串</td><td>content text</td><td>约2W-6W个字符(受字符集影响)</td></tr></tbody></table><h3 id="char-varchar-text区别"><a href="#char-varchar-text区别" class="headerlink" title="char,varchar,text区别"></a>char,varchar,text区别</h3><p>char是一种固定长度的类型，varchar则是一种可变长度的类型，它们的区别是：</p><ul><li>char如果不指定(M)则表示长度默认是1个字符。varchar必须指定(M)。</li><li>char(M)类型的数据列里，每个值都占用M个<strong>字符</strong>，如果某个长度小于M，MySQL就会在它的右边用空格字符补足（在检索操作中那些填补出来的空格字符将被去掉；如果存入时右边本身就带空格，检索时也会被去掉）；在varchar(M)类型的数据列里，每个值只占用刚好够用的字符再加上一个到两个用来记录其长度的字节（即总长度为L字符+1/2字字节）。</li><li>由于某种原因char 固定长度，所以在处理速度上要比varchar快速很多，但相对费存储空间，所以对存储不大，但在速度上有要求的可以使用char类型，反之可以用varchar类型来实例。</li><li>text文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用char，varchar来代替。还有text类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含text类型字段，建议单独分出去，单独用一个表。</li></ul><h3 id="哪些情况使用char或varchar更好"><a href="#哪些情况使用char或varchar更好" class="headerlink" title="哪些情况使用char或varchar更好"></a>哪些情况使用char或varchar更好</h3><ul><li>一，存储很短的信息，比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的现在得不偿失。</li><li>二，固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息。</li><li>三，十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。</li><li>MyISAM和MEMORY存储引擎中无论使用char还是varchar其实都是作为char类型处理的。</li><li>其他像InnoDB存储引擎，建议使用varchar类型，因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且主要影响性能的因素是数据行使用的存储总量，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。</li></ul><h2 id="位类型"><a href="#位类型" class="headerlink" title="位类型"></a>位类型</h2><p>BIT数据类型可用来保存位字段值。BIT(M)类型允许存储M位值。M范围为1~64，默认为1。</p><p>BIT其实就是存入二进制的值，类似010110。如果存入一个BIT类型的值，位数少于M值，则左补0。如果存入一个BIT类型的值，位数多于M值，MySQL的操作取决于此时有效的SQL模式：如果模式未设置，MySQL将值裁剪到范围的相应端点，并保存裁减好的值。如果模式设置为traditional(“严格模式”)，超出范围的值将被拒绝并提示错误，并且根据SQL标准插入会失败。</p><p>对于位字段，直接使用SELECT命令将不会看到结果，可以用bin()或hex()函数进行读取。</p><h2 id="二进制值类型"><a href="#二进制值类型" class="headerlink" title="二进制值类型"></a>二进制值类型</h2><p>包括：xxxBLOB和xxxBINARY</p><p>BINARY和VARBINARY类型类似于CHAR和VARCHAR类型，但是不同的是，它们存储的不是字符字符串，而是二进制串。所以它们没有字符集，并且排序和比较基于列值字节的数值值。当保存BINARY(M)值时，在它们右边填充0x00(零字节)值以达到指定长度。取值时不删除尾部的字节。比较时所有字节很重要（因为空格和0x00是不同的，0x00&lt;空格），包括ORDER BY和DISTINCT操作。比如插入’a ‘会变成’a \0’。</p><p>BLOB是一个二进制大对象，可以容纳可变数量的数据。有4种BLOB类型：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。它们只是可容纳值的最大长度不同。分别与四种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT和LONGTEXT对应有相同的最大长度和存储需求。在TEXT或BLOB列的存储或检索过程中，不存在大小写转换。BLOB和TEXT列不能有默认值。BLOB或TEXT对象的最大大小由其类型确定，但在客户端和服务器之间实际可以传递的最大值由可用内存数量和通信缓存区大小确定。你可以通过更改max_allowed_packet变量的值更改消息缓存区的大小，但必须同时修改服务器和客户端程序。</p><h2 id="枚举（ENUM）"><a href="#枚举（ENUM）" class="headerlink" title="枚举（ENUM）"></a>枚举（ENUM）</h2><p>MySql中的ENUM是一个字符串对象，其值来自表创建时在列规定中显式枚举的一列值：</p><ul><li><p>可以插入空字符串””和NULL（如果运行NULL的话）。</p></li><li><p>如果你将一个非法值插入ENUM(也就是说，允许的值列之外的字符串)，如果是严格模式，将不能插入，如果是非严格模式，将选用第一个元素代替，并警告。</p></li><li><p>ENUM最多可以有65,535个成员，需要2个字节存储。</p></li><li><p>当创建表时，ENUM成员值的尾部空格将自动被删除。</p><p>例如：enum(‘M’,’F’)</p></li></ul><p>值的索引规则如下：</p><ul><li>来自列规定的允许的值列中的值从1开始编号。</li><li>空字符串错误值的索引值是0。</li><li>NULL值的索引是NULL。</li></ul><h2 id="集合（SET）"><a href="#集合（SET）" class="headerlink" title="集合（SET）"></a>集合（SET）</h2><p>SET和ENUM类型非常类似，也是一个字符串对象，里面包含0~64个成员。</p><p>SET和ENUM存储上有所不同，SET是根据成员的个数决定存储的字节数。</p><p>SET和ENUM最主要的区别在于SET类型一次可以选择多个成员，而ENUM则只能选择一个。</p><p>例如：set(‘a’,’b’,’c’,’d’)</p><h2 id="特殊的NULL值"><a href="#特殊的NULL值" class="headerlink" title="特殊的NULL值"></a>特殊的NULL值</h2><p><strong>Null特征：</strong></p><ol><li><p>所有的类型的值都可以是null，包括int、float等数据类型</p></li><li><p>空字符串””，不等于null，0也不等于null，false也不等于null</p></li><li><p>任何运算符,判断符碰到NULL,都得NULL</p></li><li><p>NULL的判断只能用is null,is not null</p></li><li><p>NULL 影响查询速度,一般避免使值为NULL</p></li></ol><p><strong>面试：</strong></p><p>为什么建表时,加not null default ‘’ 或 default 0</p><p>答:不想让表中出现null值.</p><p>为什么不想要的null的值</p><p>答:</p><ol><li><p>不好比较,null是一种特殊值,比较时,只能用专门的is null 和 is not null来比较.</p><p>碰到运算符,一律返回null</p></li><li><p>效率不高,影响提高索引效果.</p><p>因此,我们往往,在建表时 not null default ‘’ 或 default 0</p></li></ol><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>SQL：Structure Query Language结构化查询语言，它是使用关系模型的数据库应用语言，由IBM上世纪70年代开发出来。后由美国国家标准局（ANSI）开始着手制定SQL标准，先后有SQL-86，SQL-89，SQL-92，SQL-99等标准。</p><h2 id="SQL的语言规范"><a href="#SQL的语言规范" class="headerlink" title="SQL的语言规范"></a>SQL的语言规范</h2><ul><li>mysql对于SQL语句不区分大小写，SQL语句关键字尽量大写</li><li>值，除了数值型，字符串型和日期时间类型使用单引号（’’）</li><li>别名，尽量使用双引号（””），而且不建议省略as</li><li>所有标点符号使用英文状态下的半角输入方式</li><li>必须保证所有(),单引号，双引号是成对结束的</li><li>可以使用（1）#单行注释 （2）–空格单行注释 （3）/*  多行注释  */</li></ul><p><strong>命名规则：</strong></p><ul><li>数据库、表名不得超过30个字符，变量名限制为29个</li><li>必须只能包含 A–Z, a–z, 0–9, _共63个字符</li><li>不能在对象名的字符间留空格</li><li>必须不能和用户定义的其他对象重名</li><li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突</li><li>保持字段名和类型的一致性,在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数,那在另一个表里可就别变成字符型了</li></ul><p>在命令行中的要求：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql20.png" alt="mysql"></p><p>说明：一个语句可以分开多行编写，以;或\g结束</p><h2 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h2><p>SQL的分类：</p><ul><li><p>DDL（Data Definition Languages)：数据定义语言，这些语句定义了不同的数据段、数据库、表、列、索引等数据库对象。</p><p>主要的语句关键字包括create、drop、alter等。</p></li><li><p>DML（Data Manipulation Language）：数据操作语句，用于添加、删除、更新和查询数据库记录，并检查数据完整性。</p><p>主要的语句关键字包括insert、delete、update、select等。</p></li><li><p>DCL（Data Control Language）：数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括grant、revoke等。</p></li></ul><h1 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h1><h2 id="操作Database"><a href="#操作Database" class="headerlink" title="操作Database"></a>操作Database</h2><p>注意：database不能改名。一些可视化工具可以改名，它是建新库,把所有表复制到新库,再删旧库完成的。</p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ul><li><p>create database 数据库名 [charset 字符集];  (关键字大写效果：CREATE DATABASE 数据库名;)</p><p>如果不指定字符集，则按照安装mysql服务时选择的默认字符集。</p></li></ul><h3 id="查看有哪些数据库"><a href="#查看有哪些数据库" class="headerlink" title="查看有哪些数据库"></a>查看有哪些数据库</h3><ul><li><p>show databases;</p><p>提示：当前用户有权限查看的</p></li></ul><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><ul><li>drop database 数据库名;</li></ul><h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><ul><li>use 数据库名;</li></ul><h3 id="查看当前正在使用哪个数据库"><a href="#查看当前正在使用哪个数据库" class="headerlink" title="查看当前正在使用哪个数据库"></a>查看当前正在使用哪个数据库</h3><ul><li>select database();</li></ul><p>注意：要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上“数据库名.”</p><h2 id="表结构的操作TABLE"><a href="#表结构的操作TABLE" class="headerlink" title="表结构的操作TABLE"></a>表结构的操作TABLE</h2><h3 id="查看当前数据库的所有表格"><a href="#查看当前数据库的所有表格" class="headerlink" title="查看当前数据库的所有表格"></a>查看当前数据库的所有表格</h3><ul><li><p>show tables;  </p><p>前面必须有use 数据库名语句，否则报错ERROR 1046 (3D000): No database selected</p></li><li><p>show tables from 数据库名;</p></li></ul><h3 id="创建表结构"><a href="#创建表结构" class="headerlink" title="创建表结构"></a>创建表结构</h3><h4 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名称(</span><br><span class="line">字段名1 数据类型1,</span><br><span class="line">字段名2 数据类型2,</span><br><span class="line">字段名3 数据类型3</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE t_stu(</span><br><span class="line">sid INT,</span><br><span class="line">sname VARCHAR(100),</span><br><span class="line">gender CHAR</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 如果没有使用ust 数据库名的情况</span><br><span class="line">CREATE TABLE 数据库名.t_stu(</span><br><span class="line">sid INT,</span><br><span class="line">sname VARCHAR(100),</span><br><span class="line">gender CHAR</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="详细版"><a href="#详细版" class="headerlink" title="详细版"></a>详细版</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名称(</span><br><span class="line">字段名1 数据类型1 主键 自增长,</span><br><span class="line">字段名2 数据类型2 非空 默认值,</span><br><span class="line">字段名3 数据类型3</span><br><span class="line">)ENGINE&#x3D;当前表格的引擎 AUTO_INCREMENT&#x3D;自增长的起始值 DEFAULT CHARSET&#x3D;表数据的默认字符集;</span><br><span class="line"></span><br><span class="line">CREATE TABLE t_stu(</span><br><span class="line">sid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">sname VARCHAR(100) NOT NULL,</span><br><span class="line">gender CHAR NOT NULL DEFAULT &#39;男&#39;</span><br><span class="line">)ENGINE&#x3D;INNODB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><h3 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h3><ul><li>desc 表名称;</li><li>SHOW CREATE TABLE 表名;    查看表的定义</li></ul><h3 id="删除表结构"><a href="#删除表结构" class="headerlink" title="删除表结构"></a>删除表结构</h3><ul><li>drop table 表名称;</li></ul><p>注意：</p><p>数据和结构都被删除</p><p>所有正在运行的相关事务被提交</p><p>所有相关索引被删除</p><p>DROP TABLE 语句不能回滚</p><h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><h4 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h4><ul><li><p>alter table 表名 rename 新表名;</p></li><li><p>rename table 表名 to 新表名; </p></li></ul><h4 id="增加一列"><a href="#增加一列" class="headerlink" title="增加一列"></a>增加一列</h4><ul><li><p>alter table 表名 add 【column】 列名 数据类型 【default 默认值】【not null】;  #默认在最后</p></li><li><p>alter table 表名 add 【column】 列名 数据类型 【default 默认值】【not null】 after 某一列;</p></li><li><p>alter table 表名 add 【column】 列名 数据类型 【default 默认值】【not null】 first;</p></li></ul><h4 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h4><ul><li>alter table 表名 drop 【column】 列名;</li></ul><h4 id="修改列类型"><a href="#修改列类型" class="headerlink" title="修改列类型"></a>修改列类型</h4><ul><li><p>alter table 表名 modify 【column】 列名 数据类型【default 默认值】【not null】;</p></li><li><p>alter table 表名 modify 【column】 列名 数据类型【default 默认值】【not null】 after 某一列;</p></li><li><p>alter table 表名 modify 【column】 列名 数据类型【default 默认值】【not null】 first;</p></li></ul><h4 id="修改列名等"><a href="#修改列名等" class="headerlink" title="修改列名等"></a>修改列名等</h4><ul><li>alter table 表名 change 【column】 列名 新列名 数据类型【default 默认值】【not null】;</li></ul><h3 id="约束：CONSTRAINTS"><a href="#约束：CONSTRAINTS" class="headerlink" title="约束：CONSTRAINTS"></a>约束：CONSTRAINTS</h3><p>数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是应防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。数据的完整性要从以下四个方面考虑：</p><ul><li>实体完整性（Entity Integrity）：例如，同一个表中，不能存在两条完全相同无法区分的记录</li><li>域完整性（Domain Integrity）：例如：年龄范围0-120，性别范围“男/女”</li><li>引用完整性（Referential Integrity）：例如：员工所在部门，在部门表中要能找到这个部门</li><li>用户自定义完整性（User-defined Integrity）：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍。</li></ul><p><strong>根据约束的特点，分为几种：</strong></p><ul><li>键约束：主键约束、外键约束、唯一键约束</li><li>Not NULL约束：非空约束</li><li>Check约束：检查约束</li><li>Default约束：缺省约束</li></ul><h4 id="查看某个表的约束和索引"><a href="#查看某个表的约束和索引" class="headerlink" title="查看某个表的约束和索引"></a>查看某个表的约束和索引</h4><ul><li>SELECT * FROM information_schema.table_constraints WHERE table_name = ‘表名称’;</li><li>SHOW INDEX FROM 表名称;</li><li>SHOW CREATE TABLE 表名;</li></ul><h4 id="主键约束PRIMARY-KEY"><a href="#主键约束PRIMARY-KEY" class="headerlink" title="主键约束PRIMARY KEY"></a>主键约束PRIMARY KEY</h4><p>主键：Primary key，简称PK，数据库主键作用保证实体的完整性，可以是一个列或多列的组合。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql21.png" alt="mysql"></p><ul><li><p>主键约束相当于<strong>唯一约束+非空约束</strong>的组合，主键约束列不允许重复，也不允许出现空值，如果是多列组合的主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。</p></li><li><p><strong>每个表有且最多只允许一个主键约束</strong>。</p></li><li><p>MySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用。</p></li><li><p>当创建主键约束时，MySQL默认在对应的列上建立<strong>主键键索</strong>。删除主键时，也会直接删除主键索引。</p></li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql22.png" alt="mysql"></p><h4 id="唯一键Unique-key，简称UK"><a href="#唯一键Unique-key，简称UK" class="headerlink" title="唯一键Unique key，简称UK"></a>唯一键Unique key，简称UK</h4><ul><li>同一个表可以有多个唯一约束。</li><li>唯一约束可以是某一个列的值唯一，也可以多个列组合值的唯一。</li><li>MySQL会给唯一约束的列上默认创建一个<strong>唯一索引</strong>。</li><li>删除唯一键只能通过删除唯一索引的方式删除，删除时需要指定唯一索引名，唯一索引名就是唯一约束名一样。如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同，如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql23.png" alt="mysql"></p><h4 id="外键：Foreign-key，简称FK"><a href="#外键：Foreign-key，简称FK" class="headerlink" title="外键：Foreign key，简称FK"></a>外键：Foreign key，简称FK</h4><ul><li>外键约束是保证一个或两个表之间的参照完整性,外键是构建于一个表的两个字段或是两个表的两个字段之间的参照关系。</li><li>在创建外键约束时，如果不给外键约束名称，默认名不是列名，而是自动产生一个外键名（例如 student_ibfk_1;），也可以指定外键约束名。</li><li>当创建外键约束时，系统默认会在所在的列上建立对应的<strong>普通索引</strong>。但是索引名是列名，不是外键的约束名。</li><li>删除外键时，关于外键列上的普通<strong>索引需要单独删除</strong>。</li></ul><p><strong>约束关系：</strong></p><p>约束是针对双方的</p><ul><li>添加了外键约束后，主表的修改和删除受约束</li><li>添加了外键约束后，从表的添加和修改受约束</li></ul><p><strong>5个约束等级</strong></p><ul><li>Cascade方式：在父表上update/delete记录时，同步update/delete掉子表的匹配记录</li><li>Set null方式：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null</li><li>No action方式：如果子表中有匹配的记录,则不允许对父表对应候选键进行update/delete操作</li><li>Restrict方式：同no action, 都是立即检查外键约束</li><li>Set default方式（在可视化工具SQLyog中可能显示空白）：父表有变更时,子表将外键列设置成一个默认的值，但Innodb不能识别如果没有指定等级，就相当于Restrict方式</li></ul><p><strong>注意：</strong></p><ul><li>在从表上建立外键，而且主表要先存在。</li><li>从表的外键列，在主表中引用的只能是键列（主键，唯一键，外键）。</li><li>从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样。</li><li>一个表可以建立多个外键约束</li><li>从表的外键值必须”在主表中能找到”或者为空，从而约束了从表的外键列的值的添加和修改。</li><li>当主表的记录被从表参照时，主表中被参考记录的删除和更新也会受到限制。<ul><li><ol><li>默认情况下，主表和从表是严格依赖关系RESTRICT。当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据。</li></ol></li><li><ol start="2"><li>但是有一种是级联“修改、删除”：</li></ol></li><li>ON DELETE SET NULL(级联置空)：当外键设置了SET NULL,当主表的相关记录删除时，从表对应的字段改为NULL。注意从表外键字段得允许为空才行</li><li>ON DELETE CASCADE(级联删除)：当外键设置了CASCADE（级联），当主表的相关记录删除时，从表对应的行都删除了。</li><li>对于外键约束,最好是采用: ON UPDATE CASCADE ON DELETE RESTRICT 的方式</li></ul></li><li>如果要删除表，需要先删除从表，才能删除主表</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql24.png" alt="mysql"></p><p>如何建立外键约束？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建外键</span><br><span class="line"></span><br><span class="line">CREATE TABLE t_department(</span><br><span class="line">did INT PRIMARY KEY,</span><br><span class="line">dname VARCHAR(100) NOT NULL UNIQUE,</span><br><span class="line">description VARCHAR(200) NOT NULL</span><br><span class="line">);</span><br><span class="line">CREATE TABLE t_employee(</span><br><span class="line">eid INT PRIMARY KEY,</span><br><span class="line">ename VARCHAR(100) NOT NULL,</span><br><span class="line">dept_id INT,</span><br><span class="line">CONSTRAINT fk_emp_dept_did FOREIGN KEY(dept_id) REFERENCES t_department(did) ON UPDATE CASCADE ON DELETE RESTRICT</span><br><span class="line">);</span><br><span class="line">#其中CONSTRAINT fk_emp_dept_did可以省略</span><br><span class="line">#ON UPDATE CASCADE ON DELETE RESTRICT如果省略表示都是RESTRICT</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一个表可以有多个外键，而且主表和从表可以是一张表</span><br><span class="line"></span><br><span class="line">CREATE TABLE t_emp(</span><br><span class="line">eid INT PRIMARY KEY,</span><br><span class="line">ename VARCHAR(100) NOT NULL,</span><br><span class="line">manager_id INT,</span><br><span class="line">dept_id INT,</span><br><span class="line">CONSTRAINT fk_emp_dept_did FOREIGN KEY(dept_id) REFERENCES t_department(did)  ON UPDATE CASCADE ON DELETE RESTRICT,</span><br><span class="line">CONSTRAINT fk_emp_mid_eid FOREIGN KEY(manager_id) REFERENCES t_emp(eid)  ON UPDATE CASCADE ON DELETE RESTRICT</span><br><span class="line">);</span><br><span class="line">#其中CONSTRAINT fk_emp_dept_did可以省略</span><br><span class="line">#ON UPDATE CASCADE ON DELETE RESTRICT如果省略表示都是RESTRICT</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 建表后创建外键</span><br><span class="line"></span><br><span class="line">alter table表名称 add 【constraint 约束名】 foreign key (从表字段名) references 主表名(主表被参照字段名);</span><br><span class="line">ALTER TABLE t_emp ADD CONSTRAINT fk_emp_dept_did FOREIGN KEY(dept_id) REFERENCES t_department(did)  ON UPDATE CASCADE ON DELETE RESTRICT;</span><br><span class="line">#其中CONSTRAINT fk_emp_dept_did可以省略</span><br><span class="line">#ON UPDATE CASCADE ON DELETE RESTRICT如果省略表示都是RESTRICT</span><br></pre></td></tr></table></figure><p>如何删除外键约束？</p><ul><li><p>ALTER TABLE 表名称 DROP FOREIGN KEY 外键约束名;</p><p>ALTER TABLE t_emp DROP FOREIGN KEY fk_emp_dept_did;</p></li></ul><p>查看约束名</p><ul><li>SELECT * FROM information_schema.table_constraints WHERE table_name = ‘表名称’;</li></ul><p>如何删除外键列上的索引？需要单独删除</p><ul><li><p>ALTER TABLE 表名称 DROP INDEX 外键列索引名; </p><p>ALTER TABLE t_emp DROP INDEX dept_id;</p></li></ul><p>查看索引名</p><ul><li>show index from 表名称;</li></ul><h4 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h4><ul><li>NOT NULL 非空约束，规定某个字段不能为空</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t_stu(</span><br><span class="line">sid INT PRIMARY KEY,</span><br><span class="line">sname VARCHAR(100) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果某列已经创建好，那么可以修改列语句修改：</p><p>例如：原来非空，修改为允许空</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE ceshi_table MODIFY des VARCHAR(20);</span><br></pre></td></tr></table></figure><p>例如：原来允许空，修改为非空</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE ceshi_table MODIFY des VARCHAR(20) NOT NULL;</span><br></pre></td></tr></table></figure><h4 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h4><p>注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果；</p><p>例如：age tinyint check(age &gt;20)  或 sex char(2) check(sex in(‘男’,’女’))</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t_stu(</span><br><span class="line">sid INT PRIMARY KEY,</span><br><span class="line">sname VARCHAR(100) NOT NULL,</span><br><span class="line">gender CHAR NOT NULL CHECK(gender IN(&#39;男&#39;,&#39;女&#39;))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="Default缺省约束"><a href="#Default缺省约束" class="headerlink" title="Default缺省约束"></a>Default缺省约束</h4><p>default：默认值，在插入数据时某列如果没指定其他的值,那么会将默认值添加到新记录。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t_stu(</span><br><span class="line">sid INT PRIMARY KEY,</span><br><span class="line">sname VARCHAR(100) NOT NULL,</span><br><span class="line">gender CHAR NOT NULL CHECK(gender IN(&#39;男&#39;,&#39;女&#39;))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果某列已经创建好，那么可以修改列语句修改：</p><p>例如：原来有默认值，去除默认值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE ceshi_table MODIFY des VARCHAR(20);</span><br></pre></td></tr></table></figure><p>例如：原来没有默认值，增加默认值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE ceshi_table MODIFY des VARCHAR(20) DEFAULT &#39;略&#39;;</span><br></pre></td></tr></table></figure><h3 id="索引：INDEX"><a href="#索引：INDEX" class="headerlink" title="索引：INDEX"></a>索引：INDEX</h3><p><strong>索引</strong>：索引是对数据库表中一列或多列的值进行排序的一种结构。<strong>索引是一个单独的、物理的数据库结构</strong>，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。由此可知，<strong>索引是要消耗数据库空间的</strong>。而<strong>约束是一种逻辑概念。</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql25.png" alt="mysql"></p><p>例如：一本字典，如何快速找到某个字，可以给字典加目录，对数据库来说,索引的作用即是给”数据”加目录。</p><p>设有N条随机记录,不用索引,平均查找N/2次,那么用了索引之后呢。如果是btree(二叉树)索引，如果是hash(哈希)索引，时间复杂度是1。</p><p><strong>索引好处</strong>：加快了查询速度(select )</p><p><strong>索引坏处</strong>：降低了增,删,改的速度(update/delete/insert)，增大了表的文件大小(索引文件甚至可能比数据文件还大)</p><p><strong>MySQL提供多种索引类型供选择：</strong></p><ul><li><p>普通索引：</p></li><li><p>唯一性索引：</p></li><li><p>主键索引：只有一个主键索引</p></li><li><p>全文索引：MySQL5.X版本只有MyISAM存储引擎支持FULLTEXT，并且只限于CHAR、VARCHAR和TEXT类型的列上创建。</p></li></ul><p><strong>MySQL的索引方法：</strong></p><ul><li><p>HASH</p></li><li><p>BTREE</p></li></ul><p>MySQL中多数索引都以BTREE的形式保存。</p><p><strong>索引的使用原则：</strong></p><ol><li><p>不过度索引</p></li><li><p>索引条件列(where后面最频繁的条件比较适宜索引)</p></li><li><p>索引散列值,过于集中的值不要索引，例如:给性别”男”,”女”加索引,意义不大</p></li></ol><ul><li><p>CREATE INDEX 索引名 ON 表名称 (column_name,[column_name…]);      最左边的列最关键</p></li><li><p>alter table 表名称 drop index 索引名;</p></li></ul><h3 id="自增列：AUTO-INCREMENT"><a href="#自增列：AUTO-INCREMENT" class="headerlink" title="自增列：AUTO_INCREMENT"></a>自增列：AUTO_INCREMENT</h3><p>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t_stu(</span><br><span class="line">sid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">sname VARCHAR(100) NOT NULL,</span><br><span class="line">gender CHAR NOT NULL DEFAULT &#39;男&#39;,</span><br><span class="line">birthday DATE,</span><br><span class="line">address VARCHAR(200)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>auto_increment    自增长</li></ul><ol><li><p>整数类型的字段才可以设置自增长。</p></li><li><p>当需要产生唯一标识符或顺序值时，可设置自增长。</p></li><li><p>一个表最多只能有一个自增长列</p></li><li><p>自增长列必须非空</p></li><li><p>自增长列必须是主键列或唯一键列。</p></li><li><p>InnoDB表的自动增长列可以手动插入，但是插入的值如果是空或者0，则实际插入的将是自动增长后的值。</p></li></ol><h1 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h1><p>数据操作语言（DML）DML用于插入、修改、删除数据记录，包括如下SQL语句：</p><p>INSERT：添加数据到数据库中</p><p>UPDATE：修改数据库中的数据</p><p>DELETE：删除数据库中的数据</p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql26.png" alt="mysql"></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li>INSERT INTO 表名称  VALUES(值1，值2，……);</li><li>INSERT INTO 表名称  VALUES(值1，值2，……),(值1，值2，……),…;</li><li>INSERT INTO 表名称 (字段1，字段2，……) VALUES(值1，值2，……);</li><li>INSERT INTO 表名称 (字段1，字段2，……) VALUES(值1，值2，……),(值1，值2，……),…..;</li></ul><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li>值列表(值1，值2，……)的顺序、个数与字段列表(字段1，字段2，……) 中字段的顺序、个数一致</li></ol><ul><li><p>如果个数少了就报Column count doesn’t match value count</p></li><li><p>如果VALUES前面的()中没有列出字段，那么默认就是为表中的所有字段赋值，那么个数与顺序与表结构中字段定义的一致</p></li></ul><ol start="2"><li>关于自增长列、默认值列、允许为NULL列的赋值</li></ol><ul><li>如果字段列表列出了字段名，那么值列表中就要为其赋值，哪怕它是自增长列，有默认值列，可以为NULL值的列。<ul><li>InnoDB表的自动增长列可以手动插入合适的值，但是插入的值如果是NULL或者0，则实际插入的将是自动增长后的值；</li><li>如果列声明了“默认约束”那么对应的位置可以赋值具体的值，也可以使用“DEFAULT”，表示使用默认值；</li><li>如果列允许了NULL值，那么可以为对应的字段可以赋值为具体值也可以赋值为NULL</li></ul></li><li>对于没有列出的字段，像自增列就自动赋值，像默认值列就自动赋默认值，像允许NULL的列就自动赋NULL值，但是非空列又没有提供默认值会自动赋值为对应数据类型的默认值，例如字符串赋值为空字符串，int赋值为0；</li><li>VALUES也可以写成VALUE，但是VALUES是标准写法</li><li>可以同时插入多行</li><li>如果插入从表的数据，要注意查看主表参照字段的值是否存在</li><li>值的位置可以是常量值、表达式、函数</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>练习（一）</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql27.png" alt="mysql"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t_stu(</span><br><span class="line">sid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">sname VARCHAR(100) NOT NULL,</span><br><span class="line">gender CHAR NOT NULL DEFAULT &#39;男&#39;,</span><br><span class="line">card_id CHAR(18) NOT NULL UNIQUE,</span><br><span class="line">birthday DATE,</span><br><span class="line">address VARCHAR(200)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO t_stu VALUES(1,&#39;张三&#39;,DEFAULT,&#39;123456789012345678&#39;,&#39;1989-09-09&#39;,NULL);</span><br><span class="line">INSERT INTO t_stu VALUES(2,&#39;李四&#39;,&#39;女&#39;,&#39;123456789012345677&#39;,&#39;1988-09-09&#39;,&#39;北京&#39;);</span><br><span class="line">INSERT INTO t_stu VALUES(0,&#39;王五&#39;,&#39;男&#39;,&#39;123456789012345676&#39;,&#39;1987-09-09&#39;,&#39;北京&#39;);</span><br><span class="line">INSERT INTO t_stu VALUES(NULL,&#39;赵六&#39;,&#39;男&#39;,&#39;123456789012345675&#39;,&#39;1987-09-09&#39;,&#39;北京&#39;);</span><br><span class="line"></span><br><span class="line">INSERT INTO t_stu VALUES</span><br><span class="line">(NULL,&#39;冰冰&#39;,&#39;女&#39;,&#39;123456789012345674&#39;,&#39;1988-09-09&#39;,&#39;尚硅谷&#39;),</span><br><span class="line">(NULL,&#39;小丽&#39;,&#39;女&#39;,&#39;123456789012345673&#39;,&#39;1988-09-09&#39;,&#39;尚硅谷&#39;);</span><br><span class="line"></span><br><span class="line">INSERT INTO t_stu (sname,card_id,birthday)</span><br><span class="line">VALUES(&#39;小薇&#39;,&#39;123456199012045672&#39;,STR_TO_DATE(SUBSTRING(card_id,7,8),&#39;%Y%m%d&#39;));</span><br><span class="line"></span><br><span class="line">INSERT INTO t_stu (sname,card_id,birthday)VALUES</span><br><span class="line">(&#39;小红&#39;,&#39;123456789012345671&#39;,&#39;1990-09-09&#39;),</span><br><span class="line">(&#39;小紫&#39;,&#39;123456789012345670&#39;,&#39;1990-09-09&#39;);</span><br></pre></td></tr></table></figure><p>练习（二）</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql28.png" alt="mysql"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t_department(</span><br><span class="line">did INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">dname VARCHAR(100) NOT NULL,</span><br><span class="line">description VARCHAR(200),</span><br><span class="line">manager_id INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO t_department(dname,description) VALUES(&#39;教学部&#39;,&#39;技术培训&#39;),(&#39;咨询部&#39;,&#39;课程咨询服务&#39;);</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;t_job&#96; (</span><br><span class="line">  &#96;job_id&#96; INT(11) PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  &#96;job_name&#96; VARCHAR(100) DEFAULT NULL,</span><br><span class="line">  &#96;description&#96; VARCHAR(200) DEFAULT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO t_job VALUES</span><br><span class="line">(NULL,&#39;JavaSE讲师&#39;,&#39;Java基础&#39;),</span><br><span class="line">(NULL,&#39;Web讲师&#39;,&#39;Web基础&#39;),</span><br><span class="line">(NULL,&#39;JavaEE框架&#39;,&#39;框架讲解&#39;),</span><br><span class="line">(NULL,&#39;课程顾问&#39;,&#39;课程咨询&#39;);</span><br><span class="line"></span><br><span class="line">CREATE TABLE t_employee(</span><br><span class="line">eid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">ename VARCHAR(100) NOT NULL,</span><br><span class="line">gender CHAR NOT NULL DEFAULT &#39;男&#39;,</span><br><span class="line">card_id CHAR(18) UNIQUE,</span><br><span class="line">tel CHAR(11),</span><br><span class="line">job_id INT,</span><br><span class="line">&#96;mid&#96; INT,</span><br><span class="line">birthday DATE,</span><br><span class="line">hiredate DATE,</span><br><span class="line">address VARCHAR(100),</span><br><span class="line">dept_id INT,</span><br><span class="line">FOREIGN KEY (dept_id) REFERENCES t_department(did),</span><br><span class="line">FOREIGN KEY (job_id) REFERENCES t_job(job_id)</span><br><span class="line">);</span><br><span class="line">INSERT  INTO &#96;t_employee&#96;(&#96;eid&#96;,&#96;ename&#96;,&#96;gender&#96;,&#96;card_id&#96;,&#96;tel&#96;,&#96;job_id&#96;,&#96;mid&#96;,&#96;birthday&#96;,&#96;hiredate&#96;,&#96;address&#96;,&#96;dept_id&#96;)</span><br><span class="line"> VALUES (1,&#39;孙红雷&#39;,&#39;男&#39;,&#39;123456789012345678&#39;,&#39;12345678901&#39;,1,NULL,&#39;1990-01-01&#39;,&#39;2015-01-01&#39;,&#39;白庙&#39;,1),</span><br><span class="line"> (2,&#39;张亮&#39;,&#39;男&#39;,&#39;123456789012345677&#39;,&#39;12345678902&#39;,2,NULL,&#39;1990-01-02&#39;,&#39;2015-01-02&#39;,&#39;天通苑北&#39;,1),</span><br><span class="line"> (3,&#39;鹿晗&#39;,&#39;男&#39;,&#39;123456789012345676&#39;,&#39;12345678903&#39;,3,NULL,&#39;1990-01-03&#39;,&#39;2015-01-03&#39;,&#39;北苑&#39;,1),</span><br><span class="line"> (4,&#39;邓超&#39;,&#39;男&#39;,&#39;123456789012345675&#39;,&#39;12345678904&#39;,2,NULL,&#39;1990-01-04&#39;,&#39;2015-01-04&#39;,&#39;和谐家园&#39;,1),</span><br><span class="line"> (5,&#39;孙俪&#39;,&#39;女&#39;,&#39;123456789012345674&#39;,&#39;12345678905&#39;,3,NULL,&#39;1990-01-05&#39;,&#39;2015-01-05&#39;,&#39;霍营&#39;,1),</span><br><span class="line"> (6,&#39;Angelababy&#39;,&#39;女&#39;,&#39;123456789012345673&#39;,&#39;12345678906&#39;,4,NULL,&#39;1990-01-06&#39;,&#39;2015-01-06&#39;,&#39;回龙观&#39;,2);</span><br><span class="line"> </span><br><span class="line"> CREATE TABLE t_salary(</span><br><span class="line">eid INT PRIMARY KEY,</span><br><span class="line">basic_salary DECIMAL(10,2),</span><br><span class="line">performance_salary DECIMAL(10,2),</span><br><span class="line">commission_pct DECIMAL(10,2),</span><br><span class="line">deduct_wages DECIMAL(10,2),</span><br><span class="line">FOREIGN KEY (eid) REFERENCES t_employee(eid)</span><br><span class="line">);</span><br><span class="line">INSERT  INTO &#96;t_salary&#96;(&#96;eid&#96;,&#96;basic_salary&#96;,&#96;performance_salary&#96;,&#96;commission_pct&#96;,&#96;deduct_wages&#96;) </span><br><span class="line">VALUES (1,&#39;12000.00&#39;,&#39;6000.00&#39;,&#39;0.40&#39;,&#39;0.00&#39;),</span><br><span class="line">(2,&#39;9000.00&#39;,&#39;5000.00&#39;,&#39;0.20&#39;,NULL),</span><br><span class="line">(3,&#39;11000.00&#39;,&#39;8000.00&#39;,NULL,NULL),</span><br><span class="line">(4,&#39;13000.00&#39;,&#39;5000.00&#39;,NULL,NULL),</span><br><span class="line">(5,&#39;8000.00&#39;,&#39;8000.00&#39;,&#39;0.30&#39;,NULL),</span><br><span class="line">(6,&#39;15000.00&#39;,&#39;6000.00&#39;,NULL,NULL);</span><br></pre></td></tr></table></figure><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a><strong>修改数据</strong></h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql29.png" alt="mysql"></p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><ul><li>UPDATE 表名称 SET 字段名1 = 值1, 字段名2=值2,……  【WHERE  条件】; </li><li>UPDATE 表1，表2,……  SET  表1.字段名1 = 值1, 表1.字段名2=值2,表2.字段1 = 值1, 表2.字段2=值2……  【WHERE  条件】; </li></ul><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><ol><li><p>如果不写where条件，会修改所有行</p></li><li><p>值可以是常量值、表达式、函数</p></li><li><p>可以同时更新多张表</p><p>如果两个表没有建立外键，但逻辑上有外键关系</p></li><li><p>如果修改从表外键字段的数据，要注意查看主表参照字段的值是否存在</p></li><li><p>如果修改主表的被参考的字段的值，要注意查看从表的外键是否有依赖该值，如果有</p><ul><li>如果外键是on update RESTRICT或on update NO ACTION，那么要先处理从表的数据，才能修改</li><li>如果外键是on update SET NULL 或 on update CASCADE，那么直接修改，从表的外键字段会自动处理</li></ul></li></ol><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#修改所有人的基本工资，涨薪5%</span><br><span class="line">UPDATE t_salary </span><br><span class="line">SET basic_salary &#x3D; basic_salary * 1.05;</span><br><span class="line"></span><br><span class="line">#修改&quot;孙俪&quot;的手机号码为&quot;13709098765&quot;，生日为&quot;1982-09-26&quot;</span><br><span class="line">UPDATE t_employee SET tel &#x3D; &#39;13709098765&#39;,birthday &#x3D; &#39;1982-09-26&#39;</span><br><span class="line">WHERE ename &#x3D; &#39;孙俪&#39;;</span><br><span class="line"></span><br><span class="line">#修改&quot;邓超&quot;的入职日期为今天</span><br><span class="line">UPDATE t_employee SET hiredate &#x3D; CURDATE() WHERE ename &#x3D;&#39;邓超&#39;;</span><br><span class="line"></span><br><span class="line">#修改&quot;咨询部&quot;的主管id为6</span><br><span class="line">UPDATE t_department SET manager_id &#x3D;6 WHERE did &#x3D; 2;</span><br><span class="line"></span><br><span class="line">#修改&quot;教学部&quot;的主管id为1</span><br><span class="line">UPDATE t_department SET manager_id &#x3D;1 WHERE did &#x3D; 1;</span><br><span class="line"></span><br><span class="line">#修改&quot;教学部&quot;的主管id为&quot;孙红雷&quot;的编号</span><br><span class="line">UPDATE t_department,t_employee</span><br><span class="line">SET t_department.manager_id &#x3D;t_employee.eid</span><br><span class="line">WHERE t_department.&#96;dname&#96; &#x3D; &#39;教学部&#39; </span><br><span class="line"> AND t_department.&#96;did&#96; &#x3D; t_employee.&#96;dept_id&#96; </span><br><span class="line"> AND t_employee.ename &#x3D; &#39;孙红雷&#39;;</span><br><span class="line"></span><br><span class="line">#修改所有员工的领导编号为该员工所在部门的主管编号</span><br><span class="line">UPDATE t_employee,t_department </span><br><span class="line">SET t_employee.mid &#x3D; t_department.manager_id</span><br><span class="line">WHERE t_employee.dept_id &#x3D; t_department.did;</span><br><span class="line"></span><br><span class="line">#修改教学部的主管编号，以及该部门所有员工的领导编号为&quot;邓超&quot;的编号</span><br><span class="line">UPDATE t_department,t_employee</span><br><span class="line">SET t_department.manager_id &#x3D;t_employee.eid</span><br><span class="line">WHERE t_department.&#96;dname&#96; &#x3D; &#39;教学部&#39; </span><br><span class="line"> AND t_department.&#96;did&#96; &#x3D; t_employee.&#96;dept_id&#96; </span><br><span class="line"> AND t_employee.ename &#x3D; &#39;邓超&#39;;</span><br><span class="line"> </span><br><span class="line">UPDATE t_employee,t_department </span><br><span class="line">SET t_employee.mid &#x3D; t_department.manager_id</span><br><span class="line">WHERE t_employee.dept_id &#x3D; t_department.did</span><br><span class="line"> AND t_department.&#96;dname&#96; &#x3D; &#39;教学部&#39;;</span><br></pre></td></tr></table></figure><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql30.png" alt="mysql"></p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><ul><li>delete from 表名 【where 条件】;</li><li>delete 表1，表2,…….  from 表1，表2，……  【where 条件】;</li></ul><h3 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h3><ol><li><p>如果不加where条件，表示删除整张表的数据，表结构保留。</p><p>delete from 表名;</p><p>删除整张表的数据还可以使用 truncate 表名;</p></li></ol><p>   区别：</p><p>   truncate相当于删除表再重建一张同名结构的表，操作后得到一张全新表，而delete是在原有表中删除数据。如果决定清空一张表的数据，truncate速度更快一些。</p><p>   TRUNCATE语句不能回滚</p><ol start="2"><li><p>如果删除主表的记录，要注意查看从表的外键是否有依赖该行的值，如果有</p><ul><li>如果外键是on delete RESTRICT或on delete NO ACTION，那么要先处理从表的数据，才能删除</li><li>如果外键是on delete SET NULL 或 on delete CASCADE，那么删除时从表的对应记录也会被置空或跟着删除</li></ul></li><li><p>可以一次删除多个表的数据</p><p>例如：两个表没有建立外键，但逻辑上有外键关系，也可以通过删除多个表的数据来实现级联删除</p></li></ol><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#删除学号为9的学生信息</span><br><span class="line">DELETE FROM t_stu WHERE sid &#x3D; 9;</span><br><span class="line"></span><br><span class="line">#注意：前提是没有外键或外键是on delete cascade</span><br><span class="line">#删除所有“教学部”的员工信息和薪资信息和“教学部”部门信息</span><br><span class="line">DELETE t_employee,t_department,t_salary</span><br><span class="line">FROM t_employee,t_department,t_salary</span><br><span class="line">WHERE t_department.&#96;dname&#96; &#x3D;&#39;教学部&#39; </span><br><span class="line"> AND t_employee.&#96;dept_id&#96;&#x3D;t_department.&#96;did&#96;</span><br><span class="line"> AND t_employee.&#96;eid&#96; &#x3D; t_salary.eid;</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql31.png" alt="mysql"></p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT 查询列表</span><br><span class="line">  FROM 表名或视图列表</span><br><span class="line">  【WHERE 条件表达式】</span><br><span class="line">  【GROUP BY 字段名 【HAVING 条件表达式】】</span><br><span class="line">  【ORDER BY 字段 【ASC|DESC】】</span><br><span class="line">  【LIMIT m,n】;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询表中的所有行所有列</span><br><span class="line">#使用*表示，查询所有字段，即查询所有行</span><br><span class="line">select * from t_stu;</span><br><span class="line"></span><br><span class="line">#查询部分字段，查询部分列</span><br><span class="line">select sname,major from t_stu;</span><br><span class="line"></span><br><span class="line">#查询所有列，部分行</span><br><span class="line">select * from t_stu where major &#x3D; &#39;JavaEE&#39;;</span><br><span class="line"></span><br><span class="line">#查询部分行，部分列</span><br><span class="line">select sname,major from t_stu where major &#x3D; &#39;JavaEE&#39;;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li><p>如果SELECT后面是*，那么表示查询所有字段</p></li><li><p>SELECT后面的查询列表，可以是表中的字段，常量值，表达式，函数</p></li><li><p>查询的结果是一个虚拟的表</p></li><li><p>select语句，可以包含5种子句：依次是where、 group by、having、 order by、limit必须照这个顺序。</p></li></ol><h3 id="别名AS"><a href="#别名AS" class="headerlink" title="别名AS"></a><strong>别名AS</strong></h3><p>语法：AS 别名</p><p>说明：</p><ol><li><p>可以给字段取别名、可以给表名取别名</p></li><li><p>AS 可以省略</p></li><li><p>如果给字段取别名，如果别名中包含特殊符号，例如“空格”等，建议给别名加上双引号或单引号</p></li><li><p>如果是给表名取别名，那么不能加双引号或单引号，也不能有特殊符号，例如“空格”等</p></li><li><p>建议别名简短，见名知意</p></li></ol><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE t_department AS d,t_employee AS e</span><br><span class="line">SET d.manager_id &#x3D;e.eid</span><br><span class="line">WHERE d.dname &#x3D; &#39;教学部&#39; </span><br><span class="line"> AND d.did &#x3D; e.&#96;dept_id&#96; </span><br><span class="line"> AND e.ename &#x3D; &#39;孙红雷&#39;;</span><br><span class="line"> </span><br><span class="line">#查询员工姓名以及手机号码</span><br><span class="line">SELECT ename AS &#39;员工姓名&#39;,tel AS &#39;手机号码&#39;</span><br><span class="line">FROM t_employee;</span><br></pre></td></tr></table></figure><h3 id="去重DISTINCT"><a href="#去重DISTINCT" class="headerlink" title="去重DISTINCT"></a>去重DISTINCT</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查询员工表的部门编号</span><br><span class="line">SELECT DISTINCT dept_id FROM t_employee;</span><br><span class="line"></span><br><span class="line">#统计员工表中员工有几个部门</span><br><span class="line">SELECT COUNT(DISTINCT dept_id) FROM t_employee;</span><br></pre></td></tr></table></figure><h3 id="着重号"><a href="#着重号" class="headerlink" title="`着重号`"></a>`着重号`</h3><p>例如：select `name` from t_stu;</p><p>可以给字段或表名加着重号</p><p>如果字段名或表名与关键字一样更要加着重号了</p><h1 id="MySQL的运算符"><a href="#MySQL的运算符" class="headerlink" title="MySQL的运算符"></a>MySQL的运算符</h1><ol><li><p>算术运算符：+  -  *  /（除也可以写成div，div取整)  %（取模可以写成mod）</p></li><li><p>比较运算符：=  &gt;  &gt;=  &lt;  &lt;=  !=（不等于还可以写成&lt;&gt;） &lt;=&gt;（安全等于，用于判断null值）</p></li><li><p>逻辑运算符：&amp;&amp;（逻辑与也可以写成and） ||（逻辑或也可以写成or） not（逻辑非） xor（逻辑异或）</p></li><li><p>范围：表达式 between … and … （也可以写成 表达式&gt;=…  and 表达式 &lt;=…）</p><p>​            表达式 not between … and …（也可以写成 表达式&lt;…  || 表达式 &gt;…）</p></li><li><p>集合：in (值，值，值…)  not in(值，值，值…) </p></li><li><p>模糊查询：LIKE，  NOT  LIKE，通配符：%表示0-n个字符，_下划线代表一个字符</p></li><li><p>位运算符：&amp;（按位与） |（按位或）^（按位异或）~（按位取反）&gt;&gt;（右移）&lt;&lt;（左移）</p></li><li><p>NULL值判断，is null 或 is not null，如果使用null=null，null&lt;&gt;null,null=0,null&lt;&gt;0,null=false等都不对</p><p>不过xxx is null 可以使用xxx &lt;=&gt; null ，xxx  is not null 可以写成 not xxx &lt;=&gt; null</p><p>结论：所有的运算符遇到NULL结果都是NULL，除了&lt;=&gt;</p></li></ol><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一、算术运算符</span><br><span class="line">#+,-,*,&#x2F;(div),%(mod)</span><br><span class="line">#筛选出eid是偶数的员工</span><br><span class="line">SELECT * FROM t_employee WHERE eid % 2 &#x3D; 0; </span><br><span class="line">SELECT * FROM t_employee WHERE eid MOD 2 &#x3D; 0; </span><br><span class="line"></span><br><span class="line">#查看每天的基本工资值，每个月按22天算</span><br><span class="line">SELECT eid,basic_salary&#x2F;12 AS &quot;日薪&quot;</span><br><span class="line">FROM t_salary;</span><br><span class="line"></span><br><span class="line">#div也表示除，但是只保留整数部分</span><br><span class="line">SELECT eid,basic_salary DIV 12 AS &quot;日薪&quot;</span><br><span class="line">FROM t_salary;</span><br><span class="line"></span><br><span class="line">#关于+，在Java中，+的左右两边如果有字符串，那么表示字符串的拼接,但是在MySQL中+只表示数值相加，</span><br><span class="line">#如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算</span><br><span class="line">SELECT eid+ename FROM t_employee;</span><br><span class="line">SELECT eid+birthday FROM t_employee;</span><br><span class="line"></span><br><span class="line">#MySQL中字符串拼接要使用字符串函数实现</span><br><span class="line">SELECT CONCAT(eid,&quot;:&quot;,ename) AS result FROM t_employee;</span><br></pre></td></tr></table></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#二、比较运算符</span><br><span class="line">#&#x3D;，&gt;, &lt;，&gt;&#x3D;, &lt;&#x3D;， !&#x3D;(不等于&lt;&gt;)，&lt;&#x3D;&gt;（安全等于）</span><br><span class="line">#查询basic_salary!&#x3D;10000</span><br><span class="line">SELECT eid,basic_salary FROM t_salary WHERE basic_salary !&#x3D; 10000;</span><br><span class="line">SELECT eid,basic_salary FROM t_salary WHERE basic_salary &lt;&gt; 10000;</span><br><span class="line"></span><br><span class="line">#查询basic_salary&#x3D;10000，注意在Java中比较是&#x3D;&#x3D;</span><br><span class="line">SELECT eid,basic_salary FROM t_salary WHERE basic_salary &#x3D; 10000;</span><br><span class="line"></span><br><span class="line">#查询commission_pct等于0.40</span><br><span class="line">SELECT eid,commission_pct FROM t_salary WHERE commission_pct &#x3D; 0.40;</span><br><span class="line">SELECT eid,commission_pct FROM t_salary WHERE commission_pct &lt;&#x3D;&gt; 0.40;</span><br><span class="line"></span><br><span class="line">#查询commission_pct等于NULL</span><br><span class="line">SELECT eid,commission_pct FROM t_salary WHERE commission_pct IS NULL;</span><br><span class="line">SELECT eid,commission_pct FROM t_salary WHERE commission_pct &lt;&#x3D;&gt; NULL;</span><br><span class="line"></span><br><span class="line">#查询commission_pct不等于NULL</span><br><span class="line">SELECT eid,commission_pct FROM t_salary WHERE commission_pct IS NOT NULL;</span><br><span class="line">SELECT eid,commission_pct FROM t_salary WHERE NOT commission_pct &lt;&#x3D;&gt; NULL;</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#三、逻辑运算符</span><br><span class="line">#与&amp;&amp;，或||，非!</span><br><span class="line">#与 AND，或 OR ，非 NOT，异或 XOR</span><br><span class="line"></span><br><span class="line">#查询性别男，并且在90以前出生的员工</span><br><span class="line">SELECT * FROM t_employee WHERE gender&#x3D;&#39;男&#39; AND birthday&lt;&#39;1990-01-01&#39;; </span><br><span class="line"></span><br><span class="line">#查询职位编号job_id是1或2的员工</span><br><span class="line">SELECT * FROM t_employee WHERE job_id &#x3D;1 OR job_id &#x3D; 2;</span><br><span class="line"></span><br><span class="line">#查询基本薪资是在9000-12000之间的员工编号和基本薪资</span><br><span class="line">SELECT eid,basic_salary FROM t_salary WHERE basic_salary &gt;&#x3D;9000 AND basic_salary&lt;&#x3D;12000;</span><br><span class="line"></span><br><span class="line">#查询基本薪资不在9000-12000之间的员工编号和基本薪资</span><br><span class="line">SELECT eid,basic_salary FROM t_salary WHERE NOT (basic_salary &gt;&#x3D;9000 AND basic_salary&lt;&#x3D;12000);</span><br><span class="line">SELECT eid,basic_salary FROM t_salary WHERE basic_salary &lt;9000 OR basic_salary&gt;12000;</span><br></pre></td></tr></table></figure><h2 id="范围和集合"><a href="#范围和集合" class="headerlink" title="范围和集合"></a>范围和集合</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#四、表示区间范围和集合范围</span><br><span class="line">#between ... and ... 和 not between ... and ... </span><br><span class="line">#in(集合)  和 not in(...)</span><br><span class="line"></span><br><span class="line">#查询基本薪资是在9000-12000之间的员工编号和基本薪资</span><br><span class="line">SELECT eid,basic_salary FROM t_salary WHERE basic_salary BETWEEN 9000 AND 12000;</span><br><span class="line"></span><br><span class="line">#查询eid是1,3,5的基本工资</span><br><span class="line">SELECT eid,basic_salary FROM t_salary WHERE eid IN (1,3,5);</span><br></pre></td></tr></table></figure><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#五、模糊查询</span><br><span class="line">#like 和 通配符 一起使用</span><br><span class="line">#like _ 匹配单个字符</span><br><span class="line">#like % 匹配任意个字符</span><br><span class="line"></span><br><span class="line">#查询名字中有&#39;冰&#39;字的员工信息</span><br><span class="line">SELECT * FROM t_employee WHERE ename LIKE &#39;%冰%&#39;;</span><br><span class="line"></span><br><span class="line">#查询姓李的员工信息</span><br><span class="line">SELECT * FROM t_employee WHERE ename LIKE &#39;李%&#39;;</span><br><span class="line"></span><br><span class="line">#查询姓李，名字就一个字的员工信息</span><br><span class="line">SELECT * FROM t_employee WHERE ename LIKE &#39;李_&#39;;</span><br><span class="line"></span><br><span class="line">#查询李冰冰的信息</span><br><span class="line">SELECT * FROM t_employee WHERE ename LIKE &#39;李冰冰&#39;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通常情况，可以使用FIND_IN_SET()函数或LIKE操作符搜索SET值：</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM tbl_name WHERE FIND_IN_SET(&#39;value&#39;,set_col)&gt;0;</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM tbl_name WHERE set_col LIKE &#39;%value%&#39;;</span><br><span class="line"></span><br><span class="line">第1个语句找出SET_col包含value set成员的行。第2个类似，但有所不同：它在其它地方找出set_col包含value的行，甚至是在另一个SET成员的子字符串中。</span><br><span class="line"></span><br><span class="line">下面的语句也是合法的：</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM tbl_name WHERE set_col &amp; 1;</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM tbl_name WHERE set_col &#x3D; &#39;val1,val2&#39;;</span><br><span class="line"></span><br><span class="line">第1个语句寻找包含第1个set成员的值。第2个语句寻找一个确切匹配的值。应注意第2类的比较。将set值与&#39;val1,val2&#39;比较返回的结果与同&#39;val2,val1&#39;比较返回的结果不同。指定值时的顺序应与在列定义中所列的顺序相同。</span><br><span class="line"></span><br><span class="line">如果想要为SET列确定所有可能的值，使用SHOW COLUMNS FROM tbl_name LIKE set_col并解析输出中第2列的SET定义。</span><br><span class="line">有什么实际应用呢？</span><br><span class="line"></span><br><span class="line">比如我们设定用户的权限控制，一个用户可能会有多种权限，我们使用所有权限创建一个SET类型的字段，我们不需要用一系列int来定义各种权限了，直接使用一个SET字段即可：</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">用户权限permission表</span><br><span class="line">*&#x2F;</span><br><span class="line">create table user_permission(</span><br><span class="line">id int UNSIGNED not null auto_increment,</span><br><span class="line">user_id int not null ,</span><br><span class="line">permission set(&#39;阅读&#39;,&#39;评论&#39;,&#39;发帖&#39;) not null,</span><br><span class="line">primary key(id),</span><br><span class="line">unique (user_id)</span><br><span class="line">);</span><br><span class="line">desc user_permission;</span><br><span class="line">insert into user_permission values (0,1,&#39;阅读&#39;),(0,2,&#39;阅读&#39;),(0,3,&#39;阅读,评论&#39;);</span><br><span class="line">insert into user_permission values (0,4,&#39;阅读,评论,发帖&#39;);</span><br><span class="line">select *,permission+0 from user_permission;</span><br><span class="line">select permission from user_permission where user_id&#x3D;1;</span><br><span class="line">select * from user_permission where permission &amp; 10;</span><br><span class="line">SELECT * FROM user_permission WHERE FIND_IN_SET(&#39;评论&#39;,permission)&gt;0;</span><br></pre></td></tr></table></figure><h2 id="NULL值判断与计算处理"><a href="#NULL值判断与计算处理" class="headerlink" title="NULL值判断与计算处理"></a>NULL值判断与计算处理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#NULL值判断与处理</span><br><span class="line">#查询奖金百分比不为空的员工编号</span><br><span class="line">SELECT eid,commission_pct FROM t_salary WHERE commission_pct IS NOT NULL;</span><br><span class="line"></span><br><span class="line">#查询奖金百分比为空的员工编号</span><br><span class="line">SELECT eid,commission_pct FROM t_salary WHERE commission_pct IS NULL;</span><br><span class="line"></span><br><span class="line">#关于null值计算</span><br><span class="line">#所有运算符遇到null都是null</span><br><span class="line"></span><br><span class="line">#计算实际的薪资：  basic_salary + salary * 奖金百分比</span><br><span class="line">#函数：IFNULL(表达式,用什么值代替)</span><br><span class="line">SELECT eid,basic_salary + performance_salary *(1+ commission_pct) FROM t_salary;#错误的</span><br><span class="line">SELECT eid,basic_salary + performance_salary *(1+ IFNULL(commission_pct,0)) FROM t_salary;</span><br><span class="line"></span><br><span class="line">#&lt;&#x3D;&gt;安全等于</span><br><span class="line">#查询奖金百分比为空的员工编号</span><br><span class="line">SELECT eid,commission_pct FROM t_salary WHERE commission_pct &lt;&#x3D;&gt; NULL;</span><br></pre></td></tr></table></figure><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#七、位运算符</span><br><span class="line">#&gt;&gt; &lt;&lt; &amp; | ~  ^（异或）</span><br><span class="line">SELECT 2^3,2&amp;3,2|3,2&gt;&gt;3,2&lt;&lt;3,~3;</span><br></pre></td></tr></table></figure><h1 id="关联查询，联合查询"><a href="#关联查询，联合查询" class="headerlink" title="关联查询，联合查询"></a>关联查询，联合查询</h1><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql32.png" alt="mysql"></p><p>作用:从2张或多张表中,取出有关联的数据.</p><p>关联查询一共有几种情况：</p><ul><li>内连接：INNER JOIN 、CROSS JOIN</li><li>外连接：左外连接（LEFT OUTER JOIN）、右外连接（RIGHT OUTER JOIN）、全外连接（FULL OUTER JOIN）</li><li>自连接：当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义</li></ul><p>说明：</p><ol><li><p>连接 n个表,至少需要 n-1个连接条件。 例如：连接三个表，至少需要两个连接条件。</p></li><li><p>当两个关联查询的表如果有字段名字相同，并且要查询中涉及该关联字段，那么需要使用表名前缀加以区分</p></li><li><p>当如果表名比较长时，可以给表取别名，简化SQL语句</p></li></ol><p>关联条件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT t_employee.eid,ename,basic_salary</span><br><span class="line">FROM t_employee, t_salary</span><br><span class="line">WHERE t_employee.eid &#x3D; t_salary.eid;</span><br></pre></td></tr></table></figure><p>表名前缀</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT t_employee.eid,ename,basic_salary</span><br><span class="line">FROM t_employee, t_salary</span><br><span class="line">WHERE t_employee.eid &#x3D; t_salary.eid;</span><br><span class="line">#否则报Column &#39;eid&#39; in field list is ambiguous</span><br></pre></td></tr></table></figure><p>表别名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT emp.eid,ename,basic_salary</span><br><span class="line">FROM t_employee AS emp, t_salary AS s</span><br><span class="line">WHERE emp.eid &#x3D; s.eid;</span><br></pre></td></tr></table></figure><h2 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h2><p>定义：将两（或多）个表的所有行进行组合，连接后的行数为两（或多）个表的乘积数.</p><p>在MySQL中如下情况会出现笛卡尔积，主要是因为缺少关联条件或者关联条件不准确</p><p>注：外连接必须写关联条件，否则报语法错误</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#笛卡尔积</span><br><span class="line">#查询员工姓名和所在部门名称</span><br><span class="line">SELECT ename,dname FROM t_employee,t_department;</span><br><span class="line">SELECT ename,dname FROM t_employee INNER JOIN t_department;</span><br><span class="line">SELECT ename,dname FROM t_employee CROSS JOIN t_department;</span><br><span class="line">SELECT ename,dname FROM t_employee JOIN t_department;</span><br></pre></td></tr></table></figure><h2 id="关联条件"><a href="#关联条件" class="headerlink" title="关联条件"></a>关联条件</h2><p>表连接的约束条件可以有三种方式：WHERE, ON, USING</p><ul><li>WHERE：适用于所有关联查询</li><li>ON：只能和JOIN一起使用，只能写关联条件。虽然关联条件可以并到WHERE中和其他条件一起写，但分开写可读性更好。</li><li>USING：只能和JOIN一起使用，而且要求<strong>两个</strong>关联字段在关联表中名称一致，而且只能表示关联字段值相等</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#关联条件</span><br><span class="line">#把关联条件写在where后面</span><br><span class="line">SELECT ename,dname FROM t_employee,t_department WHERE t_employee.dept_id&#x3D;t_department.did;</span><br><span class="line"></span><br><span class="line">#把关联条件写在on后面，只能和JOIN一起使用</span><br><span class="line">SELECT ename,dname FROM t_employee INNER JOIN t_department ON t_employee.dept_id&#x3D;t_department.did;</span><br><span class="line">SELECT ename,dname FROM t_employee CROSS JOIN t_department ON t_employee.dept_id&#x3D;t_department.did;</span><br><span class="line">SELECT ename,dname FROM t_employee JOIN t_department ON t_employee.dept_id&#x3D;t_department.did;</span><br><span class="line"></span><br><span class="line">#把关联字段写在using()中，只能和JOIN一起使用</span><br><span class="line">#而且两个表中的关联字段必须名称相同，而且只能表示&#x3D;</span><br><span class="line">#查询员工姓名与基本工资</span><br><span class="line">SELECT ename,basic_salary FROM t_employee INNER JOIN t_salary USING(eid);</span><br><span class="line"></span><br><span class="line">#n张表关联，需要n-1个关联条件</span><br><span class="line">#查询员工姓名，基本工资，部门名称</span><br><span class="line">SELECT ename,basic_salary,dname FROM t_employee,t_department,t_salary </span><br><span class="line">WHERE t_employee.dept_id&#x3D;t_department.did AND t_employee.eid&#x3D;t_salary.eid;</span><br><span class="line"></span><br><span class="line">SELECT ename,basic_salary,dname FROM t_employee INNER JOIN t_department INNER JOIN t_salary </span><br><span class="line">ON t_employee.dept_id&#x3D;t_department.did AND t_employee.eid&#x3D;t_salary.eid;</span><br></pre></td></tr></table></figure><h2 id="内连接（INNER-JOIN）"><a href="#内连接（INNER-JOIN）" class="headerlink" title="内连接（INNER JOIN）"></a>内连接（INNER JOIN）</h2><p>有两种，显式的和隐式的，返回连接表中符合连接条件和查询条件的数据行</p><p>格式：</p><p><strong>隐式：</strong></p><ul><li>SELECT [cols_list] from 表1,表2  where [condition]</li></ul><p><strong>显式：</strong></p><ul><li><p>SELECT [cols_list] from 表1  INNER JOIN 表2  ON [关联条件] where [其他筛选条件]</p></li><li><p>SELECT [cols_list] from 表1  CROSS JOIN 表2  ON [关联条件] where [其他筛选条件]</p></li><li><p>SELECT [cols_list] from 表1  JOIN 表2  ON [关联条件] where [其他筛选条件]</p></li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql33.png" alt="mysql"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#内连接</span><br><span class="line">#查询员工姓名和所在部门名称</span><br><span class="line">SELECT ename,dname FROM t_employee,t_department WHERE t_employee.dept_id&#x3D;t_department.did;</span><br><span class="line">SELECT ename,dname FROM t_employee INNER JOIN t_department ON t_employee.dept_id&#x3D;t_department.did;</span><br><span class="line">SELECT ename,dname FROM t_employee CROSS JOIN t_department ON t_employee.dept_id&#x3D;t_department.did;</span><br><span class="line">SELECT ename,dname FROM t_employee JOIN t_department ON t_employee.dept_id&#x3D;t_department.did;</span><br><span class="line"></span><br><span class="line">#查询员工姓名，基本工资，部门名称</span><br><span class="line">SELECT ename,basic_salary,dname FROM t_employee,t_department,t_salary </span><br><span class="line">WHERE t_employee.dept_id&#x3D;t_department.did AND t_employee.eid&#x3D;t_salary.eid;</span><br><span class="line"></span><br><span class="line">SELECT ename,basic_salary,dname FROM t_employee INNER JOIN t_department INNER JOIN t_salary </span><br><span class="line">ON t_employee.dept_id&#x3D;t_department.did AND t_employee.eid&#x3D;t_salary.eid;</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql34.png" alt="mysql"></p><h2 id="外连接（OUTER-JOIN）"><a href="#外连接（OUTER-JOIN）" class="headerlink" title="外连接（OUTER  JOIN）"></a>外连接（OUTER  JOIN）</h2><p>外连接分为：</p><p>左外连接（LEFT OUTER JOIN），简称左连接（LEFT JOIN）</p><p>右外连接（RIGHT OUTER JOIN），简称右连接（RIGHT JOIN）</p><p>全外连接（FULL OUTER JOIN），简称全连接（FULL JOIN）</p><h3 id="左连接（LEFT-JOIN）"><a href="#左连接（LEFT-JOIN）" class="headerlink" title="左连接（LEFT JOIN）"></a>左连接（LEFT JOIN）</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql35.png" alt="mysql"></p><h3 id="右外连接（RIGHT-JOIN）"><a href="#右外连接（RIGHT-JOIN）" class="headerlink" title="右外连接（RIGHT JOIN）"></a>右外连接（RIGHT JOIN）</h3><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql36.png" alt="mysql"></p><h3 id="外连接（FULL-JOIN）"><a href="#外连接（FULL-JOIN）" class="headerlink" title="外连接（FULL JOIN）"></a>外连接（FULL JOIN）</h3><p>mysql不支持FULL JOIN，但是可以用 left join <strong>union</strong> right join代替</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql37.png" alt="mysql"></p><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两个表再进行内连接，外连接等查询</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#自连接</span><br><span class="line">#查询员工姓名以及领导姓名，仅显示有领导的员工</span><br><span class="line">SELECT emp.ename,mgr.ename </span><br><span class="line">FROM t_employee AS emp, t_employee AS mgr</span><br><span class="line">WHERE emp.mid &#x3D; mgr.eid;</span><br><span class="line"></span><br><span class="line">#查询员工姓名以及领导姓名，仅显示有领导的员工</span><br><span class="line">SELECT emp.ename,mgr.ename </span><br><span class="line">FROM t_employee AS emp INNER JOIN t_employee AS mgr</span><br><span class="line">ON emp.mid &#x3D; mgr.eid;</span><br><span class="line"></span><br><span class="line">#查询所有员工姓名及其领导姓名</span><br><span class="line">SELECT emp.ename,mgr.ename </span><br><span class="line">FROM t_employee AS emp LEFT JOIN t_employee AS mgr</span><br><span class="line">ON emp.mid &#x3D; mgr.eid;</span><br></pre></td></tr></table></figure><h1 id="select的6个子句"><a href="#select的6个子句" class="headerlink" title="select的6个子句"></a>select的6个子句</h1><h2 id="from"><a href="#from" class="headerlink" title="from"></a>from</h2><p>后面跟表，视图，多行多列的二维表的结构</p><h2 id="where条件查询"><a href="#where条件查询" class="headerlink" title="where条件查询"></a>where条件查询</h2><p>从原表中的记录中进行筛选</p><h2 id="group-by-分组查询"><a href="#group-by-分组查询" class="headerlink" title="group by 分组查询"></a>group by 分组查询</h2><p>很多情况下，用户都需要进行一些汇总操作，比如统计整个公司的人数或者统计每一个部门的人数等。</p><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><ul><li><p>AVG(【DISTINCT】 expr) 返回expr的平均值</p></li><li><p>COUNT（【DISTINCT】 expr）返回expr的非NULL值的数目</p></li><li><p>MIN(【DISTINCT】 expr)返回expr的最小值</p></li><li><p>MAX(【DISTINCT】 expr)返回expr的最大值</p></li><li><p>SUM（【DISTINCT】 expr）返回expr的总和</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#聚合函数</span><br><span class="line">#AVG(【DISTINCT】 expr) 返回expr的平均值</span><br><span class="line">SELECT AVG(basic_salary) FROM t_salary;</span><br><span class="line"></span><br><span class="line">#COUNT（【DISTINCT】 expr）返回expr的非NULL值的数目</span><br><span class="line">#统计员工总人数</span><br><span class="line">SELECT COUNT(*) FROM t_employee;#count(*)统计的是记录数</span><br><span class="line">#统计员工表的员工所在部门数</span><br><span class="line">SELECT COUNT(dept_id) FROM t_employee;#统计的是非NULL值</span><br><span class="line">SELECT COUNT(DISTINCT dept_id) FROM t_employee;#统计的是非NULL值，并且去重</span><br><span class="line"></span><br><span class="line">#MIN(【DISTINCT】 expr)返回expr的最小值</span><br><span class="line">#查询最低基本工资值</span><br><span class="line">SELECT MIN(basic_salary) FROM t_salary;</span><br><span class="line"></span><br><span class="line">#MAX(【DISTINCT】 expr)返回expr的最大值</span><br><span class="line">#查询最高基本工资值</span><br><span class="line">SELECT MAX(basic_salary) FROM t_salary;</span><br><span class="line"></span><br><span class="line">#查询最高基本工资与最低基本工资的差值</span><br><span class="line">SELECT MAX(basic_salary)-MIN(basic_salary) FROM t_salary;</span><br><span class="line"></span><br><span class="line">#SUM（【DISTINCT】 expr）返回expr的总和</span><br><span class="line">#查询基本工资总和</span><br><span class="line">SELECT SUM(basic_salary) FROM t_salary;</span><br></pre></td></tr></table></figure><h3 id="group-by-聚合函数"><a href="#group-by-聚合函数" class="headerlink" title="group by + 聚合函数"></a>group by + 聚合函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#group by + 聚合函数</span><br><span class="line">#统计每个部门的人数</span><br><span class="line">SELECT dept_id,COUNT(*) FROM t_employee</span><br><span class="line">GROUP BY dept_id;</span><br><span class="line"></span><br><span class="line">#统计每个部门的平均基本工资</span><br><span class="line">SELECT emp.dept_id,AVG(s.basic_salary )</span><br><span class="line">FROM t_employee AS emp,t_salary AS s</span><br><span class="line">WHERE emp.eid &#x3D; s.eid</span><br><span class="line">GROUP BY emp.dept_id;</span><br><span class="line"></span><br><span class="line">#统计每个部门的年龄最大者</span><br><span class="line">SELECT dept_id,MIN(birthday) FROM t_employee GROUP BY dept_id;</span><br><span class="line"></span><br><span class="line">#统计每个部门基本工资最高者</span><br><span class="line">SELECT emp.dept_id,MAX(s.basic_salary )</span><br><span class="line">FROM t_employee AS emp,t_salary AS s</span><br><span class="line">WHERE emp.eid &#x3D; s.eid</span><br><span class="line">GROUP BY emp.dept_id;</span><br><span class="line"></span><br><span class="line">#统计每个部门基本工资之和</span><br><span class="line">SELECT emp.dept_id,SUM(s.basic_salary )</span><br><span class="line">FROM t_employee AS emp,t_salary AS s</span><br><span class="line">WHERE emp.eid &#x3D; s.eid</span><br><span class="line">GROUP BY emp.dept_id;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>用count(*),count(1),谁好呢?</p><p>其实,对于myisam引擎的表,没有区别的.</p><p>这种引擎内部有一计数器在维护着行数.</p><p>Innodb的表,用count(*)直接读行数,效率很低,因为innodb真的要去数一遍.</p><p>关于mysql的group by的特殊：</p><p>注意：在SELECT 列表中所有未包含在组函数中的列都应该是包含在 GROUP BY 子句中的，换句话说，SELECT列表中最好不要出现GROUP BY子句中没有的列。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql38.png" alt="mysql"></p><p>对于标准语句来说，这个语句是错误的，但是mysql可以这么干，出于可移植性和规范性,不推荐这么写。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql39.png" alt="mysql"></p><h2 id="having-筛选"><a href="#having-筛选" class="headerlink" title="having 筛选"></a>having 筛选</h2><p>having与where类似,可筛选数据</p><p>having与where不同点</p><ul><li><p>where针对表中的列发挥作用,查询数据；having针对查询结果中的列发挥作用,筛选数据</p></li><li><p>where后面不能写分组函数，而having后面可以使用分组函数</p></li><li><p>having只用于group by分组统计语句</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#按照部门统计员工人数，仅显示部门人数少于3人的</span><br><span class="line">SELECT dept_id,COUNT(*) AS c </span><br><span class="line">FROM t_employee </span><br><span class="line">WHERE dept_id IS NOT NULL</span><br><span class="line">GROUP BY dept_id</span><br><span class="line">HAVING c &lt;3;</span><br><span class="line"></span><br><span class="line">#查询每个部门的平均工资，并且仅显示平均工资高于10000</span><br><span class="line">SELECT emp.dept_id,AVG(s.basic_salary ) AS avg_salary</span><br><span class="line">FROM t_employee AS emp,t_salary AS s</span><br><span class="line">WHERE emp.eid &#x3D; s.eid AND dept_id IS NOT NULL</span><br><span class="line">GROUP BY emp.dept_id</span><br><span class="line">HAVING avg_salary &gt;10000;</span><br></pre></td></tr></table></figure><h2 id="order-by-排序"><a href="#order-by-排序" class="headerlink" title="order by 排序"></a>order by 排序</h2><ul><li><p>按一个或多个字段对查询结果进行排序</p><p>用法：order by col1,col2,col3…</p><p>说明：先按col1排序如果col1相同就按照col2排序，依次类推</p><p>col1，col2，col3可以是select后面的字段也可以不是</p></li><li><p>默认是升序，也可以在字段后面加asc显示说明是升序，desc为降序</p><p>例如：order by click_count desc; </p><p>如果两个字段排序不一样，例如：order by 字段1 asc ,字段2 desc;</p></li><li><p>order by 后面除了跟1个或多个字段，还可以写表达式，函数，别名等</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#排序</span><br><span class="line">#查询员工基本工资，按照基本工资升序排列，如果工资相同，按照eid升序排列</span><br><span class="line">SELECT t_employee.eid,basic_salary FROM t_employee INNER JOIN t_salary</span><br><span class="line">ON t_employee.eid &#x3D; t_salary.eid</span><br><span class="line">ORDER BY basic_salary,eid;</span><br><span class="line"></span><br><span class="line">#查询员工基本工资，按照基本工资降序排列，如果工资相同，按照eid排列</span><br><span class="line">SELECT t_employee.eid,basic_salary FROM t_employee INNER JOIN t_salary</span><br><span class="line">ON t_employee.eid &#x3D; t_salary.eid</span><br><span class="line">ORDER BY basic_salary DESC,eid;</span><br><span class="line"></span><br><span class="line">#统计每个部门的平均基本工资，并按照平均工资降序排列</span><br><span class="line">SELECT emp.dept_id,AVG(s.basic_salary)</span><br><span class="line">FROM t_employee AS emp,t_salary AS s</span><br><span class="line">WHERE emp.eid &#x3D; s.eid</span><br><span class="line">GROUP BY emp.dept_id</span><br><span class="line">ORDER BY AVG(s.basic_salary) DESC;</span><br></pre></td></tr></table></figure><h2 id="limit-分页"><a href="#limit-分页" class="headerlink" title="limit 分页"></a>limit 分页</h2><p>limit m,n</p><p>m表示从下标为m的记录开始查询，第一条记录下标为0，n表示取出n条出来，如果从m开始不够n条了，就有几条取几条。m=(page-1)*n，（page页码，n表示每页显示的条数）</p><p>如果第一页limit 0,n</p><p>如果第二页limit n,n</p><p>依次类推，得出公式limit  (page-1)*n , n</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#分页</span><br><span class="line">#查询员工信息，每页显示5条，第二页</span><br><span class="line">SELECT * FROM t_employee LIMIT 5,5;</span><br><span class="line"></span><br><span class="line">#统计每个部门的平均基本工资，并显示前三名</span><br><span class="line">SELECT emp.dept_id,AVG(s.basic_salary)</span><br><span class="line">FROM t_employee AS emp,t_salary AS s</span><br><span class="line">WHERE emp.eid &#x3D; s.eid</span><br><span class="line">GROUP BY emp.dept_id</span><br><span class="line">ORDER BY AVG(s.basic_salary) DESC</span><br><span class="line">LIMIT 0,3;</span><br></pre></td></tr></table></figure><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>某些情况下，当进行一个查询时，需要的条件或数据要用另外一个 select 语句的结果，这个时候，就要用到子查询。</p><p>例如：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql40.png" alt="mysql"></p><p>为了给主查询（外部查询）提供数据而首先执行的查询（内部查询）被叫做子查询。</p><p>一般根据子查询的嵌入位置分为，where型子查询,from型子查询，exists型子查询。</p><h2 id="where型子查询"><a href="#where型子查询" class="headerlink" title="where型子查询"></a>where型子查询</h2><p>where型子查询即把内层sql语句查询的结果作为外层sql查询的条件.</p><ul><li>子查询要包含在括号内。</li><li>建议将子查询放在比较条件的右侧。</li><li>单行操作符对应单行子查询，多行操作符对应多行子查询。<ul><li>单行操作符 右边子查询必须返回的是<strong>单个值</strong>，单行比较运算符（=,&gt;,&gt;=,&lt;,&lt;=,&lt;&gt;）</li><li>多行操作符 右边子查询可以返回多行，但必须是单列，ALL, ANY,IN 其中，ALL和ANY运算符必须与单行比较运算符（=,&gt;,&gt;=,&lt;,&lt;=,&lt;&gt;）结合使用</li></ul></li></ul><blockquote><p>IN：等于任何一个</p><p>ALL：和子查询返回的所有值比较。例如：sal&gt;ALL(1,2,3)等价于sal&gt;1 &amp;&amp; sal&gt;2 &amp;&amp; sal&gt;3，即大于所有。</p><p>ANY：和子查询返回的任意一个值比较。例如：sal&gt;ANY(1,2,3)等价于sal&gt;1 or sal&gt;2 or sal&gt;3，即大于任意一个就可以。</p><p>EXISTS：判断子查询是否有返回结果（不关心具体行数和内容），如果返回则为TRUE，否则为FALSE。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#子查询</span><br><span class="line">#where型子查询</span><br><span class="line">#查询比“孙红雷”的工资高的员工编号</span><br><span class="line">SELECT * FROM t_salary</span><br><span class="line">WHERE basic_salary &gt; (SELECT basic_salary FROM t_employee INNER JOIN t_salary ON t_employee.eid&#x3D;t_salary.eid WHERE t_employee.ename&#x3D;&#39;孙红雷&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查询和孙红雷，李晨在同一个部门的员工</span><br><span class="line">SELECT * FROM t_employee</span><br><span class="line">WHERE dept_id IN(SELECT dept_id FROM t_employee WHERE ename&#x3D;&#39;孙红雷&#39; OR ename &#x3D; &#39;李晨&#39;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM t_employee</span><br><span class="line">WHERE dept_id &#x3D; ANY(SELECT dept_id FROM t_employee WHERE ename&#x3D;&#39;孙红雷&#39; OR ename &#x3D; &#39;李晨&#39;);</span><br><span class="line"></span><br><span class="line">#查询全公司工资最高的员工编号，基本工资</span><br><span class="line">SELECT eid,basic_salary FROM t_salary</span><br><span class="line">WHERE basic_salary &#x3D; (SELECT MAX(basic_salary) FROM t_salary);</span><br><span class="line"></span><br><span class="line">SELECT eid,basic_salary FROM t_salary</span><br><span class="line">WHERE basic_salary &gt;&#x3D; ALL(SELECT basic_salary FROM t_salary);</span><br></pre></td></tr></table></figure><h2 id="from型子查询"><a href="#from型子查询" class="headerlink" title="from型子查询"></a>from型子查询</h2><p>from型子查询即把内层sql语句查询的结果作为临时表供外层sql语句再次查询.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#from型</span><br><span class="line">#找出比部门平均工资高的员工编号，基本工资</span><br><span class="line">SELECT t_employee.eid,basic_salary </span><br><span class="line">FROM t_salary INNER JOIN t_employee INNER JOIN (</span><br><span class="line">SELECT emp.dept_id AS did,AVG(s.basic_salary) AS avg_salary</span><br><span class="line">FROM t_employee AS emp,t_salary AS s</span><br><span class="line">WHERE emp.eid &#x3D; s.eid</span><br><span class="line">GROUP BY emp.dept_id) AS temp</span><br><span class="line">ON t_salary.eid &#x3D; t_employee.eid AND t_employee.dept_id &#x3D; temp.did</span><br><span class="line">WHERE t_salary.basic_salary &gt; temp.avg_salary;</span><br></pre></td></tr></table></figure><h2 id="exists型子查询"><a href="#exists型子查询" class="headerlink" title="exists型子查询"></a>exists型子查询</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#exists型</span><br><span class="line">#查询部门信息，该部门必须有员工</span><br><span class="line">SELECT * FROM t_department </span><br><span class="line">WHERE EXISTS (SELECT * FROM t_employee WHERE t_employee.dept_id &#x3D; t_department.did);</span><br></pre></td></tr></table></figure><h2 id="复制表子查询"><a href="#复制表子查询" class="headerlink" title="复制表子查询"></a>复制表子查询</h2><h3 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h3><ol><li><p>拷贝表结构</p><p>CREATE TABLE newadmin LIKE admin;</p></li><li><p>拷贝表结构和数据（但约束与索引除外）</p><p>CREATE TABLE newadmin  AS  ( SELECT *  FROM admin  )  ;</p></li><li><p>拷贝表结构+数据</p><p>CREATE TABLE newadmin LIKE admin;  </p><p>INSERT INTO newadmin SELECT * FROM admin;</p></li><li><p>跨数据库拷贝表</p><p>CREATE TABLE newadmin LIKE shop.admin;  </p><p>CREATE TABLE newshop.newadmin LIKE shop.admin; </p></li><li><p>拷贝一个表中其中的一些字段（指定新名），其中一些数据</p><p>CREATE TABLE newadmin AS  (  </p><p>​        SELECT id, username AS uname, password AS pass FROM admin  WHERE id&lt;10 </p><p>)  ;</p></li><li><p>在创建表的同时定义表中的字段信息。</p><p>create table tt    (</p><p>​    eid int primary key auto_increment</p><p>)    as    (</p><p>​    select employee_id as eid,first_name,last_name,email from employees</p><p>); </p></li></ol><h3 id="复制数据"><a href="#复制数据" class="headerlink" title="复制数据"></a>复制数据</h3><p>在 INSERT 语句中加入子查询。</p><p>不必书写 VALUES 子句。 </p><p>子查询中的值列表应与 INSERT 子句中的列名对应。</p><p>INSERT INTO emp2 </p><p>SELECT * FROM employees WHERE department_id = 90;</p><p>或</p><p>INSERT INTO sales_reps(id, name, salary, commission_pct)</p><p>SELECT employee_id, last_name, salary, commission_pct</p><p>FROM  employees</p><p>WHERE  job_id LIKE ‘%REP%’;</p><h1 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h1><p>MySQL数据库提供了很多函数包括：</p><ul><li><p>数学函数；</p></li><li><p>字符串函数；</p></li><li><p>日期和时间函数；</p></li><li><p>条件判断函数；流程控制函数；</p></li><li><p>系统信息函数；</p></li><li><p>加密函数；</p></li><li><p>格式化函数；</p></li></ul><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><table><thead><tr><th>ABS（x）</th><th>返回x的绝对值</th></tr></thead><tbody><tr><td>CEIL（x）</td><td>返回大于x的最小整数值</td></tr><tr><td>FLOOR（x）</td><td>返回大于x的最大整数值</td></tr><tr><td>MOD(x,y)</td><td>返回x/y的模</td></tr><tr><td>RAND(x)</td><td>返回0~1的随机值</td></tr><tr><td>ROUND(x,y)</td><td>返回参数x的四舍五入的有y位的小数的值</td></tr><tr><td>TRUNCATE(x,y)</td><td>返回数字x截断为y位小数的结果</td></tr><tr><td>SQRT(x)</td><td>返回x的平方根</td></tr><tr><td>POW(x,y)</td><td>返回x的y次方</td></tr></tbody></table><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><table><thead><tr><th>CONCAT(S1,S2,……,Sn)</th><th>连接S1,S2,……,Sn为一个字符串</th></tr></thead><tbody><tr><td>CONCAT_WS(s, S1,S2,……,Sn)</td><td>同CONCAT(s1,s2,…)函数，但是每个字符串之间要加上s</td></tr><tr><td>CHAR_LENGTH(s)</td><td>返回字符串s的字符数</td></tr><tr><td>LENGTH(s)</td><td>返回字符串s的字节数，和字符集有关</td></tr><tr><td>INSERT(str, index , len, instr)</td><td>将字符串str从第index位置开始，len个字符长的子串替换为字符串instr</td></tr><tr><td>UPPER(s) 或 UCASE(s)</td><td>将字符串s的所有字母转成大写字母</td></tr><tr><td>LOWER(s)  或LCASE(s)</td><td>将字符串s的所有字母转成小写字母</td></tr><tr><td>LEFT(s,n)</td><td>返回字符串s最左边的n个字符</td></tr><tr><td>RIGHT(s,n)</td><td>返回字符串s最右边的n个字符</td></tr><tr><td>LPAD(str, len, pad)</td><td>用字符串pad对str最左边进行填充，直到str的长度为len个字符</td></tr><tr><td>RPAD(str ,len, pad)</td><td>用字符串pad对str最右边进行填充，直到str的长度为len个字符</td></tr><tr><td>LTRIM(s)</td><td>去掉字符串s左侧的空格</td></tr><tr><td>RTRIM(s)</td><td>去掉字符串s右侧的空格</td></tr><tr><td>TRIM(s)</td><td>去掉字符串s开始与结尾的空格</td></tr><tr><td>TRIM(【BOTH 】s1 FROM s)</td><td>去掉字符串s开始与结尾的s1</td></tr><tr><td>TRIM(【LEADING】s1 FROM s)</td><td>去掉字符串s开始处的s1</td></tr><tr><td>TRIM(【TRAILING】s1 FROM s)</td><td>去掉字符串s结尾处的s1</td></tr><tr><td>REPEAT(str, n)</td><td>返回str重复n次的结果</td></tr><tr><td>REPLACE（str, a, b）</td><td>用字符串b替换字符串str中所有出现的字符串a</td></tr><tr><td>STRCMP(s1,s2)</td><td>比较字符串s1,s2</td></tr><tr><td>SUBSTRING(s,index,len)</td><td>返回从字符串s的index位置其len个字符</td></tr></tbody></table><h2 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数"></a>日期时间函数</h2><table><thead><tr><th>CURDATE() 或 CURRENT_DATE()</th><th>返回当前日期</th></tr></thead><tbody><tr><td>CURTIME() 或 CURRENT_TIME()</td><td>返回当前时间</td></tr><tr><td>NOW() <br />SYSDATE()<br />CURRENT_TIMESTAMP()<br />LOCALTIME()<br />LOCALTIMESTAMP()</td><td>返回当前系统日期时间</td></tr><tr><td>YEAR(date)<br />MONTH(date)<br />DAY(date)<br />HOUR(time)<br />MINUTE(time)<br />SECOND(time)</td><td>返回具体的时间值</td></tr><tr><td>WEEK(date)<br />WEEKOFYEAR(date)</td><td>返回一年中的第几周</td></tr><tr><td>DAYOFWEEK()</td><td>返回周几，注意：周日是1，周一是2，。。。周六是7</td></tr><tr><td>WEEKDAY(date)</td><td>返回周几，注意，周1是0，周2是1，。。。周日是6</td></tr><tr><td>DAYNAME(date)</td><td>返回星期：MONDAY,TUESDAY…..SUNDAY</td></tr><tr><td>MONTHNAME(date)</td><td>返回月份：January，。。。。。</td></tr><tr><td>DATEDIFF(date1,date2)<br />TIMEDIFF(time1, time2)</td><td>返回date1 - date2的日期间隔返回time1 - time2的时间间隔</td></tr><tr><td>DATE_ADD(datetime, INTERVALE  expr  type)</td><td>返回与给定日期时间相差INTERVAL时间段的日期时间</td></tr><tr><td>DATE_FORMAT(datetime ,fmt)</td><td>按照字符串fmt格式化日期datetime值</td></tr><tr><td>STR_TO_DATE(str, fmt)</td><td>按照字符串fmt对str进行解析，解析为一个日期</td></tr></tbody></table><ul><li>DATE_ADD(datetime,INTERVAL  expr  type</li></ul><blockquote><p>SELECT DATE_ADD(NOW(), INTERVAL 1 YEAR);</p><p>SELECT DATE_ADD(NOW(), INTERVAL -1 YEAR);  #可以是负数</p><p>SELECT DATE_ADD(NOW(), INTERVAL ‘1_1’ YEAR_MONTH);  #需要单引号</p></blockquote><table><thead><tr><th>表达式类型</th><th>YEAR_MONTH</th></tr></thead><tbody><tr><td>YEAR</td><td>DAY_HOUR</td></tr><tr><td>MONTH</td><td>DAY_MINUTE</td></tr><tr><td>DAY</td><td>DAY_SECOND</td></tr><tr><td>HOUR</td><td>HOUR_MINUTE</td></tr><tr><td>MINUTE</td><td>HOUR_SECOND</td></tr><tr><td>SECOND</td><td>MINUTE_SECOND</td></tr></tbody></table><ul><li>DATE_FORMAT(datetime ,fmt)和STR_TO_DATE(str, fmt)</li></ul><table><thead><tr><th>格式符</th><th>说明</th><th>格式符</th><th>说明</th></tr></thead><tbody><tr><td>%Y</td><td>4位数字表示年份</td><td>%y</td><td>表示两位数字表示年份</td></tr><tr><td>%M</td><td>月名表示月份（January,….）</td><td>%m</td><td>两位数字表示月份（01,02,03。。。）</td></tr><tr><td>%b</td><td>缩写的月名（Jan.，Feb.，….）</td><td>%c</td><td>数字表示月份（1,2,3,…）</td></tr><tr><td>%D</td><td>英文后缀表示月中的天数（1st,2nd,3rd,…）</td><td>%d</td><td>两位数字表示月中的天数(01,02…)</td></tr><tr><td>%e</td><td>数字形式表示月中的天数（1,2,3,4,5…..）</td><td></td><td></td></tr><tr><td>%H</td><td>两位数字表示小数，24小时制（01,02..）</td><td>%h和%I</td><td>两位数字表示小时，12小时制（01,02..）</td></tr><tr><td>%k</td><td>数字形式的小时，24小时制(1,2,3)</td><td>%l</td><td>数字形式表示小时，12小时制（1,2,3,4….）</td></tr><tr><td>%i</td><td>两位数字表示分钟（00,01,02）</td><td>%S和%s</td><td>两位数字表示秒(00,01,02…)</td></tr><tr><td>%W</td><td>一周中的星期名称（Sunday…）</td><td>%a</td><td>一周中的星期缩写（Sun.，Mon.,Tues.，..）</td></tr><tr><td>%w</td><td>以数字表示周中的天数(0=Sunday,1=Monday….)</td><td></td><td></td></tr><tr><td>%j</td><td>以3位数字表示年中的天数(001,002…)</td><td>%U</td><td>以数字表示年中的第几周，（1,2,3。。）其中Sunday为周中第一天</td></tr><tr><td>%u</td><td>以数字表示年中的第几周，（1,2,3。。）其中Monday为周中第一天</td><td></td><td></td></tr><tr><td>%T</td><td>24小时制</td><td>%r</td><td>12小时制</td></tr><tr><td>%p</td><td>AM或PM</td><td>%%</td><td>表示%</td></tr></tbody></table><h2 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h2><table><thead><tr><th>IF(value,t ,f)</th><th>如果value是真，返回t，否则返回f</th></tr></thead><tbody><tr><td>IFNULL(value1, value2)</td><td>如果value1不为空，返回value1，否则返回value2</td></tr><tr><td>CASE <br />WHEN 条件1 THEN <br />result1 <br />WHEN 条件2 THEN <br />result2<br />….<br />[ELSE resultn]<br />END</td><td>相当于Java的if…else if…</td></tr><tr><td>CASE  expr <br />WHEN 常量值1 THEN 值1<br />WHEN 常量值1 THEN 值1<br />….<br />[ELSE 值n]<br />END</td><td>相当于Java的switch</td></tr><tr><td></td><td>SELECT ename ,CASE <br />WHEN salary&gt;=15000 THEN ‘高薪’<br />WHEN salary&gt;=10000 THEN ‘潜力股’<br />WHEN salary&gt;=8000 THEN ‘屌丝’<br />ELSE ‘草根’<br />ENDFROM t_employee;</td></tr><tr><td></td><td>SELECT oid,`status`, CASE `status`<br />WHEN 1 THEN ‘未付款’<br />WHEN 2 THEN ‘已付款’<br />WHEN 3 THEN ‘已发货’<br />WHEN 4 THEN ‘确认收货’<br />ELSE ‘无效订单’<br />END<br />FROM t_order;</td></tr></tbody></table><h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>database()</td><td>返回当前数据库名</td></tr><tr><td>version()</td><td>返回当前数据库版本</td></tr><tr><td>user()</td><td>返回当前登录用户名</td></tr><tr><td>password(str)</td><td>返回字符串str的加密版本，41位长的字符串</td></tr><tr><td>md5(str)</td><td>返回字符串str的md5值，也是一种加密方式</td></tr></tbody></table><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>DCL用来控制数据库的访问，包括如下SQL语句：</p><ul><li>GRANT：授予访问权限</li><li>REVOKE：撤销访问权限</li><li>COMMIT：提交事务处理</li><li>ROLLBACK：事务处理回退</li><li>SAVEPOINT：设置保存点</li><li>LOCK：对数据库的特定部分进行锁定</li></ul><p>思考：我去银行给朋友汇款,我卡上有1000元,朋友卡上500元,我给朋友转账50元(无手续费),如果,我的钱刚扣,而朋友的钱又没加时,网线断了,怎么办?</p><h2 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h2><ul><li><p>原子性(Atomicity)：原子意为最小的粒子，或者说不能再分的事物。数据库事务的不可再分的原则即为原子性。 </p><p>组成事务的所有SQL必须：要么全部执行，要么全部取消（就像上面的银行例子）。</p></li><li><p>一致性(Consistency)：指数据的规则,在事务前/</p></li><li><p>隔离性(Isolation)：简单点说，某个事务的操作对其他事务不可见的.</p></li><li><p>持久性(Durability)：当事务提交完成后，其影响应该保留下来，不能撤消</p></li></ul><h2 id="事务的用法"><a href="#事务的用法" class="headerlink" title="事务的用法"></a>事务的用法</h2><ul><li>开启事务(start transaction)</li><li>执行sql操作(普通sql操作)</li><li>提交/回滚(commit/rollback)</li></ul><p>注意:</p><ul><li>建表的时候,选择 <strong>Innodb引擎</strong>才支持事务</li><li>默认情况下，MySQL是自动提交事务，每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。如果某一组操作需要在一个事务中，那么需要使用start transaction，一旦rollback或commit就结束当次事务，之后的操作又自动提交。</li><li>如果需要在当前会话（连接）的整个过程中都取消自动提交事务，进行手动提交事务，就需要设置set autocommit = false;或set autocommit = 0;那样的话每一句SQL都需要手动commit提交才会真正生效。rollback或commit之前的所有操作都视为一个事务，之后的操作视为另一个事务，还需要手动提交或回滚。</li><li>和Oracle一样，DDL语句是不能回滚的，并且部分的DDL语句会造成隐式的提交，因此最好事务中不要涉及DDL语句。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#开启手动处理事务模式</span><br><span class="line">#set autocommit &#x3D; false;</span><br><span class="line">#开始事务（推荐）</span><br><span class="line">start transaction;</span><br><span class="line"></span><br><span class="line">#查看当前表的数据</span><br><span class="line">select * from t_stu_detail;</span><br><span class="line">#删除整张表的数据</span><br><span class="line">delete from t_stu_detail;</span><br><span class="line">#查询该表数据，发现显示删除后的结果</span><br><span class="line">select * from t_stu_detail;</span><br><span class="line">#回滚</span><br><span class="line">rollback</span><br><span class="line">#查看当前表的数据，发现又回来了</span><br><span class="line">select * from t_stu_detail;</span><br><span class="line"></span><br><span class="line">#删除整张表的数据</span><br><span class="line">delete from t_stu_detail;</span><br><span class="line">#提交事务</span><br><span class="line">commit;</span><br><span class="line">#查看当前表的数据，发现真删除了</span><br><span class="line">select * from t_stu_detail;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#插入一条记录</span><br><span class="line">INSERT INTO t_stu_detail VALUES </span><br><span class="line">(1, &#39;123456789012345678&#39;, &#39;1990-01-21&#39;, &#39;12345678901&#39;, &#39;a@163.com&#39;, &#39;北七家&#39;);</span><br><span class="line">#保存还原点1</span><br><span class="line">savepoint point1;</span><br><span class="line">#插入一条记录</span><br><span class="line"></span><br><span class="line">INSERT INTO t_stu_detail VALUES </span><br><span class="line">(2, &#39;123456789012345677&#39;, &#39;1990-02-21&#39;, &#39;12345678902&#39;, &#39;b@163.com&#39;, &#39;北七家&#39;);</span><br><span class="line">#保存还原点2</span><br><span class="line">savepoint point2;</span><br><span class="line"></span><br><span class="line">#查看当前效果</span><br><span class="line">select * from t_stu_detail;</span><br><span class="line"></span><br><span class="line">#回滚到某个还原点</span><br><span class="line">rollback to point1;</span><br><span class="line"></span><br><span class="line">#提交事务</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">#清空表</span><br><span class="line">truncate t_stu_detail;</span><br><span class="line">#回滚，对于truncate无法回滚</span><br><span class="line">rollback;</span><br><span class="line">#修改表结构</span><br><span class="line">alter table t_stu_detail add description varchar(50);</span><br><span class="line">#回滚，对于修改表结构的语句无法回滚</span><br><span class="line">rollback;</span><br></pre></td></tr></table></figure><h2 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h2><p>对于同时运行的多个事务（<strong>多线程并发</strong>）, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题: （问题的本质就是线程安全问题，共享数据的问题）</p><ul><li><p>脏读: </p><p>对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段. 之后, 若 T2 <strong>回滚</strong>, T1读取的内容就是临时且无效的.</p></li><li><p>不可重复读：</p><p>对于两个事务 T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新并提交</strong>了该字段. 之后, T1再次读取同一个字段, 值就不同了.</p></li><li><p>幻读：</p><p>对于两个事务 T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入、删除</strong>了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会<strong>多出、少了</strong>几行.</p></li></ul><p>数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。</p><p>Oracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE. Oracle 默认的事务隔离级别为: READ COMMITED </p><p>Mysql 支持 4 中事务隔离级别. Mysql 默认的事务隔离级别为: REPEATABLE-READ</p><p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个变量 @@tx_isolation, 表示当前的事务隔离级别. </p><ul><li>SELECT @@tx_isolation;    查看当前的隔离级别</li><li>select @@global.tx_isolation;    查看全局的隔离级别</li><li>set tx_isolation =’repeatable-read’;    设置当前 mySQL 连接的隔离级别</li><li>set global tx_isolation =’read-committed’;    设置数据库系统的全局的隔离级别</li></ul><table><thead><tr><th>隔离级别</th><th>描述</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>允许事务读取其他事务未提交的数据，脏读、不可重复读、幻读的问题都会出现</td></tr><tr><td>READ-COMMITTED</td><td>只允许事务读取其他事务已经提交的数据，可以避免脏读，但是不可重复读、幻读的问题仍然会出现</td></tr><tr><td>REPEATABLE-READ</td><td>确保事务可以多次从一个字段中读取相同的值，好比在事务开启时对现有的数据进行了拍照，其他事务对数据的修改，不管事务是否提交，我这里读取的是拍照下来的数据，可以避免脏读和不可重复读，但幻读的问题仍然存在。注意：INNODB使用了MVCC (Multiversion Concurrency Control)，即多版本并发控制技术防止幻读。真正的像拍照一样，其他事务新插入或删除的记录也看不出来。</td></tr><tr><td>SERIALIZABLE</td><td>确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入、更新、删除操作，所有并发问题都可以避免，但是性能十分低下。</td></tr></tbody></table><h2 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>脏读：进入餐厅发现“梦中情人”旁边座位已经有“帅哥”坐那儿了，正郁闷，打完饭，发现那个位置是空着的，又欣喜若狂，其实刚刚那个“帅哥”只是临时过去打个招呼。</p><table><thead><tr><th><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql41.png" alt="mysql"><br />客户端A却读取到B未提交的脏数据</th><th><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql42.png" alt="mysql"><br />客户端B还未提交</th></tr></thead><tbody><tr><td><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql43.png" alt="mysql"><br />客户端A读取不到B未提交的脏数据</td><td><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql42.png" alt="mysql"><br />客户端B还未提交</td></tr></tbody></table><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读：在图书馆门口，发现自己占的位置旁边有位“美女”，等刷完卡，兴冲冲的走到那儿，发现已经变成一“如花”了。</p><table><thead><tr><th><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql44.png" alt="mysql"><br />A客户端在同一个事务中，前后两次读取同一条记录，值不同</th><th><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql45.png" alt="mysql"><br />B客户端提交了新修改的数据</th></tr></thead><tbody><tr><td><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql46.png" alt="mysql"><br />A客户端在同一个事务中，前后两次读取同一条记录，值相同</td><td><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql47.png" alt="mysql"><br />B客户端提交了新修改的数据</td></tr></tbody></table><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>大学考前画重点，老师说“第一章 xxxxxx概念”，你赶紧找，“天啊，在哪儿啊”，等你画完，就听老师说：“第四章xxxxx”，中间那些你都没听到。</p><table><thead><tr><th><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql48.png" alt="mysql"><br />A客户端在同一个事务中，对同一个表的查询记录数不相同</th><th><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql49.png" alt="mysql"><br />B客户端事务删除了数据，并提交</th></tr></thead><tbody><tr><td><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql50.png" alt="mysql"><br />A客户端在同一个事务中，对同一个表的查询记录数不相同</td><td><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql51.png" alt="mysql"><br />B客户端事务添加了数据，并提交</td></tr></tbody></table><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><table><thead><tr><th><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql52.png" alt="mysql"><br />A客户端的事务级别是序列化，A客户端正在查看temp表</th><th><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql53.png" alt="mysql"><br />B客户端想要多temp进行增、删、改操作不被允许如果A客户端迟迟不结束事务，B客户端将会报ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</th></tr></thead><tbody><tr><td></td><td><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql54.png" alt="mysql"></td></tr><tr><td></td><td><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql55.png" alt="mysql"></td></tr><tr><td></td><td><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql56.png" alt="mysql"><br />但是B客户端对A客户端未涉及的表不受影响</td></tr></tbody></table><h1 id="权限与安全"><a href="#权限与安全" class="headerlink" title="权限与安全"></a>权限与安全</h1><p>数据库的权限和数据库的安全是息息相关的，不当的权限设置可能会导致各种各样的安全隐患，操作系统的某些设置也会对MySQL的安全造成影响。</p><h2 id="权限系统的工作原理"><a href="#权限系统的工作原理" class="headerlink" title="权限系统的工作原理"></a>权限系统的工作原理</h2><p>MySQL的权限系统通过下面两个阶段进行认证：</p><ul><li><p>对连接到数据库的用户进行身份认证，以此来判断此用户是否属于合法的用户，合法的用户通过认证，不合法的用户拒绝连接</p></li><li><p>对通过认证的合法的用户则赋予相应的权限，用户可以在这些权限范围内对数据库做相应的操作</p></li></ul><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><p>对于身份认证，MySQL是通过IP地址和用户名联合进行确认的，也就是说，同样的一个用户名如果来自不同的IP地址，则MySQL将其视为不同的用户。</p><p>例如MySQL安装后默认创建的用户root@localhost表示用户root只能从本地(localhost)进行连接才可以通过认证，此用户从其他任何主机对数据库进行的连接都将被拒绝，除非安装时选择了（Enable root access from remote machines），那创建的就是root@%用户，就表示可以从任意主机通过root用户进行连接。</p><h3 id="权限表的存取"><a href="#权限表的存取" class="headerlink" title="权限表的存取"></a>权限表的存取</h3><p>在权限存取的两个过程中，系统会用到”mysql”数据库中user和db、host这三个最重要的权限表。</p><p>user表中的权限是针对所有数据库的，db表存储了某个用户对一个数据库的权限，host表中存储了某个主机对数据库的操作权限，配合db表对给定主机上数据库级操作权限做更细致的控制；但是很少用，新版本已经取消了host表。</p><p>当用户进行连接时，权限表的存取过程有一些两个阶段：</p><ul><li>先从user表中的host、user和password这3个字段中判断连接的IP、用户名和密码是否存在与表中，如果存在，则通过身份验证，否则拒绝连接。</li><li>如果通过身份验证，则按照一些权限表的顺序得到数据库权限：user-&gt;db-&gt;tables_priv-&gt;columns_priv。在这几个权限表中，权限范围依次递减，全局权限覆盖局部权限。<ul><li>当用户通过权限认证，进行权限分配是时先检查全局权限表user，如果user中对应权限为Y，则此用户对所有数据库的权限都为Y，将不再检查db、tables_priv和columns_priv；如果为N，则到db表中检查此用户对应的具体数据库，并得到db中为Y的权限，如果db中相应权限为N，则检查tables_priv中此数据库对应的具体表，取得表中为Y的权限，如果tables_priv中相应的权限为N，则检查columns_priv中此表对应的具体列，取得列中为Y的权限。</li></ul></li></ul><h4 id="用户表user"><a href="#用户表user" class="headerlink" title="用户表user"></a>用户表user</h4><p>user表有39个字段。这些字段可以分为4类：</p><ul><li>用户列：host，user，password三个字段</li><li>安全列：ssl_type、ssl_cipher、x509_issuer、x509_subject<ul><li>ssl用于加密；x509标准可以用来标识用户。普通的发行版都没有加密功能。可以使用SHOW VARIABLES LIKE ‘have_openssl’语句来查看是否具有ssl功能。如果取值为DISABLED，那么则没有ssl加密功能。</li></ul></li><li>资源控制列：max_questions（每小时可以允许执行多少次查询）、max_updates（每小时可以允许执行多少次更新）、max_connections（每小时可以建立多少连接）、max_user_connections（单个用户可以同时具有的连接数）<ul><li>默认值为0，表示无限制。</li></ul></li><li>权限列：<ul><li>这些字段的值只有Y和N。Y表示该权限可以用到所有数据库上；N表示该权限不能用到所有数据库上；通常，可以使用GRANT语句Wie用户赋予一些权限，也可以通过Update语句更新user表的方式来设置权限；不过，修改user表之后，一定要执行一下FLUSH PRIVILEGES</li></ul></li></ul><table><thead><tr><th>列</th><th>说明</th></tr></thead><tbody><tr><td>Select_priv</td><td>确定用户是否可以通过SELECT命令选择数据</td></tr><tr><td>Insert_priv</td><td>确定用户是否可以通过INSERT命令插入数据</td></tr><tr><td>Update_priv</td><td>确定用户是否可以通过UPDATE命令修改现有数据</td></tr><tr><td>Delete_priv</td><td>确定用户是否可以通过DELETE命令删除现有数据</td></tr><tr><td>Create_priv</td><td>确定用户是否可以创建新的数据库和表</td></tr><tr><td>Drop_priv</td><td>确定用户是否可以删除现有数据库和表</td></tr><tr><td>Reload_priv</td><td>确定用户是否可以执行刷新和重新加载MySQL所用各种内部缓存的特定命令，包括日志、权限、主机、查询和表执行flush-hosts,flush-logs,flush-privileges,flush-status,flush-tables,flush-threads,refresh,reload等命令的而全新</td></tr><tr><td>Shutdown_priv</td><td>确定用户是否可以关闭MySQL服务器。在将此权限提供给root账户之外的任何用户时，都应当非常谨慎</td></tr><tr><td>Process_priv</td><td>确定用户是否可以通过SHOW PROCESSLIST命令查看其他用户的进程</td></tr><tr><td>File_priv</td><td>确定用户是否可以执行SELECT INTO OUTFILE和LOAD DATA INFILE命令，查看服务器主机上的文件</td></tr><tr><td>Grant_priv</td><td>确定用户是否可以将已经授予给该用户自己的权限再授予其他用户</td></tr><tr><td>References_priv</td><td>目前只是某些未来功能的占位符；现在没有作用</td></tr><tr><td>Index_priv</td><td>确定用户是否可以创建和删除表索引</td></tr><tr><td>Alter_priv</td><td>确定用户是否可以重命名和修改表结构</td></tr><tr><td>Show_db_priv</td><td>确定用户是否可以查看服务器上所有数据库的名字，包括用户拥有足够访问权限的数据库</td></tr><tr><td>Super_priv</td><td>确定用户是否可以执行某些强大的管理功能，例如通过KILL命令删除用户进程，使用SET GLOBAL修改全局MySQL变量，执行关于复制和日志的各种命令</td></tr><tr><td>Create_tmp_table_priv</td><td>确定用户是否可以创建临时表</td></tr><tr><td>Lock_tables_priv</td><td>确定用户是否可以使用LOCK TABLES命令阻止对表的访问/修改</td></tr><tr><td>Execute_priv</td><td>确定用户是否可以执行存储过程</td></tr><tr><td>Repl_slave_priv</td><td>确定用户是否可以读取用于维护复制数据库环境的二进制日志文件。此用户位于主系统中，有利于主机和客户机之间的通信</td></tr><tr><td>Repl_client_priv</td><td>确定用户是否可以确定复制从服务器和主服务器的位置</td></tr><tr><td>Create_view_priv</td><td>确定用户是否可以创建视图</td></tr><tr><td>Show_view_priv</td><td>确定用户是否可以查看视图或了解视图如何执行</td></tr><tr><td>Create_routine_priv</td><td>确定用户是否可以更改或放弃存储过程和函数</td></tr><tr><td>Alter_routine_priv</td><td>确定用户是否可以修改或删除存储函数及函数</td></tr><tr><td>Create_user_priv</td><td>确定用户是否可以执行CREATE USER命令，这个命令用于创建新的MySQL账户</td></tr><tr><td>Event_priv</td><td>确定用户能否创建、修改和删除事件</td></tr><tr><td>Trigger_priv</td><td>确定用户能否创建和删除触发器</td></tr></tbody></table><p>其他几个db、host、tables_priv、columns_priv权限表类似，可以通过desc查看字段</p><h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><h3 id="创建或更改账号"><a href="#创建或更改账号" class="headerlink" title="创建或更改账号"></a>创建或更改账号</h3><h4 id="语句命令方式"><a href="#语句命令方式" class="headerlink" title="语句命令方式"></a>语句命令方式</h4><p>有两种方法：</p><ol><li><p>使用GRANT语法创建（推荐）</p></li><li><p>直接insert，update权限表</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT 权限类型列表 </span><br><span class="line">on  object_type &#123;表名称|*|*.*|db_name.*&#125;</span><br><span class="line"> to user [identified by password ‘密码’][,user [identified by password ‘密码’] ....</span><br><span class="line">with grant option;</span><br><span class="line">其中：object_type &#x3D; TABLE | FUNCTION | PROCEDURE</span><br></pre></td></tr></table></figure><p>例1：创建用户admin，权限为可以在所有数据库上执行所有权限，但只能从本地进行连接</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO admin@localhost;</span><br></pre></td></tr></table></figure><p>可以发现除了Grant_priv权限外，所有权限在user表里面都是Y.</p><p>例2：在例1基础上，增加对admin的grant权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO admin@localhost WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><p>例3：在例2基础上，设置密码为“123”</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO admin@localhost IDENTIFIED BY &#39;123&#39; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><p>例4：创建新用户chai，可以从任何IP进行连接，权限为对test数据库的所有表进行SELECT、UPDATE、INSERT、DELETE操作，初始密码为“123”</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT SELECT,INSERT,UPDATE,DELETE ON test.* TO &#39;chai&#39;@&#39;%&#39; IDENTIFIED BY &#39;123&#39;;</span><br></pre></td></tr></table></figure><p>发现此例，user表中权限都是N，db表中增加的记录权限则都是Y。</p><p><strong>注意：</strong></p><ul><li>mysql数据库的user表中user的值为空，表示所有用户都可以连接（此处不能用<em>，</em>表示用户名为*的用户了）</li><li>mysql数据库的user表中host的值为*或空，表示所有外部IP都可以连接，但是不包括本地服务器localhost，因此如果要包括本地服务器，必须单独为localhost赋予权限。如果host的值为%，表示所有IP，包括本地服务器localhost。</li></ul><table><thead><tr><th>Host值</th><th>User值</th><th>被条目匹配的连接</th></tr></thead><tbody><tr><td>‘thomas.loc.gov’</td><td>‘fred’</td><td>fred，从thomas.loc.gov连接</td></tr><tr><td>‘thomas.loc.gov’</td><td>‘’</td><td>任何用户，从thomas.loc.gov连接</td></tr><tr><td>‘%’</td><td>‘fred’</td><td>fred，从任何主机连接</td></tr><tr><td>‘%’</td><td>‘’</td><td>任何用户，从任何主机连接</td></tr><tr><td>‘%.loc.gov’</td><td>‘fred’</td><td>fred，从在loc.gov域的任何主机连接</td></tr><tr><td>‘x.y.%’</td><td>‘fred’</td><td>fred，从在x.y.net，x.y.com等主机连</td></tr><tr><td>‘144.155.166.177’</td><td>‘fred’</td><td>fred，从144.155.166.177的IP地址连接</td></tr><tr><td>‘144.155.166.%’</td><td>‘fred’</td><td>fred，从‘144.155.166.*的C类子网的任何主机连接</td></tr></tbody></table><p>如果有多个匹配，服务器必须选择使用哪个条目，按照下述原则来解决：</p><ul><li>服务器在启动时读入user表后进行排序<ul><li>首先以最具体的host值排序，%排后面，如果host相同，以最具体的user值排序，空User值排后面。</li></ul></li><li>服务器使用与客户端和用户名匹配的第一行</li></ul><h4 id="navicat图形化界面"><a href="#navicat图形化界面" class="headerlink" title="navicat图形化界面"></a>navicat图形化界面</h4><p>1、新建用户</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql57.png" alt="mysql"></p><p>2、填写用户名、主机和密码</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql58.png" alt="mysql"></p><p>3、配use表的安全列和资源权限列的信息(0表示不限制)</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql59.png" alt="mysql"></p><p>4、选择user表的权限，这是针对所有数据库的全局权限</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql60.png" alt="mysql"></p><p>5、也可以设置单独某个数据库或某个表，或某个列的权限</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql61.png" alt="mysql"></p><h4 id="SQLyog图形化界面"><a href="#SQLyog图形化界面" class="headerlink" title="SQLyog图形化界面"></a>SQLyog图形化界面</h4><p>1、新建用户</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql62.png" alt="mysql"></p><p>2、填写用户名密码和资源权限等</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql63.png" alt="mysql"></p><p>3、全局权限</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql64.png" alt="mysql"></p><p>4、某个库或某个表等局部权限</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/mysql65.png" alt="mysql"></p><h3 id="查看账户权限"><a href="#查看账户权限" class="headerlink" title="查看账户权限"></a>查看账户权限</h3><ul><li>show grants for user@host;</li></ul><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><ul><li>drop user 用户名;</li></ul><h1 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h1><ol><li><p>在命令行出现乱码问题</p><p>按照数据库时选择utf8, 而我们在windows下窗口是GBK的,因此,需要在命令行客户端声明字符集.</p><p>set names gbk;是为了告诉服务器,客户端用的GBK编码,防止乱码.</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; set names gbk;  </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>​        可以查看字符集</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;character_set_%&#39;;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>退出当前错误语句</p><p>语句打错以后应该退出本语句,再继续打新语句.</p><p>也可以打\c,快速退出本语句.</p></li><li><p>如何破解数据库的密码？安全模式登录</p></li></ol><ul><li><p>通过任务管理器或者服务管理,关掉mysqld(服务进程)</p></li><li><p>通过命令行+特殊参数开启mysqld</p><p>mysqld –skip-grant-tables</p></li><li><p>此时,mysqld服务进程已经打开,并且,不需要权限检查.</p></li><li><p>mysql -uroot  无密码登陆服务器.</p></li><li><p>修改权限表</p><ul><li>use mysql;</li><li>update user set Password = password(‘123456’) where User = ‘root’;</li><li>flush privileges;</li></ul></li><li><p>通过任务管理器,关掉mysqld服务进程.</p></li><li><p>再次通过服务管理,打mysql服务。</p></li><li><p>即可用修改后的新密码登陆.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2020/06/28/java-design-pattern/"/>
      <url>/2020/06/28/java-design-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="模版设计模式"><a href="#模版设计模式" class="headerlink" title="模版设计模式"></a>模版设计模式</h1><p>1、当解决某个问题，或者完成某个功能时，主体的算法结构（步骤）是确定的，只是其中的一个或者几个小的步骤不确定，要有使用者（子类）来确定时，就可以使用模板设计模式</p><p>2、示例代码：计算任意一段代码的运行时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CalTime</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、获取开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start =  System.currentTimeMills();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、运行xx代码：这个是不确定的</span></span><br><span class="line">        doWork();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、获取结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end =  System.currentTimeMills();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4、计算时间差</span></span><br><span class="line">        <span class="keyword">return</span> end - start;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用模板类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCalTime</span> <span class="keyword">extends</span> <span class="title">CalTime</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//....需要计算运行时间的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyCalTime my = <span class="keyword">new</span> MyCalTime();</span><br><span class="line">        System.out.println(<span class="string">"运行时间："</span> + my.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><p>单例设计模式，是软件开发中最常用的设计模式之一，它是指某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式。例如：代表JVM运行环境的Runtime类。</p><p>通常有饿汉式和懒汉式两种。</p><h2 id="饿汉式单例设计模式"><a href="#饿汉式单例设计模式" class="headerlink" title="饿汉式单例设计模式"></a>饿汉式单例设计模式</h2><p>所谓饿汉式，就是在类初始化时，直接创建对象。</p><p>优势：因为Java的类加载和初始化的机制可以保证线程安全，所以这类形式的单例设计模式不存在线程安全问题。</p><p>劣势：不管你暂时是否需要该实例对象，都会创建，使得类初始化时间加长。</p><h3 id="直接实例化饿汉式"><a href="#直接实例化饿汉式" class="headerlink" title="直接实例化饿汉式"></a>直接实例化饿汉式</h3><p>形式一：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton1 INSTANCE = <span class="keyword">new</span> Singleton1();</span><br><span class="line"><span class="comment">//构造器私有化</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形式二：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton3 INSTANCE = <span class="keyword">new</span> Singleton3();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举式"><a href="#枚举式" class="headerlink" title="枚举式"></a>枚举式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton2 &#123;</span><br><span class="line">INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉式单例设计模式"><a href="#懒汉式单例设计模式" class="headerlink" title="懒汉式单例设计模式"></a>懒汉式单例设计模式</h2><p>所谓懒汉式：即延迟创建对象，直到用户来获取这个对象时，再创建。</p><p>优势：不用不创建，用时再创建</p><p>劣势：需要考虑线程安全问题</p><h3 id="在获取实例的方法中创建单例对象"><a href="#在获取实例的方法中创建单例对象" class="headerlink" title="在获取实例的方法中创建单例对象"></a>在获取实例的方法中创建单例对象</h3><p>方式一：线程不安全</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSingleton4</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance1;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">instance1 = Singleton4.getInstance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">instance2 = Singleton4.getInstance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">t2.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(instance1);</span><br><span class="line">System.out.println(instance2);</span><br><span class="line">    System.out.println(instance1 == instance2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：解决了线程安全</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton5 instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (Singleton5<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类形式"><a href="#静态内部类形式" class="headerlink" title="静态内部类形式"></a>静态内部类形式</h3><p>当调用getInstance()方法，才会去加载和初始化Inner类，所以是懒汉式，因为是在类初始化时创建对象，所以线程安全</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton6 INSTANCE = <span class="keyword">new</span> Singleton6();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h1><p>解决的问题：把对象的创建者与对象的使用者分离，把对象的创建统一到一个地方（工厂）</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"让你在宝马车里哭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"奔驰让你坐在引擎盖上哭"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCar</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(type)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"宝马"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BMW();</span><br><span class="line"><span class="keyword">case</span> <span class="string">"奔驰"</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Benz();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有反射：简单工厂模式的工厂类可以优化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactoryPlus</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * type：类型的全名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCar</span><span class="params">(String type)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//获取Car的实现类的Class对象</span></span><br><span class="line">Class clazz = Class.forName(type);</span><br><span class="line"><span class="comment">//创建Car的实现类的实例对象</span></span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line"><span class="comment">//强转类并返回车的实例对象</span></span><br><span class="line"><span class="keyword">return</span> (Car)obj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"让你在宝马车里哭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"奔驰让你坐在引擎盖上哭"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂的公共接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"><span class="function">Car <span class="title">getCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMWFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BMW <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BMW();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BenzFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Benz <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Benz();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态代理模式"><a href="#静态代理模式" class="headerlink" title="静态代理模式"></a>静态代理模式</h1><p>静态代理类只能替一个主题接口进行代理工作。</p><p>如果主题接口不同，代理工作相同，也需要编写两个代理类。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">TimeProxy tp = <span class="keyword">new</span> TimeProxy(<span class="keyword">new</span> GoodsDAO());</span><br><span class="line">tp.add();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">TimeProxy tp = <span class="keyword">new</span> TimeProxy(<span class="keyword">new</span> UserDAO());</span><br><span class="line">tp.add();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主题接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DAO</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodsDAO</span> <span class="keyword">implements</span> <span class="title">DAO</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"商品的添加"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserDAO</span> <span class="keyword">implements</span> <span class="title">DAO</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"用户的添加"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeProxy</span> <span class="keyword">implements</span> <span class="title">DAO</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> DAO target;<span class="comment">//target表示被代理者对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TimeProxy</span><span class="params">(DAO target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">target.add();<span class="comment">//核心业务逻辑交还给被代理者</span></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"时间差："</span> +(end-start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>步骤：</p><p>（1）主题接口</p><p>（2）被代理类</p><p>（3）动态代理的代理工作处理器</p><p>要求必须实现：java.lang.reflect.InvocationHandler接口，重写</p><p>Object invoke(Object proxy, Method method,Object[] args)</p><p>（4）创建代理类对象</p><p>java.lang.reflect.Proxy类型的静态方法</p><p>newProxyInstance(ClassLoader loader, Class[] interfaces，InvocationHandler h )</p><p>（5）调用对用的方法</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* 步骤：</span></span><br><span class="line"><span class="comment"> * 1、编写主题接口（和静态代理一样）</span></span><br><span class="line"><span class="comment"> * 2、编写被代理类（和静态代理一样）</span></span><br><span class="line"><span class="comment"> * 3、编写代理工作处理器：即代理类要替被代理类做什么事情</span></span><br><span class="line"><span class="comment"> * 要求：必须实现InvocationHandler，重写</span></span><br><span class="line"><span class="comment"> *   Object invoke(Object proxy, Method method, Object[] args)</span></span><br><span class="line"><span class="comment"> *   第一个参数：代理类对象</span></span><br><span class="line"><span class="comment"> *   第二个参数：被代理类和代理类   要执行的方法</span></span><br><span class="line"><span class="comment"> *   第三个参数：要执行方法的实参列表</span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> *   这个invoke方法不是程序员调用，当代理类对象执行对应的代理方法时，自动调用的</span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> * 4、创建代理类及其对象</span></span><br><span class="line"><span class="comment"> *   需要：Proxy：提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类。</span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> *    static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) </span></span><br><span class="line"><span class="comment"> *    第一个参数：被代理类的类加载器，我们希望被代理和代理类使用同一个类加载器</span></span><br><span class="line"><span class="comment"> *    第二个参数：被代理类实现的接口们</span></span><br><span class="line"><span class="comment"> *    第三个参数：代理工作处理器对象</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> * 5、调用被代理的方法   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy2</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//被代理对象</span></span><br><span class="line">YongHuDAO sd = <span class="keyword">new</span> YongHuDAO();</span><br><span class="line"></span><br><span class="line">ClassLoader loader = sd.getClass().getClassLoader();<span class="comment">//被代理者的类加载器对象</span></span><br><span class="line">Class&lt;?&gt;[] interfaces = sd.getClass().getInterfaces();<span class="comment">//被代理者实现的接口们</span></span><br><span class="line">TimeInvocationHandler h = <span class="keyword">new</span> TimeInvocationHandler(sd);<span class="comment">//代理工作处理器对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建代理类及其对象</span></span><br><span class="line"><span class="comment">//proxy是代理类的对象，代理类是编译器自动编译生成的一个类</span></span><br><span class="line">Object proxy = Proxy.newProxyInstance(loader, interfaces, h);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里强转的目的是为了调用增、删、改、查的方法</span></span><br><span class="line"><span class="comment">//为什么这里强转可以成功了，因为代理类与被代理类实现了相同的主题接口</span></span><br><span class="line">DBDAO d = (DBDAO) proxy;</span><br><span class="line">d.add();</span><br><span class="line">d.update();</span><br><span class="line">d.delete();</span><br><span class="line">d.select();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//被代理对象</span></span><br><span class="line">ShangPinDAO sd = <span class="keyword">new</span> ShangPinDAO();</span><br><span class="line"></span><br><span class="line">ClassLoader loader = sd.getClass().getClassLoader();</span><br><span class="line">Class&lt;?&gt;[] interfaces = sd.getClass().getInterfaces();</span><br><span class="line">TimeInvocationHandler h = <span class="keyword">new</span> TimeInvocationHandler(sd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建代理类及其对象</span></span><br><span class="line"><span class="comment">//proxy是代理类的对象，代理类是编译器自动编译生成的一个类</span></span><br><span class="line">Object proxy = Proxy.newProxyInstance(loader, interfaces, h);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里强转的目的是为了调用增、删、改、查的方法</span></span><br><span class="line"><span class="comment">//为什么这里强转可以成功了，因为代理类与被代理类实现了相同的主题接口</span></span><br><span class="line">DBDAO d = (DBDAO) proxy;</span><br><span class="line">d.add();</span><br><span class="line">d.update();</span><br><span class="line">d.delete();</span><br><span class="line">d.select();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理工作处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Object target;<span class="comment">//被代理对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TimeInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理对象的xx方法被调用</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 没有反射：  被代理对象.xx方法(args实参列表)</span></span><br><span class="line"><span class="comment"> * 有了反射：  方法对象.invoke(被代理对象，args实参列表)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object returnValue = method.invoke(target, args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(method.getName() + <span class="string">"方法运行时间："</span> + (end-start));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//主题接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DBDAO</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理类1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShangPinDAO</span> <span class="keyword">implements</span> <span class="title">DBDAO</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"添加商品"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"修改商品"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"删除商品"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"查询商品"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理类2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YongHuDAO</span> <span class="keyword">implements</span> <span class="title">DBDAO</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"添加用户"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"修改用户"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"删除用户"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"查询用户"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式与StreamAPI</title>
      <link href="/2020/06/27/java-lambda/"/>
      <url>/2020/06/27/java-lambda/</url>
      
        <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>Lambda表达式不是Java最早使用的，很多语言就支持Lambda表达式，例如：C++，C#，Python，Scala等。如果有Python或者Javascript的语言基础，对理解Lambda表达式有很大帮助，可以这么说lambda表达式其实就是实现SAM接口的语法糖，使得Java也算是支持函数式编程的语言。Lambda<strong>写的好</strong>可以极大的减少代码冗余，同时可读性也好过冗长的匿名内部类。</p><h2 id="Lambda表达式引入"><a href="#Lambda表达式引入" class="headerlink" title="Lambda表达式引入"></a>Lambda表达式引入</h2><h3 id="示例1：Runnable实现线程"><a href="#示例1：Runnable实现线程" class="headerlink" title="示例1：Runnable实现线程"></a>示例1：Runnable实现线程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"do something.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"do something.."</span>)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例2：foreach遍历"><a href="#示例2：foreach遍历" class="headerlink" title="示例2：foreach遍历"></a>示例2：foreach遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">  List&lt;String&gt; list = Arrays.asList(<span class="string">"hello"</span>,<span class="string">"java"</span>,<span class="string">"atguigu"</span>,<span class="string">"lambda"</span>);</span><br><span class="line">  <span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">  List&lt;String&gt; list = Arrays.asList(<span class="string">"hello"</span>,<span class="string">"java"</span>,<span class="string">"atguigu"</span>,<span class="string">"lambda"</span>);</span><br><span class="line">  list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例3：FileFilter文件过滤"><a href="#示例3：FileFilter文件过滤" class="headerlink" title="示例3：FileFilter文件过滤"></a>示例3：FileFilter文件过滤</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//1.文件目录</span></span><br><span class="line">  File fileDir=<span class="keyword">new</span> File(<span class="string">"D:/resource"</span>);</span><br><span class="line">  <span class="comment">//2.创建筛选规则，帅选出所有.java文件</span></span><br><span class="line">  FileFilter filter=<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!file.isDirectory()&amp;&amp;file.getName().endsWith(<span class="string">".java"</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//3.得到筛选文件</span></span><br><span class="line">  File[] files=fileDir.listFiles(filter);</span><br><span class="line">  <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">    System.out.println(file);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//1.文件目录</span></span><br><span class="line">  File fileDir=<span class="keyword">new</span> File(<span class="string">"D:/resource"</span>);</span><br><span class="line">  <span class="comment">//2.得到筛选文件，帅选出所有.java文件</span></span><br><span class="line">  File[] files=fileDir.listFiles((file) -&gt;  !file.isDirectory() &amp;&amp; file.getName().endsWith(<span class="string">".java"</span>));</span><br><span class="line">  <span class="comment">//3、遍历查看结果</span></span><br><span class="line">  Arrays.asList(files).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数式接口概念"><a href="#函数式接口概念" class="headerlink" title="函数式接口概念"></a>函数式接口概念</h2><p>Lambda表达式是用来实现SAM接口的，所谓SAM接口就是Single Abstract Method，即该接口中只有一个抽象方法需要实现，当然该接口可以包含其他非抽象方法。</p><p>其实只要满足“SAM”特征的接口都可以称为函数式接口，但是如果要更明确一点，最好在声明接口时，加上@FunctionalInterface。</p><p>JDK1.8之前，核心类库中就已经存在很多SAM接口了，例如：</p><ol><li><p>java.lang.Runnable</p></li><li><p>java.util.concurrent.Callable</p></li><li><p>java.util.Comparator</p></li><li><p>java.lang.Comparable</p></li><li><p>java.lang.Iterable</p></li><li><p>java.io.FileFilter</p></li><li><p>java.lang.reflect.InvocationHandler</p><p>……等</p></li></ol><p>但是在JDK1.8，只有（1）（2）（3）（6）加了@FunctionalInterface，那些没有加@FunctionalInterface的SAM接口，现在使用Lambda表达式实现，但是存在将来增加抽象方法变成非SAM接口的风险，因此建议只对加了@FunctionalInterface的接口使用Lambda表达式实现。</p><p>JDK1.8在java.util.function包增加了很多函数式接口，不过他们可以归纳为四类：消费型接口、供给型接口、功能型接口、判断型接口，一共43个，基本上可以满足开发中函数式接口的基本使用需求，如你在开发中需要设计函数式接口，请先从以下接口中选择是否有满足需求的，如果有几不需要重新设计了。</p><h3 id="消费型接口"><a href="#消费型接口" class="headerlink" title="消费型接口"></a>消费型接口</h3><p>这类接口的抽象方法特点：有形参，但是返回值类型是void</p><table><thead><tr><th>接口名</th><th>抽象方法</th><th>描述</th></tr></thead><tbody><tr><td>Consumer<T></td><td>void accept(T t)</td><td>接收一个对象用于完成功能</td></tr><tr><td>BiConsumer&lt;T,U&gt;</td><td>void accept(T t, U u)</td><td>接收两个对象用于完成功能</td></tr><tr><td>DoubleConsumer</td><td>void accept(double value)</td><td>接收一个double值</td></tr><tr><td>IntConsumer</td><td>void accept(int value)</td><td>接收一个int值</td></tr><tr><td>LongConsumer</td><td>void accept(long value)</td><td>接收一个long值</td></tr><tr><td>ObjDoubleConsumer<T></td><td>void accept(T t, double value)</td><td>接收一个对象和一个double值</td></tr><tr><td>ObjIntConsumer<T></td><td>void accept(T t, int value)</td><td>接收一个对象和一个int值</td></tr><tr><td>ObjLongConsumer<T></td><td>void accept(T t, long value)</td><td>接收一个对象和一个long值</td></tr></tbody></table><h3 id="供给型接口"><a href="#供给型接口" class="headerlink" title="供给型接口"></a>供给型接口</h3><p>这类接口的抽象方法特点：无参，但是无返回值</p><table><thead><tr><th>接口名</th><th>抽象方法</th><th>描述</th></tr></thead><tbody><tr><td>Supplier<T></td><td>T get()</td><td>返回一个对象</td></tr><tr><td>BooleanSupplier</td><td>boolean getAsBoolean()</td><td>返回一个boolean值</td></tr><tr><td>DoubleSupplier</td><td>double getAsDouble()</td><td>返回一个double值</td></tr><tr><td>IntSupplier</td><td>int getAsInt()</td><td>返回一个int值</td></tr><tr><td>LongSupplier</td><td>long getAsLong()</td><td>返回一个long值</td></tr></tbody></table><h3 id="判断型接口"><a href="#判断型接口" class="headerlink" title="判断型接口"></a>判断型接口</h3><p>这里接口的抽象方法特点：有参，但是返回值类型是boolean结果。</p><table><thead><tr><th>接口名</th><th>抽象方法</th><th>描述</th></tr></thead><tbody><tr><td>Predicate<T></td><td>boolean test(T t)</td><td>接收一个对象</td></tr><tr><td>BiPredicate&lt;T,U&gt;</td><td>boolean test(T t, U u)</td><td>接收两个对象</td></tr><tr><td>DoublePredicate</td><td>boolean test(double value)</td><td>接收一个double值</td></tr><tr><td>IntPredicate</td><td>boolean test(int value)</td><td>接收一个int值</td></tr><tr><td>LongPredicate</td><td>boolean test(long value)</td><td>接收一个long值</td></tr></tbody></table><h3 id="功能型接口"><a href="#功能型接口" class="headerlink" title="功能型接口"></a>功能型接口</h3><p>这类接口的抽象方法特点：既有参数又有返回值</p><table><thead><tr><th>接口名</th><th>抽象方法</th><th>描述</th></tr></thead><tbody><tr><td>Function&lt;T,R&gt;</td><td>R apply(T t)</td><td>接收一个T类型对象，返回一个R类型对象结果</td></tr><tr><td>UnaryOperator<T></td><td>T apply(T t)</td><td>接收一个T类型对象，返回一个T类型对象结果</td></tr><tr><td>DoubleFunction<R></td><td>R apply(double value)</td><td>接收一个double值，返回一个R类型对象</td></tr><tr><td>IntFunction<R></td><td>R apply(int value)</td><td>接收一个int值，返回一个R类型对象</td></tr><tr><td>LongFunction<R></td><td>R apply(long value)</td><td>接收一个long值，返回一个R类型对象</td></tr><tr><td>ToDoubleFunction<T></td><td>double applyAsDouble(T value)</td><td>接收一个T类型对象，返回一个double</td></tr><tr><td>ToIntFunction<T></td><td>int applyAsInt(T value)</td><td>接收一个T类型对象，返回一个int</td></tr><tr><td>ToLongFunction<T></td><td>long applyAsLong(T value)</td><td>接收一个T类型对象，返回一个long</td></tr><tr><td>DoubleToIntFunction</td><td>int applyAsInt(double value)</td><td>接收一个double值，返回一个int结果</td></tr><tr><td>DoubleToLongFunction</td><td>long applyAsLong(double value)</td><td>接收一个double值，返回一个long结果</td></tr><tr><td>IntToDoubleFunction</td><td>double applyAsDouble(int value)</td><td>接收一个int值，返回一个double结果</td></tr><tr><td>IntToLongFunction</td><td>long applyAsLong(int value)</td><td>接收一个int值，返回一个long结果</td></tr><tr><td>LongToDoubleFunction</td><td>double applyAsDouble(long value)</td><td>接收一个long值，返回一个double结果</td></tr><tr><td>LongToIntFunction</td><td>int applyAsInt(long value)</td><td>接收一个long值，返回一个int结果</td></tr><tr><td>DoubleUnaryOperator</td><td>double applyAsDouble(double operand)</td><td>接收一个double值，返回一个double</td></tr><tr><td>IntUnaryOperator</td><td>int applyAsInt(int operand)</td><td>接收一个int值，返回一个int结果</td></tr><tr><td>LongUnaryOperator</td><td>long applyAsLong(long operand)</td><td>接收一个long值，返回一个long结果</td></tr><tr><td>BiFunction&lt;T,U,R&gt;</td><td>R apply(T t, U u)</td><td>接收一个T类型和一个U类型对象，返回一个R类型对象结果</td></tr><tr><td>BinaryOperator<T></td><td>T apply(T t, T u)</td><td>接收两个T类型对象，返回一个T类型对象结果</td></tr><tr><td>ToDoubleBiFunction&lt;T,U&gt;</td><td>double applyAsDouble(T t, U u)</td><td>接收一个T类型和一个U类型对象，返回一个double</td></tr><tr><td>ToIntBiFunction&lt;T,U&gt;</td><td>int applyAsInt(T t, U u)</td><td>接收一个T类型和一个U类型对象，返回一个int</td></tr><tr><td>ToLongBiFunction&lt;T,U&gt;</td><td>long applyAsLong(T t, U u)</td><td>接收一个T类型和一个U类型对象，返回一个long</td></tr><tr><td>DoubleBinaryOperator</td><td>double applyAsDouble(double left, double right)</td><td>接收两个double值，返回一个double结果</td></tr><tr><td>IntBinaryOperator</td><td>int applyAsInt(int left, int right)</td><td>接收两个int值，返回一个int结果</td></tr><tr><td>LongBinaryOperator</td><td>long applyAsLong(long left, long right)</td><td>接收两个long值，返回一个long结果</td></tr></tbody></table><h2 id="Lambda表达式-1"><a href="#Lambda表达式-1" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式是用来实现SAM接口的，它相当于一个匿名函数，语法格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(Type1 param1, Type2 param2, ..., TypeN paramN) -&gt; &#123;</span><br><span class="line">  statment1;</span><br><span class="line">  statment2;</span><br><span class="line">  <span class="comment">//.............</span></span><br><span class="line">  <span class="keyword">return</span> statmentM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的说就是：</p><blockquote><p>(形参列表) -&gt; {Lambda体}</p></blockquote><p>这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符或箭头操作符。它将 Lambda 分为两个部分：</p><ol><li><p>左侧：指定了 Lambda 表达式需要的参数列表，它其实就是函数式接口的抽象方法的形参列表</p></li><li><p>右侧：指定了 Lambda 体，即 Lambda 表达式要执行的功能，它其实就是实现函数式接口的抽象方法的方法体。</p></li></ol><p>例如：Lambda表达式只写了Runnable接口的抽象方法public void run()的()空参列表以及对run()方法的实现代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"do something.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"do something.."</span>)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>格式要求：</strong></p><ol><li>关于(形参列表)</li></ol><ul><li><p>如果没有形参，那么()不可以省略；</p></li><li><p>如果有形参，并且形参只有一个，并且形参类型已知或可推断，那么可以省略()和数据类型，只写形参名；</p></li><li><p>如果形参不止一个，那么()不可以省略，但是如果形参类型已知或可推断，那么可以数据类型。</p></li></ul><ol start="2"><li>关系{Lambda体}</li></ol><ul><li>如果函数式接口的抽象方法有返回值，即返回值类型不是void，那么Lambda体必须要有“return 返回值;”语句；</li><li>如果{Lambda体}只有一个语句，那么{}可以省略，如果{}省略了，那么语句后面的;也要省略，如果{Lambda体}只有一个return 返回值;语句，那么{return;}都可以省略，Lambda体只写返回值即可。</li></ul><h3 id="形式一：无参无返回值"><a href="#形式一：无参无返回值" class="headerlink" title="形式一：无参无返回值"></a>形式一：无参无返回值</h3><p>代码示例：Runnable函数式接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda1</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//不使用Lambda表达式</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something.."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用Lambda表达式</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;System.out.println(<span class="string">"do something.."</span>);&#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//省略了可以省略的部分</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"do something.."</span>)).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="形式二：有参无返回值"><a href="#形式二：有参无返回值" class="headerlink" title="形式二：有参无返回值"></a>形式二：有参无返回值</h3><p>代码示例：Consumer<T>接口</p><p>在JDK1.8中Collection集合接口的父接口Iterable接口中增加了一个默认方法：</p><ul><li>default void forEach(Consumer&lt;? super T&gt; action)     遍历Collection集合的每个元素，执行“xxx消费型”操作。</li></ul><p>在JDK1.8中Map集合接口中增加了一个默认方法：</p><ul><li>default void forEach(BiConsumer&lt;? super K,? super V&gt; action)    遍历Map集合的每对映射关系，执行“xxx消费型”操作。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda2</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//不使用Lambda表达式</span></span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">"hello"</span>,<span class="string">"java"</span>,<span class="string">"lambda"</span>,<span class="string">"lambda"</span>);</span><br><span class="line">    <span class="keyword">for</span> (String string : list) &#123;</span><br><span class="line">      System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">"hello"</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">"java"</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">"lambda"</span>);</span><br><span class="line">    map.put(<span class="number">4</span>, <span class="string">"lambda"</span>);</span><br><span class="line">    Set&lt;Entry&lt;Integer, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Integer, String&gt; entry : entrySet) &#123;</span><br><span class="line">      System.out.println(entry.getKey() + <span class="string">"-&gt;"</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用Lambda表达式</span></span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">"hello"</span>,<span class="string">"java"</span>,<span class="string">"lambda"</span>,<span class="string">"haha"</span>);</span><br><span class="line">    list.forEach((String s) -&gt; &#123;System.out.println(s);&#125;);</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">"hello"</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">"java"</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">"lambda"</span>);</span><br><span class="line">    map.put(<span class="number">4</span>, <span class="string">"haha"</span>);</span><br><span class="line">    map.forEach((Integer k,String v) -&gt; &#123;System.out.println(k+<span class="string">"-&gt;"</span>+v);&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//省略了可以省略的部分</span></span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">"hello"</span>,<span class="string">"java"</span>,<span class="string">"lambda"</span>,<span class="string">"haha"</span>);</span><br><span class="line">    list.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">"hello"</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">"java"</span>);</span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">"lambda"</span>);</span><br><span class="line">    map.put(<span class="number">4</span>, <span class="string">"haha"</span>);</span><br><span class="line">    map.forEach((k,v) -&gt; System.out.println(k+<span class="string">"-&gt;"</span>+v));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="形式三：无参有返回值"><a href="#形式三：无参有返回值" class="headerlink" title="形式三：无参有返回值"></a>形式三：无参有返回值</h3><p>代码示例：Supplier<T>接口</p><p>在JDK1.8中增加了StreamAPI，Stream是一个数据流，一个不同于集合的数据流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda3</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用Lambda表达式</span></span><br><span class="line">    Stream&lt;Double&gt; stream = Stream.generate(() -&gt; &#123;<span class="keyword">return</span> Math.random();&#125;);</span><br><span class="line">    stream.forEach((Double num) -&gt; &#123;System.out.println(num);&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//省略了可以省略的部分</span></span><br><span class="line">    Stream&lt;Double&gt; stream = Stream.generate(() -&gt; Math.random());</span><br><span class="line">    stream.forEach(num -&gt; System.out.println(num));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="形式四：有参有返回值"><a href="#形式四：有参有返回值" class="headerlink" title="形式四：有参有返回值"></a>形式四：有参有返回值</h3><p>代码示例：Funtion&lt;T,R&gt;接口</p><p>在JDK1.8时Map接口增加了很多方法，其中一个是：</p><ul><li>default void replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)     按照function指定的操作替换map中的value。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda4</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HashMap&lt;String,Employee&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"张三"</span>, <span class="keyword">new</span> Employee(<span class="string">"张三"</span>, <span class="number">8000</span>));</span><br><span class="line">    map.put(<span class="string">"李四"</span>, <span class="keyword">new</span> Employee(<span class="string">"李四"</span>, <span class="number">9000</span>));</span><br><span class="line">    map.put(<span class="string">"王五"</span>, <span class="keyword">new</span> Employee(<span class="string">"王五"</span>, <span class="number">12000</span>));</span><br><span class="line">    map.put(<span class="string">"赵六"</span>, <span class="keyword">new</span> Employee(<span class="string">"赵六"</span>, <span class="number">11000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把薪资低于10000的工资修改为10000</span></span><br><span class="line">    map.replaceAll((String k,Employee v) -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>(v.getSalary()&lt;<span class="number">10000</span>)&#123;</span><br><span class="line">        v.setSalary(<span class="number">10000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">    &#125;);</span><br><span class="line">    map.forEach((String k, Employee v) -&gt; &#123;System.out.println(k+<span class="string">"-&gt;"</span>+v);&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HashMap&lt;String,Employee&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"张三"</span>, <span class="keyword">new</span> Employee(<span class="string">"张三"</span>, <span class="number">8000</span>));</span><br><span class="line">    map.put(<span class="string">"李四"</span>, <span class="keyword">new</span> Employee(<span class="string">"李四"</span>, <span class="number">9000</span>));</span><br><span class="line">    map.put(<span class="string">"王五"</span>, <span class="keyword">new</span> Employee(<span class="string">"王五"</span>, <span class="number">12000</span>));</span><br><span class="line">    map.put(<span class="string">"赵六"</span>, <span class="keyword">new</span> Employee(<span class="string">"赵六"</span>, <span class="number">11000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把薪资低于10000的工资修改为10000</span></span><br><span class="line">    <span class="comment">//省略了可省略部分</span></span><br><span class="line">    map.replaceAll((k,v) -&gt; &#123;<span class="keyword">if</span>(v.getSalary()&lt;<span class="number">10000</span>)v.setSalary(<span class="number">10000</span>);<span class="keyword">return</span> v;&#125;);</span><br><span class="line">    map.forEach((k, v) -&gt; System.out.println(k+<span class="string">"-&gt;"</span>+v));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.salary = salary;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> salary;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.salary = salary;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Employee [name="</span> + name + <span class="string">", salary="</span> + salary + <span class="string">"]"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码示例：Predicate<T>接口</p><p>JDK1.8时，Collecton<E>接口增加了一下方法，其中一个如下：</p><ul><li>default boolean removeIf(Predicate&lt;? super E&gt; filter)     用于删除集合中满足filter指定的条件判断的。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ArrayList&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"张三"</span>, <span class="number">8000</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"李四"</span>, <span class="number">9000</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"王五"</span>, <span class="number">12000</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"赵六"</span>, <span class="number">11000</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//删除那些薪资低于10000的</span></span><br><span class="line">  list.removeIf((Employee e) -&gt; &#123;<span class="keyword">return</span> e.getSalary()&gt;<span class="number">10000</span>;&#125;);</span><br><span class="line">  list.forEach((Employee e) -&gt; &#123;System.out.println(e);&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ArrayList&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"张三"</span>, <span class="number">8000</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"李四"</span>, <span class="number">9000</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"王五"</span>, <span class="number">12000</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"赵六"</span>, <span class="number">11000</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//删除那些薪资低于10000的</span></span><br><span class="line">  <span class="comment">//省略了可以省略的部分</span></span><br><span class="line">  list.removeIf(e -&gt; e.getSalary()&gt;<span class="number">10000</span>);</span><br><span class="line">  list.forEach(e -&gt; System.out.println(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法引用和构造器引用"><a href="#方法引用和构造器引用" class="headerlink" title="方法引用和构造器引用"></a>方法引用和构造器引用</h2><p>当Lambda体的实现是通过调用一个现有的方法来完成功能时，那么可以考虑再次简化代码，使用方法引用和构造器引用。</p><p>此时要求函数式接口的抽象方法的形参列表与返回值类型与该方法的形参列表与返回值类型要对应。</p><p><strong>方法引用的语法格式：</strong></p><blockquote><p>类或对象：：方法名</p></blockquote><p><strong>构造器引用的语法格式：</strong></p><blockquote><p>类名或数组类型：：new</p></blockquote><h3 id="对象-实例方法名"><a href="#对象-实例方法名" class="headerlink" title="对象::实例方法名"></a>对象::实例方法名</h3><p>例如Consumer<T>的抽象方法void accept(T t)，它的Lambda体是通过调用System.out.println(x)来完成，它们都是有参无返回值。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  List&lt;String&gt; list = Arrays.asList(<span class="string">"hello"</span>,<span class="string">"java"</span>,<span class="string">"lambda"</span>,<span class="string">"atguigu"</span>);</span><br><span class="line">  <span class="comment">//使用Lambda表达式</span></span><br><span class="line">  list.forEach(e -&gt; System.out.println(e));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  List&lt;String&gt; list = Arrays.asList(<span class="string">"hello"</span>,<span class="string">"java"</span>,<span class="string">"lambda"</span>,<span class="string">"atguigu"</span>);</span><br><span class="line">  <span class="comment">//使用方法引用</span></span><br><span class="line">  list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：Comparator<T>接口的抽象方法int compare(T t1,T  t2)，它的Lambda体是通过调用Collator文本校对器对象的compare(t1,t2)方法来完成，他们的形参列表和返回值类型完成可以对上。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//使用Lambda表达式</span></span><br><span class="line">  TreeSet&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;((t1,t2) -&gt; Collator.getInstance().compare(t1, t2));</span><br><span class="line">  set.add(<span class="string">"张三"</span>);</span><br><span class="line">  set.add(<span class="string">"李四"</span>);</span><br><span class="line">  set.add(<span class="string">"王五"</span>);</span><br><span class="line">  set.add(<span class="string">"赵六"</span>);</span><br><span class="line">  set.forEach(e -&gt; System.out.println(e));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//使用方法引用</span></span><br><span class="line">  TreeSet&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;(Collator.getInstance()::compare);</span><br><span class="line">  set.add(<span class="string">"张三"</span>);</span><br><span class="line">  set.add(<span class="string">"李四"</span>);</span><br><span class="line">  set.add(<span class="string">"王五"</span>);</span><br><span class="line">  set.add(<span class="string">"赵六"</span>);</span><br><span class="line">  set.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类-静态方法名"><a href="#类-静态方法名" class="headerlink" title="类::静态方法名"></a>类::静态方法名</h3><p>例如：Supplier<T>的抽象方法T get()，它的lambda体是通过调用Math.random()来完成的，它们都是无参有返回值。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//使用Lambda表达式</span></span><br><span class="line">  Stream&lt;Double&gt; stream = Stream.generate(() -&gt; Math.random());</span><br><span class="line">  stream.forEach(num -&gt; System.out.println(num));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//使用方法引用</span></span><br><span class="line">  Stream&lt;Double&gt; stream = Stream.generate(Math::random);</span><br><span class="line">  stream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类-实例方法名"><a href="#类-实例方法名" class="headerlink" title="类::实例方法名"></a>类::实例方法名</h3><p>例如：Comparator<T>接口的抽象方法int compare(T t1,T  t2)，它的Lambda体是通过调用String对象的compareToIgnoreCase(String o)来完成的，而且这里调用compareToIgnoreCase方法是用compare()方法的第一个参数，而compare()方法剩下的参数正好是给compareToIgnoreCase的实参，它俩的返回值类型都是int。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String[] arr = &#123;<span class="string">"Hello"</span>,<span class="string">"hello"</span>,<span class="string">"abc"</span>,<span class="string">"world"</span>,<span class="string">"ABC"</span>&#125;;</span><br><span class="line">  <span class="comment">//使用generate</span></span><br><span class="line">  Arrays.sort(arr, (s1,s2)-&gt; s1.compareToIgnoreCase(s2));</span><br><span class="line">  System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String[] arr = &#123;<span class="string">"Hello"</span>,<span class="string">"hello"</span>,<span class="string">"abc"</span>,<span class="string">"world"</span>,<span class="string">"ABC"</span>&#125;;</span><br><span class="line">  <span class="comment">//使用方法引用</span></span><br><span class="line">  Arrays.sort(arr, String::compareToIgnoreCase);</span><br><span class="line">  System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类名-new"><a href="#类名-new" class="headerlink" title="类名::new"></a>类名::new</h3><p>例如：在JDK1.8中增加了一个工具类Optional<T>，它是一个容器，可以用来包装一个对象，如果所包装的对象不为null，那么通过get()方法可以获取到这个对象，如果所包装的对象是null，调用get()方法会报异常，所以很多时候需要通过调用orElseGet(Supplier&lt;? extends T&gt; other) 来获取，即如果该对象存在，就返回该对象，否则返回由Supplier接口实现所提供的对象。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span>&#123;</span><br><span class="line">  HashMap&lt;String,Employee&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  map.put(<span class="string">"张三"</span>, <span class="keyword">new</span> Employee(<span class="string">"张三"</span>, <span class="number">8000</span>));</span><br><span class="line">  map.put(<span class="string">"李四"</span>, <span class="keyword">new</span> Employee(<span class="string">"李四"</span>, <span class="number">9000</span>));</span><br><span class="line"></span><br><span class="line">  Optional&lt;Employee&gt; opt = Optional.ofNullable(map.get(<span class="string">"王五"</span>));</span><br><span class="line">  <span class="comment">//使用Lambda表达式</span></span><br><span class="line">  Employee emp = opt.orElseGet(() -&gt; <span class="keyword">new</span> Employee());</span><br><span class="line">  System.out.println(emp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span></span>&#123;</span><br><span class="line">  HashMap&lt;String,Employee&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  map.put(<span class="string">"张三"</span>, <span class="keyword">new</span> Employee(<span class="string">"张三"</span>, <span class="number">8000</span>));</span><br><span class="line">  map.put(<span class="string">"李四"</span>, <span class="keyword">new</span> Employee(<span class="string">"李四"</span>, <span class="number">9000</span>));</span><br><span class="line"></span><br><span class="line">  Optional&lt;Employee&gt; opt = Optional.ofNullable(map.get(<span class="string">"王五"</span>));</span><br><span class="line">  <span class="comment">//使用构造器引用</span></span><br><span class="line">  Employee emp = opt.orElseGet(Employee::<span class="keyword">new</span>);</span><br><span class="line">  System.out.println(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组类型-new"><a href="#数组类型-new" class="headerlink" title="数组类型::new"></a>数组类型::new</h3><p>例如：我声明了一个工具方法createArray，用于创建一个长度为2的幂次方的数组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; R[] createArray(Function&lt;Integer,R[]&gt; fun,<span class="keyword">int</span> length)&#123;</span><br><span class="line">  <span class="keyword">int</span> n = length - <span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">  length = n &lt; <span class="number">0</span> ? <span class="number">1</span> : n + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> fun.apply(length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//使用Lambda表达式</span></span><br><span class="line">  Object[] arr1 = createArray(len -&gt; <span class="keyword">new</span> Object[len], <span class="number">5</span>);</span><br><span class="line">  System.out.println(arr1.length);</span><br><span class="line">  <span class="comment">//使用构造器引用</span></span><br><span class="line">  Object[] arr2 = createArray(Object[]::<span class="keyword">new</span>, <span class="number">5</span>);</span><br><span class="line">  System.out.println(arr2.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h1><p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</p><p>Optional实际上是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p><p><strong>创建Optional类对象的方法：</strong></p><ul><li><p>Optional.of(T t) : 创建一个 Optional 实例，t必须非空；</p></li><li><p>Optional.empty() : 创建一个空的 Optional 实例</p></li><li><p>Optional.ofNullable(T t)：t可以为null</p></li></ul><p><strong>判断Optional容器中是否包含对象：</strong></p><ul><li>boolean isPresent() : 判断是否包含对象</li><li>void ifPresent(Consumer&lt;? super T&gt; consumer) ：如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它。</li></ul><p><strong>获取Optional容器的对象：</strong></p><ul><li>T get(): 如果调用对象包含值，返回该值，否则抛异常</li><li>T orElse(T other) ：如果有值则将其返回，否则返回指定的other对象。</li><li>T orElseGet(Supplier&lt;? extends T&gt; other) ：如果有值则将其返回，否则返回由Supplier接口实现提供的对象。</li><li>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) ：如果有值则将其返回，否则抛出由Supplier接口实现提供的异常。</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Boy b = <span class="keyword">new</span> Boy(<span class="string">"张三"</span>);</span><br><span class="line">  Optional&lt;Girl&gt; opt = Optional.ofNullable(b.getGrilFriend());</span><br><span class="line">  <span class="comment">//如果女朋友存在就打印女朋友的信息</span></span><br><span class="line">  opt.ifPresent(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Boy b = <span class="keyword">new</span> Boy(<span class="string">"张三"</span>);</span><br><span class="line">  Optional&lt;Girl&gt; opt = Optional.ofNullable(b.getGrilFriend());</span><br><span class="line">  <span class="comment">//如果有女朋友就返回他的女朋友，否则只能欣赏“嫦娥”了</span></span><br><span class="line">  Girl girl = opt.orElse(<span class="keyword">new</span> Girl(<span class="string">"嫦娥"</span>));</span><br><span class="line">  System.out.println(<span class="string">"他的女朋友是："</span> + girl.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对Optional中的对象进行xx操作：</strong></p><ul><li>Optional<T> filter(Predicate&lt;? super T&gt; predicate) ：如果有值，就判断该值是否满足predicate的条件，否则返回空的Optional。</li><li>Optional<U> map(Function&lt;? super T,? extends U&gt; mapper) ：如果有值，对该值执行Function接口的实现代码，并返回一个Optional的结果，否则报空指针异常。</li><li>Optional<U> flatMap(Function&lt;? super T,Optional<U>&gt; mapper) ：如果有值，对该值执行Function接口的实现代码，并返回一个Optional的结果，否则报空指针异常。该方法和map方法的区别是，map方法的Function接口的实现不负责把结果包装为Optional对象，该操作由map方法自己完成，而flatMap方法的Function接口的实现直接把结果包装为Optional对象了，flatMap方法不需要再次包装了。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Optional&lt;Employee&gt; opt = Optional.of(<span class="keyword">new</span> Employee(<span class="string">"张三"</span>, <span class="number">8888</span>));</span><br><span class="line">  <span class="comment">//判断opt中员工对象是否满足条件，如果满足就保留，否则返回空</span></span><br><span class="line">  Optional&lt;Employee&gt; emp = opt.filter(e -&gt; e.getSalary()&gt;<span class="number">10000</span>);</span><br><span class="line">  System.out.println(emp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Optional&lt;Employee&gt; opt = Optional.of(<span class="keyword">new</span> Employee(<span class="string">"张三"</span>, <span class="number">8888</span>));</span><br><span class="line">  <span class="comment">//如果opt中员工对象不为空，就涨薪10%</span></span><br><span class="line">  Optional&lt;Employee&gt; emp = opt.map(e -&gt; &#123;e.setSalary(e.getSalary()%<span class="number">1.1</span>);<span class="keyword">return</span> e;&#125;);</span><br><span class="line">  System.out.println(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h1><p>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API。</p><p>Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p><p>例如：在处理集合时，我们通常会迭代遍历它的元素，并在每个元素上执行某项操作。</p><p>Stream是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。“集合讲的是数据，负责存储数据，Stream流讲的是计算，负责处理数据！”</p><p><strong>注意：</strong></p><ul><li><p>Stream 自己不会存储元素。</p></li><li><p>Stream 不会改变源对象。每次处理都会返回一个持有结果的新Stream。</p></li><li><p>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p></li></ul><p><strong>Stream 的操作三个步骤：</strong></p><ol><li>创建 Stream：通过一个数据源（如：集合、数组），获取一个流</li><li>中间操作：中间操作是个操作链，对数据源的数据进行n次处理，但是在终结操作前，并不会真正执行。</li><li>终止操作：一旦执行终止操作，就执行中间操作链，最终产生结果并结束Stream。</li></ol><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/stream.png" alt="stream"></p><h2 id="创建Stream流"><a href="#创建Stream流" class="headerlink" title="创建Stream流"></a>创建Stream流</h2><h3 id="创建-Stream方式一：通过集合"><a href="#创建-Stream方式一：通过集合" class="headerlink" title="创建 Stream方式一：通过集合"></a>创建 Stream方式一：通过集合</h3><p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：</p><ul><li>default Stream<E> stream() : 返回一个顺序流</li><li>default Stream<E> parallelStream() : 返回一个并行流</li></ul><h3 id="创建-Stream方式二：通过数组"><a href="#创建-Stream方式二：通过数组" class="headerlink" title="创建 Stream方式二：通过数组"></a>创建 Stream方式二：通过数组</h3><p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：</p><ul><li>static <T> Stream<T> stream(T[] array): 返回一个流</li></ul><p>重载形式，能够处理对应基本类型的数组：</p><ul><li>public static IntStream stream(int[] array)：返回一个整型数据流</li><li>public static LongStream stream(long[] array)：返回一个长整型数据流</li><li>public static DoubleStream stream(double[] array)：返回一个浮点型数据流</li></ul><h3 id="创建-Stream方式三：通过Stream的of"><a href="#创建-Stream方式三：通过Stream的of" class="headerlink" title="创建 Stream方式三：通过Stream的of()"></a>创建 Stream方式三：通过Stream的of()</h3><p>可以调用Stream类静态方法 of(), 通过显示值创建一个流。它可以接收任意数量的参数。</p><ul><li>public static<T> Stream<T> of(T… values) : 返回一个顺序流</li></ul><h3 id="创建-Stream方式四：创建无限流"><a href="#创建-Stream方式四：创建无限流" class="headerlink" title="创建 Stream方式四：创建无限流"></a>创建 Stream方式四：创建无限流</h3><p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</p><ul><li>public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f):返回一个无限流</li><li>public static<T> Stream<T> generate(Supplier<T> s) ：返回一个无限流</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCreateStream</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"java"</span>, <span class="string">"lambda"</span>, <span class="string">"stream"</span>);</span><br><span class="line">    <span class="comment">// 创建stream</span></span><br><span class="line">    Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">    <span class="comment">// 终结遍历stream流中的数据</span></span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] array = &#123; <span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"java"</span>, <span class="string">"lambda"</span>, <span class="string">"stream"</span> &#125;;</span><br><span class="line">    <span class="comment">// 创建stream</span></span><br><span class="line">    Stream&lt;String&gt; stream = Arrays.stream(array);</span><br><span class="line">    <span class="comment">// 终结遍历stream流中的数据</span></span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建stream</span></span><br><span class="line">    Stream&lt;String&gt; stream = Stream.of(<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"java"</span>, <span class="string">"lambda"</span>, <span class="string">"stream"</span>);</span><br><span class="line">    <span class="comment">// 终结遍历stream流中的数据</span></span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建stream，由奇数组成</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">1</span>, num-&gt;num+<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 终结遍历stream流中的数据</span></span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中间处理数据操作"><a href="#中间处理数据操作" class="headerlink" title="中间处理数据操作"></a>中间处理数据操作</h2><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。</p><table><thead><tr><th>方 法</th><th>描 述</th></tr></thead><tbody><tr><td>filter(Predicate p)</td><td>接收 Lambda ， 从流中排除某些元素</td></tr><tr><td>distinct()</td><td>筛选，通过流所生成元素的equals() 去除重复元素</td></tr><tr><td>limit(long maxSize)</td><td>截断流，使其元素不超过给定数量</td></tr><tr><td>skip(long n)</td><td>跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</td></tr><tr><td>peek(Consumer action)</td><td>接收Lambda，对流中的每个数据执行Lambda体操作</td></tr><tr><td>sorted()</td><td>产生一个新流，其中按自然顺序排序</td></tr><tr><td>sorted(Comparator com)</td><td>产生一个新流，其中按比较器顺序排序</td></tr><tr><td>map(Function f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td></tr><tr><td>mapToDouble(ToDoubleFunction f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。</td></tr><tr><td>mapToInt(ToIntFunction f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。</td></tr><tr><td>mapToLong(ToLongFunction f)</td><td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。</td></tr><tr><td>flatMap(Function f)</td><td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td></tr></tbody></table><p>示例代码：找出流所有偶数，并且要求不重复</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//取出所有偶数，并且要求不重复</span></span><br><span class="line">  Stream.of(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>)</span><br><span class="line">    .filter(num -&gt; num%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">    .distinct()</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：随机产生10个100以内整数，遍历显示，并找出最大值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//随机产生10个100以内整数，遍历显示，并找出最大值</span></span><br><span class="line">  Random random = <span class="keyword">new</span> Random();</span><br><span class="line">  Optional&lt;Integer&gt; max = Stream.generate(() -&gt; random.nextInt(<span class="number">100</span>))</span><br><span class="line">    .limit(<span class="number">10</span>)</span><br><span class="line">    .peek(System.out::println)</span><br><span class="line">    .max(Integer::compareTo);</span><br><span class="line">  System.out.println(<span class="string">"max = "</span> + max.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：按照薪资排序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//按照薪资排序</span></span><br><span class="line">  ArrayList&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"张三"</span>,<span class="number">8888</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"李四"</span>,<span class="number">9999</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"王五"</span>,<span class="number">10000</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"赵六"</span>,<span class="number">11111</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"钱七"</span>,<span class="number">7777</span>));</span><br><span class="line"></span><br><span class="line">  list.stream()</span><br><span class="line">    .sorted((e1,e2)-&gt;e1.getSalary()==e2.getSalary()?<span class="number">0</span>:(<span class="keyword">int</span>)Math.ceil(e1.getSalary()-e2.getSalary()))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：给每个员工涨薪10%</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//给每个员工涨薪10%</span></span><br><span class="line">  ArrayList&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"张三"</span>,<span class="number">8888</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"李四"</span>,<span class="number">9999</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"王五"</span>,<span class="number">10000</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"赵六"</span>,<span class="number">11111</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"钱七"</span>,<span class="number">7777</span>));</span><br><span class="line"></span><br><span class="line">  list.stream()</span><br><span class="line">    .map(e-&gt;&#123;e.setSalary(e.getSalary()*<span class="number">1.1</span>);<span class="keyword">return</span> e;&#125;)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：求每个数的平方根</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//求每个数的平方根</span></span><br><span class="line">  Stream.of(<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">49</span>)</span><br><span class="line">    .mapToDouble(num -&gt; Math.sqrt(num))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：把首字母变成大写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//把首字母变成大写</span></span><br><span class="line">  Stream.of(<span class="string">"hello"</span>,<span class="string">"world"</span>,<span class="string">"java"</span>,<span class="string">"stream"</span>).</span><br><span class="line">    map(s -&gt; Character.toUpperCase(s.charAt(<span class="number">0</span>)) + s.substring(<span class="number">1</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：把每个单词拆成一个个字母</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//把每个单词拆成一个个字母</span></span><br><span class="line">  Stream.of(<span class="string">"hello"</span>,<span class="string">"world"</span>,<span class="string">"java"</span>,<span class="string">"stream"</span>)</span><br><span class="line">    .flatMap(t -&gt; Stream.of(t.split(<span class="string">"|"</span>)))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="终结操作"><a href="#终结操作" class="headerlink" title="终结操作"></a>终结操作</h2><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void。流进行了终止操作后，不能再次使用。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>boolean allMatch(Predicate p)</td><td>检查是否匹配所有元素</td></tr><tr><td>boolean anyMatch(Predicate p)</td><td>检查是否至少匹配一个元素</td></tr><tr><td>boolean noneMatch(Predicate p)</td><td>检查是否没有匹配所有元素</td></tr><tr><td>Optional<T> findFirst()</td><td>返回第一个元素</td></tr><tr><td>Optional<T> findAny()</td><td>返回当前流中的任意元素</td></tr><tr><td>long count()</td><td>返回流中元素总数</td></tr><tr><td>Optional<T> max(Comparator c)</td><td>返回流中最大值</td></tr><tr><td>Optional<T> min(Comparator c)</td><td>返回流中最小值</td></tr><tr><td>void forEach(Consumer c)</td><td>迭代</td></tr><tr><td>T reduce(T iden, BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值。返回 T</td></tr><tr><td>U reduce(BinaryOperator b)</td><td>可以将流中元素反复结合起来，得到一个值。返回 Optional<T></td></tr><tr><td>R collect(Collector c)</td><td>将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</td></tr></tbody></table><p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例。</p><p>代码示例：是否所有员工的薪资都低于10000</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ArrayList&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"张三"</span>,<span class="number">8888</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"李四"</span>,<span class="number">9999</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"王五"</span>,<span class="number">10000</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"赵六"</span>,<span class="number">11111</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"钱七"</span>,<span class="number">7777</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> result = list.stream().allMatch(e -&gt; e.getSalary()&lt;<span class="number">10000</span>);</span><br><span class="line">  System.out.println(<span class="string">"所有员工的薪资都低于10000："</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：是否有员工薪资低于10000</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ArrayList&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"张三"</span>,<span class="number">8888</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"李四"</span>,<span class="number">9999</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"王五"</span>,<span class="number">10000</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"赵六"</span>,<span class="number">11111</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"钱七"</span>,<span class="number">7777</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> result = list.stream().anyMatch(e -&gt; e.getSalary()&lt;<span class="number">10000</span>);</span><br><span class="line">  System.out.println(<span class="string">"是否有员工的薪资都低于10000："</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码示例：薪资最高的员工</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ArrayList&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"张三"</span>,<span class="number">8888</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"李四"</span>,<span class="number">9999</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"王五"</span>,<span class="number">10000</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"赵六"</span>,<span class="number">11111</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"钱七"</span>,<span class="number">7777</span>));</span><br><span class="line"></span><br><span class="line">  Optional&lt;Employee&gt; max = list.stream()</span><br><span class="line">    .max((e1,e2)-&gt;e1.getSalary()==e2.getSalary()?<span class="number">0</span>:(<span class="keyword">int</span>)Math.ceil(e1.getSalary()-e2.getSalary()));</span><br><span class="line">  System.out.println(<span class="string">"薪资最高的员工是："</span> + max.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码示例：求累加和</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Optional&lt;Integer&gt; sum = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line">    .reduce((t1,t2) -&gt; t1+t2);</span><br><span class="line">  System.out.println(<span class="string">"和："</span> + sum.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码示例：找出薪资高于10000的员工放到新的List集合中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ArrayList&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"张三"</span>,<span class="number">8888</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"李四"</span>,<span class="number">9999</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"王五"</span>,<span class="number">10000</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"赵六"</span>,<span class="number">11111</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Employee(<span class="string">"钱七"</span>,<span class="number">7777</span>));</span><br><span class="line"></span><br><span class="line">  List&lt;Employee&gt; collect = list.stream().</span><br><span class="line">    filter(e-&gt;e.getSalary()&gt;<span class="number">10000</span>)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">  collect.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：按照男女分组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ArrayList&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  list.add(<span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="string">'男'</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Student(<span class="string">"李四"</span>,<span class="string">'女'</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Student(<span class="string">"王五"</span>,<span class="string">'男'</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Student(<span class="string">"赵六"</span>,<span class="string">'女'</span>));</span><br><span class="line">  list.add(<span class="keyword">new</span> Student(<span class="string">"钱七"</span>,<span class="string">'男'</span>));</span><br><span class="line"></span><br><span class="line">  Map&lt;Character, List&lt;Student&gt;&gt; collect = list.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(s -&gt; s.getGender()));</span><br><span class="line"></span><br><span class="line">  collect.forEach((k,v) -&gt; System.out.println(k+<span class="string">"-&gt;"</span> + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> Lambda表达式与StreamAPI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2020/06/24/java-reflex/"/>
      <url>/2020/06/24/java-reflex/</url>
      
        <content type="html"><![CDATA[<h1 id="类的加载、连接和初始化"><a href="#类的加载、连接和初始化" class="headerlink" title="类的加载、连接和初始化"></a>类的加载、连接和初始化</h1><p>当程序主动使用某个类时，如果该类还未被加载到JVM内存中，系统会通过加载、连接、初始化三个步骤来对该类进行初始化，如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/reflex1.png" alt="reflex"></p><h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><p>系统可能在第一次使用某个类时加载该类，但也可能采用预先加载机制来预加载某个类，不管怎样，类的加载必须由类加载器完成，类加载器通常由JVM提供，由JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。</p><p>通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源：</p><ol><li>从本地系统直接读取.class文件，这是绝大部分类的加载方法；</li><li>从zip，jar等归档文件中加载.class文件，这种方式也是很常见的；</li><li>通过网络下载.class文件或数据</li><li>从专有数据库中提取.class数据</li><li>将Java源文件数据上传到服务器中动态编译为.class数据，并执行加载；</li></ol><p>但是，不管类的字节码内容从哪里加载，加载的结果都一样，这些字节码内容加载到内存后，都会将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址），所有需要访问和使用类数据只能通过这个Class对象。</p><h2 id="类的连接"><a href="#类的连接" class="headerlink" title="类的连接"></a>类的连接</h2><p>当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段将会负责把类的二进制数据合并到JVM的运行状态之中。类连接又可以分为如下三个阶段：</p><ol><li>验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题</li><li>准备：正式为类变量（static）分配内存并设置类变量<strong>默认</strong>初始值的阶段，这些内存都将在方法区中进行分配</li><li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程</li></ol><h2 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h2><p>类的初始化主要就是对静态的类变量进行初始化：</p><ol><li>执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中所有类变量的显式赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）</li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化</li><li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = getNum();</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">++a;</span><br><span class="line">System.out.println(<span class="string">"(2)a = "</span> + a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">++a;</span><br><span class="line">System.out.println(<span class="string">"(3)a = "</span> + a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"(1)a = "</span> + a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClinit</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b = getNum();</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">++b;</span><br><span class="line">System.out.println(<span class="string">"(5)b = "</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">++b;</span><br><span class="line">System.out.println(<span class="string">"(6)b = "</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"(4)b = "</span> + b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(1)a = 0</span></span><br><span class="line"><span class="comment">(2)a = 2</span></span><br><span class="line"><span class="comment">(3)a = 3</span></span><br><span class="line"><span class="comment">(4)b = 0</span></span><br><span class="line"><span class="comment">(5)b = 2</span></span><br><span class="line"><span class="comment">(6)b = 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>虽然类的加载大多数时候和类初始化是一气呵成的，但其实类的加载不一定就会触发类的初始化，当Java程序<strong>首次</strong>通过下面5种方式来使用某个类时，系统就会初始化该类：</p><ul><li>会发生类的初始化：<ul><li>当虚拟机启动，先初始化main方法所在的类</li><li>new一个类的对象</li><li>调用该类的静态变量（final的常量除外）和静态方法</li><li>使用java.lang.reflect包的方法对类进行反射调用</li><li>当初始化一个类，如果其父类没有被初始化，则先会初始化他的父类</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当虚拟机启动，先初始化main方法所在的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"init...A"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//new一个类的对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"init...B"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用该类的静态变量（final的常量除外）和静态方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"init...C"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestC</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">C.test();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用该类的静态变量（final的常量除外）和静态方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"init...C"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestC</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(C.num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用java.lang.reflect包的方法对类进行反射调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"init...D"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestD</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">cl.loadClass(<span class="string">"com.atguigu.loader.D"</span>);<span class="comment">//该句不会造成类初始化，只是加载类</span></span><br><span class="line">System.out.println(<span class="string">"类加载已完成..."</span>);</span><br><span class="line">Class.forName(<span class="string">"com.atguigu.loader.D"</span>);<span class="comment">//会导致类初始化</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当初始化一个类，如果其父类没有被初始化，则先会初始化他的父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EBase</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"父类初始化"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestE</span> <span class="keyword">extends</span> <span class="title">EBase</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"子类初始化"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不会发生类的初始化：<ul><li>引用静态常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li><li>当访问一个静态域时，只有真正声明这个域的类才会被初始化<ul><li>当通过子类引用父类的静态变量或父类的静态方法，不会导致子类初始化</li></ul></li><li>通过数组定义类引用，不会触发此类的初始化</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用静态常量不会触发此类的初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NBase</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"父类初始化"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NSub</span> <span class="keyword">extends</span> <span class="title">NBase</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"子类初始化"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNoInitialize</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(NSub.MAX_VALUE);</span><br><span class="line">System.out.println(NBase.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当访问一个静态域时，只有真正声明这个域的类才会被初始化</span></span><br><span class="line"><span class="comment">//   当通过子类引用父类的静态变量，不会导致子类初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NBase</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"父类初始化"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NSub</span> <span class="keyword">extends</span> <span class="title">NBase</span></span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"子类初始化"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNoInitialize</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(NSub.num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过数组定义类引用，不会触发此类的初始化</span></span><br><span class="line">NSub[] arr = <span class="keyword">new</span> NSub[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>很多开发人员都遇到过java.lang.ClassNotFoundException或java.lang.NoClassDefError，想要更好的解决这类问题，或者在一些特殊的应用场景，比如需要支持类的动态加载或需要对编译后的字节码文件进行加密解密操作，那么需要你自定义类加载器，因此了解类加载器及其类加载机制也就成了每一个Java开发人员的必备技能之一。</p><h2 id="四种类加载器"><a href="#四种类加载器" class="headerlink" title="四种类加载器"></a>四种类加载器</h2><p>Java的类加载器由如下四种：</p><ol><li><p>引导类加载器（Bootstrap Classloader）：又称为根类加载器</p><p>它负责加载Java的核心库（JAVA_HOME/jre/lib/rt.jar等或sun.boot.class.path路径下的内容），是用原生代码（C/C++）来实现的，并不继承自java.lang.ClassLoder，所以通过Java代码获取引导类加载器对象将会得到null。</p></li><li><p>扩展类加载器（Extension ClassLoader）</p><p>它由sun.misc.Launcher$ExtClassLoader实现，是java.lang.ClassLoader的子类，负责加载Java的扩展库（JAVA_HOME/jre/ext/*.jar或java.ext.dirs路径下的内容）。</p></li><li><p>应用程序类加载器（Application Classloader）</p><p>它由sun.misc.Launcher$AppClassLoader实现，是java.lang.ClassLoader的子类，负责加载Java应用程序类路径（classpath、java.class.path）下的内容。</p></li><li><p>自定义类加载器</p><p>开发人员可以通过继承java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求，例如对字节码进行加密来避免class文件被反编译，或者加载特殊目录下的字节码数据。</p></li></ol><h2 id="经典委托模式"><a href="#经典委托模式" class="headerlink" title="经典委托模式"></a>经典委托模式</h2><p>类加载器负责加载所有的类，系统为所有被载入内存中的类生成一个java.lang.Class实例。一旦一个类被载入JVM中，同一个类就不会被再次载入了。</p><p>那么，怎么样算是“同一个类”呢？在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。换句话说，同一个类如果用两个类加载器分别加载，JVM将视为“不同的类”，它们互不兼容。</p><p>那么，我们的类加载器在执行类加载任务的时候，如何确保一个类的全局唯一性呢？Java虚拟机的设计者们通过一种称之为“双亲委派模型（Parent Delegation Model）”的委派机制来约定类加载器的加载机制。</p><p>按照双亲委派模型的规则，除了引导类加载器之外，程序中的每一个类加载器都应该拥有一个超类加载器，比如：ExtClassLoader的超类加载器是引导类加载器，而AppClassLoader的超类加载器是ExtClassLoader，而自定义类加载器的超类就是AppClassLoader。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/reflex2.png" alt="reflex"></p><p>那么当一个类加载器接收到一个类加载任务的时候，它并不会立即展开加载，先检测此类是否加载过，即在方法区寻找该类对应的Class对象是否存在，如果存在就是已经加载过了，直接返回该Class对象，否则会将加载任务委派给它的超类加载器去执行，每一层的类加载器都采用相同的方式，直至委派给最顶层的启动类加载器为止，如果超类加载器无法加载委派给它的类时，便会将类的加载任务退回给它的下一级类加载器去执行加载，如果所有的类加载器都加载失败，就会报java.lang.ClassNotFoundException或java.lang.NoClassDefFoundError。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/reflex3.png" alt="reflex"></p><p>在此大家需要注意，由于Java虚拟机规范并没有要求类加载器的加载机制一定要使用双亲委托模式，只是建议采用这种方式而已。比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器就接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。</p><p>说明：数组类型本身并不是由类加载器负责创建，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。因此，JVM会把数组元素类型的类加载器记录为数组类型的类加载器。</p><h2 id="java-lang-ClassLoader"><a href="#java-lang-ClassLoader" class="headerlink" title="java.lang.ClassLoader"></a>java.lang.ClassLoader</h2><p>ClassLoader 类是一个抽象类，ClassLoader的相关方法：</p><ul><li>public final ClassLoader getParent()：返回委托的父类加载器。一些实现可能使用 null 来表示引导类加载器。</li><li>public static ClassLoader getSystemClassLoader()：返回委托的系统类加载器。</li><li>public Class&lt;?&gt; loadClass(String name)：使用指定的二进制名称（类的全限定名）来加载类。例如：java.lang.String，注意内部类的名称：匿名内部类（外部类的全限定名$编号）、局部内部类（外部类的全限定名$编号+类名）、成员/静态内部类（外部类的全限定名$+类名）。</li><li>protected Class&lt;?&gt; findClass(String name)：使用指定的二进制名称（类的全限定名）来查找类。此方法应该被类加载器的实现重写，该实现按照委托模型来加载类。在通过父类加载器检查所请求的类后，此方法将被 loadClass 方法调用。</li><li>protected final Class&lt;?&gt; findLoadedClass(String name)：返回Class 对象，如果类没有被加载，则返回 null</li><li>protected final Class&lt;?&gt; defineClass(String name,byte[] b,int off,int len)：将一个 byte 数组转换为 Class 类的实例。</li></ul><p>自定义类加载器示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String rootDir;<span class="comment">//指定加载路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileClassLoader</span><span class="params">(String rootDir)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"><span class="comment">//首先检查请求的类型是否已经被这个类装载器装载到命名空间中了，如果已经被装载，直接返回；</span></span><br><span class="line">Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(c ==<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//委派类加载器请求给父类加载器，如果父类加载器能够完成，则返回父类加载器加载的Class实例；</span></span><br><span class="line">ClassLoader parent = <span class="keyword">this</span>.getParent();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">c = parent.loadClass(name);</span><br><span class="line"><span class="comment">//加异常处理，父类加载不到，然后自己加载</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用本类加载器的findClass()方法，试图获取对应的字节码，如果获取的到，则调用defineClass()导入类型到方法区；</span></span><br><span class="line"><span class="comment">//如果获取不到对应的字节码或其他原因失败，则异常，终止加载过程</span></span><br><span class="line"><span class="keyword">if</span>(c == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line"><span class="keyword">if</span>(classData == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">c = defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把.class文件的内容读取到一个字节数组中</span></span><br><span class="line"><span class="comment">//为什么要读取的字节数组中，因为protected final Class&lt;?&gt; defineClass(String name,byte[] b,int off,int len)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String name) &#123;</span><br><span class="line">String path = rootDir + File.separator + name.replace(<span class="string">"."</span>, File.separator)+<span class="string">".class"</span>;</span><br><span class="line">InputStream is = <span class="keyword">null</span>;</span><br><span class="line">ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">is = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">baos =<span class="keyword">new</span> ByteArrayOutputStream(); </span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(is!=<span class="keyword">null</span>)&#123;</span><br><span class="line">is.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">FileClassLoader fsc = <span class="keyword">new</span> FileClassLoader(<span class="string">"D:/atguigu/code"</span>);</span><br><span class="line">Class&lt;?&gt; uc = fsc.loadClass(<span class="string">"com.atguigu.UserManager"</span>);</span><br><span class="line">System.out.println(uc);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; sc = fsc.loadClass(<span class="string">"java.lang.String"</span>);</span><br><span class="line">System.out.println(sc);</span><br><span class="line">System.out.println(sc.getClassLoader());<span class="comment">//null,因为委托给父类加载器...一直到引导类加载器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用类加载器加载资源文件"><a href="#使用类加载器加载资源文件" class="headerlink" title="使用类加载器加载资源文件"></a>使用类加载器加载资源文件</h2><p>ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个Java类，即java.lang.Class类的一个实例。除此之外，ClassLoader还负责加载Java应用所需的资源，如图像文件和配置文件等。</p><p>加载类路径下（例如：src下）jdbc.properties资源文件的示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">username=root</span><br><span class="line">password=<span class="number">123456</span></span><br><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLoaderProperties</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">pro.load(ClassLoader.getSystemResourceAsStream(<span class="string">"jdbc.properties"</span>));</span><br><span class="line">System.out.println(pro);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果发布在tomcat中web应用，使用如上代码是无法加载src类路径下的资源文件的，src下的资源文件会随着类被发布到web应用的WEB-INF\classes目录下，而tomcat使用自定义类加载器加载该路径下的内容。那么就需要通过该路径下的类先获取到该自定义加载器对象，然后再调用getSystemResourceAsStream(String name)去加载。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ClassLoader loader = DBUtils<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">  InputStream is = loader.getResourceAsStream(<span class="string">"druid.properties"</span>);</span><br><span class="line">  pro.load(is);</span><br><span class="line">  System.out.println(pro);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="通过反射查看类信息"><a href="#通过反射查看类信息" class="headerlink" title="通过反射查看类信息"></a>通过反射查看类信息</h1><p>Java程序中，所有的对象都有两种类型：编译时类型和运行时类型，而很多时候对象的编译时类型和运行时类型不一致。</p><p>例如：我们某些变量或形参的类型是Object类型，但是程序确需要调用该对象运行时类型的方法，该方法不是Object中方法，那么如何解决呢？</p><p>为了解决这些问题，程序需要在运行时发现对象和类的真实信息，我们有两种方法：</p><p>第一种是在编译和运行时都完全知道类型的具体信息，在这种情况下，我们可以直接先使用instanceof运算符进行判断，再利用强制类型转换符将其转换成运行时类型的变量即可。</p><p>第二种是编译时根本无法预知该对象和类的真实信息，程序只能依靠运行时信息来发现该对象和类的真实信息，这就必须使用反射。</p><p>因为加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</p><h2 id="java-lang-Class"><a href="#java-lang-Class" class="headerlink" title="java.lang.Class"></a>java.lang.Class</h2><h3 id="哪些类型有Class对象"><a href="#哪些类型有Class对象" class="headerlink" title="哪些类型有Class对象"></a>哪些类型有Class对象</h3><p>Class 类的实例表示正在运行的 Java 应用程序中的类和接口。事实上，所有类型都可以表示为Class的实例对象。</p><ol><li>class：外部类，内部类</li><li>interface：接口</li><li>[]：数组，所有具有相同元素类型和维数的数组共享同一个Class 对象</li><li>enum：枚举</li><li>annotation：注解@interface</li><li>primitive type：8种基本数据类型</li><li>void</li></ol><h3 id="获得Class对象"><a href="#获得Class对象" class="headerlink" title="获得Class对象"></a>获得Class对象</h3><p>Java程序中可以通过以下四种方式获得Class对象：</p><ul><li>类型名.class：适用于编译期间已知的任意类型；</li><li>调用任意对象的getClass()方法，可以获取该对象的运行时类型的Class对象；</li><li>使用Class类的forName(String name)静态方法，该方法需要传入一个字符串参数，该值是某个类的全限定名（全限定名即完整的包.类型名）；该方法适用于除了数组以外的任意引用数据类型；</li><li>调用类加载对象的loadClass(String name)该方法需要传入一个字符串参数，该值是某个类的全限定名（全限定名即完整的包.类型名）;</li></ul><p>方式（1）只适用于编译器间已知的类型，如果某个类型编译期间是已知的，优先考虑这种方式，代码更安全，效率更高；另外基本数据类型和也只能通过该方式获得Class对象；如果某个类型编译期间未知，我们只能通过某种方式获取该类型的全名称的字符串形式，那么就只能选择（3）和（4）了，但是该方法在运行期间仍然无法加载该类的话，会报ClassNotFoundException。对于基本数据类型和数组类型，无法通过第（3）和（4）方式获取。</p><p>示例代码：获取Class对象的四种方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</span><br><span class="line">  Class&lt;?&gt; c1 = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  Class&lt;?&gt; c2 = <span class="string">"hello"</span>.getClass();</span><br><span class="line">  Class&lt;?&gt; c3 = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">  Class&lt;?&gt; c4 = ClassLoader.getSystemClassLoader().loadClass(<span class="string">"java.lang.String"</span>);</span><br><span class="line">  System.out.println(c1 == c2);</span><br><span class="line">  System.out.println(c1 == c3);</span><br><span class="line">  System.out.println(c1 == c4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Class&lt;?&gt; c1 = <span class="keyword">int</span><span class="class">.<span class="keyword">class</span></span>;<span class="comment">//基本数据类型</span></span><br><span class="line">  Class&lt;?&gt; c2 = <span class="keyword">void</span><span class="class">.<span class="keyword">class</span></span>;<span class="comment">//void类型</span></span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; c3 = String<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//类</span></span><br><span class="line">  Class&lt;?&gt; c4 = Object<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//类</span></span><br><span class="line">  Class&lt;?&gt; c5 = Class<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//类</span></span><br><span class="line">  Class&lt;?&gt; c6 = Comparable<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//接口</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//只要元素类型与维度一样，就是同一个Class</span></span><br><span class="line">  Class&lt;?&gt; c7 = <span class="keyword">int</span>[]<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  <span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">  <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">  System.out.println(arr1.getClass() == c7);</span><br><span class="line">  System.out.println(arr2.getClass() == c7);</span><br><span class="line">  Class c9 = String[]<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  Class c10 = <span class="keyword">int</span>[][]<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  System.out.println(c7 == c9);</span><br><span class="line">  System.out.println(c7 == c10);</span><br><span class="line"></span><br><span class="line">  Class c11 = Override<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//注解</span></span><br><span class="line">  Class c12 = ElementType<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//枚举</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从Class中获取信息"><a href="#从Class中获取信息" class="headerlink" title="从Class中获取信息"></a>从Class中获取信息</h2><p>Class类提供了大量实例方法来获取该Class对象所对应类的详细信息，Class类大致包含如下几种方法，下面每种方法都可能包含多个重载的版本。</p><p>例如：包、修饰符、类名、父类、父接口、注解，及成员（属性、构造器、方法）等</p><p>反射相关的API主要是java.lang.Class和java.lang.reflect包的内容。</p><h3 id="获取某个类的加载器"><a href="#获取某个类的加载器" class="headerlink" title="获取某个类的加载器"></a>获取某个类的加载器</h3><ul><li><p>public ClassLoader getClassLoader()</p><p>返回该类的类加载器。有些实现可能使用 null 来表示引导类加载器。如果此对象表示一个基本类型或 void，则返回 null。</p></li></ul><h3 id="获取包名和类型名"><a href="#获取包名和类型名" class="headerlink" title="获取包名和类型名"></a>获取包名和类型名</h3><ul><li><p>public Package getPackage()：获取此类的包。然后可以通过Package实例对象的getName()获取包名。</p></li><li><p>public String getName()：以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//java.lang.String</span></span><br><span class="line">  System.out.println(String<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">  <span class="comment">//int</span></span><br><span class="line">  System.out.println(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">  <span class="comment">//[I</span></span><br><span class="line">  System.out.println(<span class="keyword">int</span>[]<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">  <span class="comment">//[[[I</span></span><br><span class="line">  System.out.println(<span class="keyword">int</span>[][][]<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">  <span class="comment">//[Ljava.lang.Object;</span></span><br><span class="line">  System.out.println(Object[]<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此类对象表示的是非数组类型的引用类型，则返回该类的二进制名称，即包.类名。</p><p>如果此类对象表示一个基本类型或 void，则返回该基本类型或 void 所对应的 Java 语言关键字相同的字符串名称。 </p><p>如果此类对象表示一个数组类，则名字的内部形式为：表示该数组嵌套深度的一个或多个 ‘[‘ 字符加元素类型名。元素类型名的编码如下： </p><table><thead><tr><th>Element</th><th>Type    Encoding</th></tr></thead><tbody><tr><td>byte</td><td>B</td></tr><tr><td>short</td><td>S</td></tr><tr><td>int</td><td>I</td></tr><tr><td>long</td><td>L</td></tr><tr><td>float</td><td>F</td></tr><tr><td>double</td><td>D</td></tr><tr><td>boolean</td><td>Z</td></tr><tr><td>char</td><td>C</td></tr><tr><td>class or interface</td><td>Lclassname;</td></tr></tbody></table><h3 id="获取类型修饰符"><a href="#获取类型修饰符" class="headerlink" title="获取类型修饰符"></a>获取类型修饰符</h3><ul><li>public int getModifiers()：返回此类或接口以整数编码的 Java 语言修饰符。</li></ul><p>修饰符由 Java 虚拟机的 public、protected、private、final、static、abstract 和 interface 对应的常量组成；它们应当使用 Modifier 类的方法来解码。 </p><p>如果底层类是数组类，则其 public、private 和 protected 修饰符与其组件类型的修饰符相同。如果此 Class 表示一个基本类型或 void，则其 public 修饰符始终为 true，protected 和 private 修饰符始终为 false。如果此对象表示一个数组类、一个基本类型或 void，则其 final 修饰符始终为 true，其接口修饰符始终为 false。该规范没有给定其他修饰符的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Class&lt;?&gt; clazz = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  <span class="keyword">int</span> mod = clazz.getModifiers();</span><br><span class="line">  System.out.println(Modifier.toString(mod));<span class="comment">//public final</span></span><br><span class="line">  System.out.println(Modifier.isPublic(mod));<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取父类或父接口"><a href="#获取父类或父接口" class="headerlink" title="获取父类或父接口"></a>获取父类或父接口</h3><ul><li><p>public Class&lt;? super T&gt; getSuperclass()</p><p>返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。如果此 Class 表示 Object 类、一个接口、一个基本类型或 void，则返回 null。如果此对象表示一个数组类，则返回表示该 Object 类的 Class 对象。</p></li><li><p>public Class&lt;?&gt;[] getInterfaces()</p><p>确定此对象所表示的类或接口实现的接口。如果此对象表示一个类，则返回值是一个数组，它包含了表示该类所实现的所有接口的对象。数组中接口对象顺序与此对象所表示的类的声明的 implements 子句中接口名顺序一致。如果此对象表示一个接口，则该数组包含表示该接口扩展的所有接口的对象。数组中接口对象顺序与此对象所表示的接口的声明的 extends 子句中接口名顺序一致。 如果此对象表示一个不实现任何接口的类或接口，则此方法返回一个长度为 0 的数组。如果此对象表示一个基本类型或 void，则此方法返回一个长度为 0 的数组。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">  System.out.println(Integer<span class="class">.<span class="keyword">class</span>.<span class="title">getSuperclass</span>())</span>;<span class="comment">//Number</span></span><br><span class="line">  System.out.println(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>.<span class="title">getSuperclass</span>())</span>;<span class="comment">//null</span></span><br><span class="line">  System.out.println(Runnable<span class="class">.<span class="keyword">class</span>.<span class="title">getSuperclass</span>())</span>;<span class="comment">//null</span></span><br><span class="line">  System.out.println(<span class="keyword">int</span>[]<span class="class">.<span class="keyword">class</span>.<span class="title">getSuperclass</span>())</span>;<span class="comment">//Object</span></span><br><span class="line">  System.out.println(String[]<span class="class">.<span class="keyword">class</span>.<span class="title">getSuperclass</span>())</span>;<span class="comment">//Object</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Class&lt;?&gt; clazz = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line">  <span class="keyword">for</span> (Class&lt;?&gt; inter : interfaces) &#123;</span><br><span class="line">    System.out.println(inter);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取内部类或外部类信息"><a href="#获取内部类或外部类信息" class="headerlink" title="获取内部类或外部类信息"></a>获取内部类或外部类信息</h3><ul><li><p>public Class&lt;?&gt;[] getClasses()</p><p>返回所有公共内部类和内部接口。包括从超类继承的公共类和接口成员以及该类声明的公共类和接口成员。</p></li><li><p>public Class&lt;?&gt;[] getDeclaredClasses()</p><p>返回 Class 对象的一个数组，这些对象反映声明为此 Class 对象所表示的类的成员的所有类和接口。包括该类所声明的公共、保护、默认（包）访问及私有类和接口，但不包括继承的类和接口。</p></li><li><p>public Class&lt;?&gt; getDeclaringClass()</p><p>如果此 Class 对象所表示的类或接口是一个内部类或内部接口，则返回它的外部类或外部接口，否则返回null。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Class&lt;?&gt; clazz = Map<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  Class&lt;?&gt;[] inners = clazz.getDeclaredClasses();</span><br><span class="line">  <span class="keyword">for</span> (Class&lt;?&gt; inner : inners) &#123;</span><br><span class="line">    System.out.println(inner);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Class&lt;?&gt; ec = Map.Entry<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  Class&lt;?&gt; outer = ec.getDeclaringClass();</span><br><span class="line">  System.out.println(outer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><p>四个方法用于访问Class对应类所包含的属性（Field）：</p><ul><li><p>public Field[] getFields()</p><p>返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段。返回数组中的元素没有排序，也没有任何特定的顺序。包括继承的公共字段。</p></li><li><p>public Field getField(String name)</p><p>返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段。包括继承的公共字段。name 参数是一个 String，用于指定所需字段的简称。</p></li><li><p>public Field[] getDeclaredFields()</p><p>返回 Field 对象的一个数组，这些对象反映此 Class 对象所表示的类或接口所声明的所有字段。包括公共、保护、默认（包）访问和私有字段，但不包括继承的字段。返回数组中的元素没有排序，也没有任何特定的顺序。</p></li><li><p>public Field getDeclaredField(String name)</p><p>返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Class&lt;?&gt; clazz = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">  <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    <span class="keyword">int</span> mod = field.getModifiers();</span><br><span class="line">    Class&lt;?&gt; type = field.getType();</span><br><span class="line">    String name = field.getName();</span><br><span class="line">    System.out.print(Modifier.toString(mod)+<span class="string">"\t"</span>);</span><br><span class="line">    System.out.println(type.getName()+<span class="string">"\t"</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取构造器"><a href="#获取构造器" class="headerlink" title="获取构造器"></a>获取构造器</h3><p>四个方法用于访问Class对应的类所包含的构造器（Constructor）：</p><ul><li><p>public Constructor<T> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</p><p>构造器名称无需指定，因为它和类名一致。parameterTypes 参数是 Class 对象的一个数组，它按声明顺序标识构造方法的形参类型。 如果此 Class 对象表示非静态上下文中声明的内部类，则形参类型作为第一个参数包括显示封闭的实例。</p></li><li><p>public Constructor&lt;?&gt;[] getDeclaredConstructors()</p><p>它们是公共、保护、默认（包）访问和私有构造方法。</p></li><li><p>public Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes)</p><p>指定公共构造方法</p></li><li><p>public Constructor&lt;?&gt;[] getConstructors()</p><p>所有公共构造方法</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConstructor</span></span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Outer<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();</span><br><span class="line">    System.out.println(constructor);<span class="comment">//无参构造</span></span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; c = Outer.Inner<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    <span class="comment">//因为Inner是非静态的内部类，所以它的构造器，默认第一个形参是外部类的实例对象</span></span><br><span class="line">    Constructor&lt;?&gt; cs = c.getDeclaredConstructor(Outer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(cs);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Class&lt;?&gt; clazz = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  Constructor&lt;?&gt;[] constructors = clazz.getConstructors();</span><br><span class="line">  <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">    <span class="keyword">int</span> mod = constructor.getModifiers();</span><br><span class="line">    String name = constructor.getName();</span><br><span class="line">    Class&lt;?&gt;[] parameterTypes = constructor.getParameterTypes();</span><br><span class="line">    System.out.print(Modifier.toString(mod)+<span class="string">"\t"</span> + name + <span class="string">"("</span>);</span><br><span class="line">    System.out.println(Arrays.toString(parameterTypes)+<span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><p>四个方法用于访问Class对应的类所包含的方法（Method）：</p><ul><li><p>public Method getDeclaredMethod(String name,Class&lt;?&gt;… parameterTypes)</p><p>name 参数是一个 String，它指定所需方法的简称，parameterTypes 参数是 Class 对象的一个数组或0~n个Class对象，它按声明顺序标识该方法的<strong>形参类型</strong>。如果是无参方法，那么parameterTypes 可以不传或者传null。因为可能存在重载的方法，所以在一个类中唯一确定一个方法，需要方法名和形参类型列表。</p></li><li><p>public Method[] getDeclaredMethods()</p><p>包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</p></li><li><p>public Method getMethod(String name,Class&lt;?&gt;… parameterTypes)</p><p>指定的公共成员方法。包括继承的公共方法。</p></li><li><p>public Method[] getMethods()</p><p>所有公共成员方法。包括继承的公共方法。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Class&lt;?&gt; clazz = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">  Method[] methods = clazz.getMethods();</span><br><span class="line">  <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    <span class="keyword">int</span> mod = method.getModifiers();</span><br><span class="line">    Class&lt;?&gt; returnType = method.getReturnType();</span><br><span class="line">    String name = method.getName();</span><br><span class="line">    Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">    System.out.print(Modifier.toString(mod)+<span class="string">"\t"</span> + returnType + <span class="string">"\t"</span> + name + <span class="string">"("</span>);</span><br><span class="line">    System.out.println(Arrays.toString(parameterTypes)+<span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取泛型父类"><a href="#获取泛型父类" class="headerlink" title="获取泛型父类"></a>获取泛型父类</h3><p>JDK1.5引入的泛型，为了通过反射操作这些泛型，新增了ParameterizedType，GenericArrayType，TypeVariable和WildcardType几种类型来代表不能被归一到Class中的类型但是又和原始类型齐名的类型。</p><ul><li>ParameterizedType:    参数化类型    例如：Father&lt;Integer,String&gt;</li><li>GenericArrayType:       泛型数组类型   例如：T[]</li><li>TypeVariable:        类型变量    例如：T</li><li>WildcardType：    带？(通配符)的泛型的类型      例如： ArrayList&lt;?&gt; 或 ArrayList&lt;? super 下限&gt; 或 ArrayList&lt;? extends 上限&gt;</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/reflex4.png" alt="reflex"></p><p>而在Class类、Field类、Method类等API中增加了很多关于获取泛型信息的方法，例如在Class类中就有很多，其中有一个获取泛型父类的方法：</p><ul><li>public Type getGenericSuperclass()：返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的直接超类的 Type。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGenericSuperClass</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; c = Base<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    TypeVariable&lt;?&gt;[] typeParameters = c.getTypeParameters();</span><br><span class="line">    <span class="keyword">for</span> (TypeVariable&lt;?&gt; typeVariable : typeParameters) &#123;</span><br><span class="line">      System.out.println(typeVariable + <span class="string">"，上限："</span> + typeVariable.getBounds()[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;Sub&gt; clazz = Sub<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    Type gs = clazz.getGenericSuperclass();</span><br><span class="line"></span><br><span class="line">    ParameterizedType gt = (ParameterizedType)gs;</span><br><span class="line">    Type[] types = gt.getActualTypeArguments();</span><br><span class="line">    <span class="keyword">for</span> (Type type : types) &#123;</span><br><span class="line">      System.out.println(type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取注解信息"><a href="#获取注解信息" class="headerlink" title="获取注解信息"></a>获取注解信息</h3><p>可以通过反射API，获得相关的注解信息。</p><ul><li><p>public Annotation[] getAnnotations() </p><p>返回此元素上存在的所有注释。</p></li><li><p>public Annotation[] getDeclaredAnnotations()</p><p>获取某元素上存在的所有注释。该方法将忽略继承的注释。</p></li><li><p>public <T extends Annotation> T getAnnotation(Class<T> annotationClass)</p><p>如果存在该元素的指定类型的注释，则返回这些注释，否则返回 null。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnnotation</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; clazz = MyClass<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">MyAnnotation my = clazz.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(my.value());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyAnnotation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "尚硅谷"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示：要想通过反射获取到某个注解的信息，该注解声明时必须加@Retention(RetentionPolicy.<strong>RUNTIME</strong>)元注解，表明滞留注解信息到运行时。</p><h1 id="使用反射生成并操作对象"><a href="#使用反射生成并操作对象" class="headerlink" title="使用反射生成并操作对象"></a>使用反射生成并操作对象</h1><h2 id="使用反射创建对象"><a href="#使用反射创建对象" class="headerlink" title="使用反射创建对象"></a>使用反射创建对象</h2><p>通过反射来生成对象有如下两种方式：</p><p>方式一：使用Class对象的newInstance()方法来创建该Class对象对应类的实例，这种方式要求该Class对象的对应类有默认构造器，而执行newInstance()方法时实际上是利用默认构造器来创建该类的实例。</p><p>方式二：先使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance(Object… args)方法来创建该Class对象对应类的实例。通过这种方式可以选择使用某个类的指定构造器来创建实例。</p><p>通过第一种方式来创建对象是比较常见的情形，因为在很多JavaEE框架中都需要根据配置文件信息来创建实例对象，从配置文件读取的只是某个类的字符串类名，程序就需要根据该字符串来创建对应的实例，就必须使用反射。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNewInstance</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.unclehe.reflect.Student"</span>);</span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line">System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.unclehe.reflect.Student"</span>);</span><br><span class="line">Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"佟刚"</span>);</span><br><span class="line">System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Student [name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取或设置某个对象的属性值"><a href="#获取或设置某个对象的属性值" class="headerlink" title="获取或设置某个对象的属性值"></a>获取或设置某个对象的属性值</h2><p>通过Class对象的getFields()等方法可以获取该类所包括的全部Field（属性）或指定Field。而Field类除了提供获取属性的修饰符、属性类型、属性名等方法外，还提供了如下两组方法来访问属性：</p><ul><li><p>public xxx getXxx(Object obj)</p><p>获取obj对象该Field的属性值。此处的Xxx对应8种基本数据类型，如果该属性的类型是引用数据类型，则直接使用get(Object obj)方法。</p></li><li><p>public void setXxx(Object obj,Xxx value)</p><p>设置obj对象该Field的属性值为value。此处的Xxx对应8种基本数据类型，如果该属性的类型是引用数据类型，则直接使用set(Object obj, Object value)方法。</p></li><li><p>public void setAccessible(boolean flag)启动和禁用访问安全检查的开关。</p><ul><li>值为true则指示反射的对象在使用时应该取消Java语言访问检查。<ul><li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true.</li><li>使得原本无法访问的私有成员也可以访问</li></ul></li><li>值为false则指示反射的对象应该实施Java语言访问检查。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestField</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.atguigu.reflect.Circle"</span>);</span><br><span class="line">Object obj = clazz.newInstance();</span><br><span class="line">Field field = clazz.getDeclaredField(<span class="string">"radius"</span>);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(obj, <span class="number">1.2</span>);</span><br><span class="line">Object value = field.get(obj);</span><br><span class="line">System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>当获得某个类对应的Class对象后，就可以通过该Class对象的getMethods()等方法获取全部方法或指定方法。每个Method对象对应一个方法，获得Method对象后，程序就可以通过该Method对象的invoke方法来调用对应方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">"com.atguigu.reflect.Utils"</span>);</span><br><span class="line">    Object obj = clazz.newInstance();</span><br><span class="line">    Method method = clazz.getMethod(<span class="string">"check"</span>, String<span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    Object value = method.invoke(obj, <span class="string">"tong"</span>,<span class="string">"666"</span>);</span><br><span class="line">    System.out.println(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utils</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String user,String password)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">"admin"</span>.equals(user) &amp;&amp; <span class="string">"123"</span>.equals(password))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作数组"><a href="#操作数组" class="headerlink" title="操作数组"></a>操作数组</h2><p>在java.lang.reflect包下还提供了一个Array类，Array对象可以代表所有的数组。程序可以通过使用Array类来动态的创建数组，操作数组元素等。</p><p>Array类提供了如下几个方法：</p><ul><li><p>public static Object newInstance(Class&lt;?&gt; componentType, int… dimensions)</p><p>创建一个具有指定的组件类型和维度的新数组。</p></li><li><p>public static void setXxx(Object array,int index,xxx value)</p><p>将array数组中[index]元素的值修改为value。此处的Xxx对应8种基本数据类型，如果该属性的类型是引用数据类型，则直接使用set(Object array,int index, Object value)方法。</p></li><li><p>public static xxx getXxx(Object array,int index,xxx value)</p><p>将array数组中[index]元素的值返回。此处的Xxx对应8种基本数据类型，如果该属性的类型是引用数据类型，则直接使用get(Object array,int index)方法。</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArray</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Object arr = Array.newInstance(String<span class="class">.<span class="keyword">class</span>, 5)</span>;</span><br><span class="line">Array.set(arr, <span class="number">0</span>, <span class="string">"哈哈哈"</span>);</span><br><span class="line">Array.set(arr, <span class="number">1</span>, <span class="string">"嘻嘻"</span>);</span><br><span class="line">System.out.println(Array.get(arr, <span class="number">0</span>));</span><br><span class="line">System.out.println(Array.get(arr, <span class="number">1</span>));</span><br><span class="line">System.out.println(Array.get(arr, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>在Java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口可以生成JDK动态代理类或动态代理对象。</p><p>Proxy提供用于创建动态代理类和代理对象的静态方法，它也是所有动态代理类的父类。如果我们在程序中为一个或多个接口动态地生成实现类，就可以使用Proxy来创建动态代理类或它们的实例。</p><ul><li><p>public static Class<?>  getProxyClass(ClassLoader loader, Class<?>… interfaces)</p><p>创建一个动态代理类所对应的Class对象</p></li><li><p>public static Object  newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</p><p>直接创建一个动态代理对象。第一个参数，被代理类的类加载器对象，第二个参数，被代理类实现的接口们，第三个参数，代理类代理工作处理器对象。</p></li></ul><p>InvocationHandler接口，有一个invoke方法需要实现，该invoke方法中三个参数分别是proxy，代表动态代理对象，method，代表正在执行的方法，args，代表执行代理对象的方法时传入的实参。</p><p>案例需求：我需要在所有的Dog，Person，Bird等接口的实现类所有实现方法加上统计方法的执行时间，并要求不修改这些实现类的代码。</p><p>接口们：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">think</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类们：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TibetanMastiff</span> <span class="keyword">implements</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"藏獒在叫"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"藏獒在跑"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"中国人在学习"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">think</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"中国人在思考"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Magpie</span> <span class="keyword">implements</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"喜鹊在跳来跳去"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"喜鹊飞来了"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类处理器，必须实现InvocationHandler接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TimeInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"开始计时..."</span>);</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">Object returnValue = method.invoke(target, args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"方法执行时间："</span> + (end-start));</span><br><span class="line"><span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态创建代理对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">TibetanMastiff target = <span class="keyword">new</span> TibetanMastiff();</span><br><span class="line">Class&lt;?&gt; clazz = TibetanMastiff<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">TimeInvocationHandler handler = <span class="keyword">new</span> TimeInvocationHandler(target);</span><br><span class="line">Dog dog = (Dog) Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), handler);</span><br><span class="line">dog.bark();</span><br><span class="line">dog.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">Chinese target = <span class="keyword">new</span> Chinese();</span><br><span class="line">Class&lt;?&gt; clazz = Chinese<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">TimeInvocationHandler handler = <span class="keyword">new</span> TimeInvocationHandler(target);</span><br><span class="line">Person person = (Person) Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), handler);</span><br><span class="line">person.study();</span><br><span class="line">person.think();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">Magpie target = <span class="keyword">new</span> Magpie();</span><br><span class="line">Class&lt;?&gt; clazz = Magpie<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">TimeInvocationHandler handler = <span class="keyword">new</span> TimeInvocationHandler(target);</span><br><span class="line">Bird bird = (Bird) Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), handler);</span><br><span class="line">bird.jump();</span><br><span class="line">bird.fly();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理对象需要实现一个或多个接口的方法时，它是如何知道怎么实现这些方法的呢？实际上它实现的方法体，其实就是执行InvocationHandler对象的invoke()方法。</p><p>不难发现，使用动态代理可以非常灵活的实现解耦合，这种动态代理在Spring框架体系的AOP（Aspect Orient Program，即面向切面编程）里被称为AOP代理，AOP代理可替代目标对象，AOP代理包含了目标对象的全部方法。但AOP代理中的方法与目标对象的方法存在差异：AOP代理里的方法可以在执行目标方法之前、后插入一下通用处理。</p>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 反射 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/2020/06/23/java-network-programming/"/>
      <url>/2020/06/23/java-network-programming/</url>
      
        <content type="html"><![CDATA[<h1 id="网络编程的基本知识"><a href="#网络编程的基本知识" class="headerlink" title="网络编程的基本知识"></a>网络编程的基本知识</h1><h2 id="网络的概念和分类"><a href="#网络的概念和分类" class="headerlink" title="网络的概念和分类"></a>网络的概念和分类</h2><p>所谓计算机网络就是把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源。</p><p>生活在今天的我们，没有网络那是相当可怕的，我们每天几乎都在用所谓的云计算、云服务、云备份、搜索引擎检索信息、即时通信、在线支付……</p><p>计算机网络有很多种，按照网络的传输介质划分：双绞线网、同轴电缆网、光纤网、卫星网等。还有无线传输的，例如Wifi的传输介质是红外线，蓝牙的传输介质是无线电波，都是电磁波的一种。</p><p>如果按照网络的拓扑结构来划分，可以分为星型网络、总线网络、环线网络、树型网络、网状网络、混合型网络等。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/network-programming1.png" alt="network-programming"></p><p>按照规模来分类</p><ul><li>局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。</li><li>城域网(Metropolitan Area Network，MAN)是在一个城市范围内所建立的计算机通信网，属宽带局域网。由于采用具有有源交换元件的局域网技术，网中传输时延较小，它的传输媒介主要采用光缆，传输速率在100兆比特/秒以上。MAN的一个重要用途是用作骨干网，通过它将位于同一城市内不同地点的主机、数据库，以及LAN等互相联接起来，这与WAN的作用有相似之处，但两者在实现方法与性能上有很大差别。</li><li>广域网（Wide Area Network， WAN），又称外网、公网，是连接不同地区局域网或城域网计算机通信的远程网。通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个地区、城市和国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。</li></ul><p><strong>那么什么是互联网、因特网、万维网呢？</strong></p><p>凡是由能彼此通信的设备组成的网络就叫互联网，即使仅有两台机器（计算机、手机等），不论用何种技术使其彼此通信，都叫互联网，所以，互联网有广域网、城域网及局域网之分。国际标准的互联网写法是internet，字母i小写！</p><p>而因特网是互联网中的一种，它可不是仅有两台机器组成的网络，而是由上千万台设备组成的网络（该网络具备一定规模）。国际标准的因特网写法是Internet，字母I大写！</p><p>因特网是基于TCP/IP协议实现的，TCP/IP协议由很多协议组成，不同类型的协议又被放在不同的层，其中，位于应用层的协议就有很多，比如FTP、SMTP、HTTP。所以，因特网提供的服务一般包括有：www（万维网）服务、电子邮件服务（outlook）、远程登录（QQ）服务、文件传输（FTP）服务、网络电话等等。只要应用层使用的是HTTP协议，就称为万维网(World Wide Web)。</p><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>不管处于那种网络，那么通信是网络最基本的要求，而计算机网络中实现通信必须有一些约定，即通信协议。对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准。</p><p>网络通信必须有硬件和软件方面的支持，由于世界上大型计算机厂商推出各自不同的网络体系结构，影响了网络通信的统一性，因此国际标准化组织ISO于1978年提出了著名的OSI（Open System Interconnection）开放系统互连参考模型。它把计算机网络分成物理层、数据链路层、网络层、传输层、会话层、表示层、应用层等七层。</p><ul><li>应用层：网络服务与最终用户的一个接口。协议有：HTTP、FTP、SMTP、DNS、TELNET、HTTPS、POP3等等。</li><li>表示层：数据的表示、安全、压缩。格式有：JPEG、ASCll、DECOIC、加密格式等。</li><li>会话层：建立、管理、终止会话。对应主机进程，指本地主机与远程主机正在进行的会话</li><li>传输层：定义传输数据的协议端口号，以及流控和差错校验。协议有：TCP、UDP。</li><li>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。协议有：ICMP、IGMP、IP（IPV4 IPV6）、ARP、RARP。</li><li>数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正</li><li>物理层：建立、维护、断开物理连接。</li></ul><p>而IP协议是一种非常重要的协议。IP（internet protocal）又称为互联网协议。IP的责任就是把数据从源传送到目的地。它在源地址和目的地址之间传送一种称之为数据包的东西，它还提供对数据大小的重新组装功能，以适应不同网络对包大小的要求。经常与IP协议放在一起的还有TCP（Transmission Control Protocol）协议，即传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。而通常我们说的TCP/IP协议，其实是指TCP/IP协议族，因为该协议家族的两个最核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准，所以简称为TCP/IP协议。</p><p>按照TCP/IP协议模型，网络通常被分为四层：网络访问层、互联网层、传输层和应用层。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/network-programming2.png" alt="network-programming"></p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址用于标识网络中的一个通信实体，这个通信实体可以是一台计算机，也可以是一台打印机，或者是路由器的一个端口。而在基于IP协议网络中传输的数据包，都必须使用IP地址来进行标识。</p><p>如同我们写信，发快递一样，要标明收件人的通信地址和发件人的通信地址，而邮政人员和物流快递员则通过该地址决定信件、包裹的去向。</p><p>IP地址是一个32位的整数，但为了便于记忆，通常把它分为4个8位的二进制数组成，每8位之间用圆点隔开，格式：X.X.X.X，其中每个X表示地址中的8位，用十进制[0,255]之间值表示，因此我们看到的IP常常是：222.222.88.104。</p><p>Internet委员会定义了5种IP地址类型以适合不同容量的网络，即A类~E类。其中A、B、C这3类由Internet NIC在全球范围内统一分配，D、E类为特殊地址。</p><table><thead><tr><th align="center">类别</th><th align="center">最大网络数</th><th align="center">IP地址范围</th><th align="center">最大主机数</th><th align="center">私有IP地址范围</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">126(2^7-2)</td><td align="center">0.0.0.0-255.255.255.255</td><td align="center">16777214</td><td align="center">10.0.0.0-255.255.255.255</td></tr><tr><td align="center">B</td><td align="center">16384(2^14)</td><td align="center">128.0.0.0-191.255.255.255</td><td align="center">65534</td><td align="center">172.16.0.0-172.31.255.255</td></tr><tr><td align="center">C</td><td align="center">2097152(2^21)</td><td align="center">192.0.0.0-223.255.255.255</td><td align="center">254</td><td align="center">192.168.0.0-192.168.255.255</td></tr></tbody></table><p>IP地址还分为IPV4和IPV6。由于IPv4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。IPv6是IETF（Internet Engineering Task Force）设计的用于替代现行版本IP协议（IPv4）的下一代IP协议，号称可以为全世界的每一粒沙子编上一个网址。IPv4和IPv6地址格式不相同，因此在很长一段时间里，互联网中出现IPv4和IPv6长期共存的局面。2012年6月6日，国际互联网协会举行了世界IPv6启动纪念日，这一天，全球IPv6网络正式启动。多家知名网站，如Google、Facebook和Yahoo等，于当天全球标准时间0点（北京时间8点整）开始永久性支持IPv6访问。2018年6月，三大运营商联合阿里云宣布，将全面对外提供IPv6服务，并计划在2025年前助推中国互联网真正实现“IPv6 Only”。 7月，百度云制定了中国的IPv6改造方案。8月3日，工信部通信司在北京召开IPv6规模部署及专项督查工作全国电视电话会议，中国将分阶段有序推进规模建设IPv6网络，实现下一代互联网在经济社会各领域深度融合。</p><p>IPv6的地址长度为128位，是IPv4地址长度的4倍，格式为X:X:X:X:X:X:X:X，其中每个X表示地址中的16位，以十六进制表示。</p><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>IP地址可以唯一的确定网络上的一个通信实体，但是一个通信实体可以有多个通信程序同时提供网络服务，此时还需要使用端口。IP地址就好比通信的街道和门牌号，我们通过IP地址可以找到房子，但是要具体找到某个人，还需要房间号或名字。</p><p>端口号是一个16位的整数，即在[0,65535]之间，通常它可以分为三类：</p><ol><li><p>公认端口（Well-Known Ports）范围从0到1023，这些端口号一般固定分配给一些服务。比如21端口分配给FTP(文件传输协议)服务，25端口分配给SMTP（简单邮件传输协议）服务，80端口分配给HTTP服务。</p></li><li><p>注册端口（Registered Ports）：端口号从1024到49151。它们松散地绑定于一些服务。例如：Tomcat(8080)，JBOSS(8080)，Oracle（1521）,MySQL(3306)，SQL Server(1433)，QQ（1080）。</p></li><li><p>动态/私有端口（Dynamic and/Private Ports）：端口的范围从49152到65535，这些端口号一般不固定分配给某个服务。只要运行的程序向系统提出访问网络的申请，那么系统就可以从这些端口号中分配一个供该程序使用。理论上，不应为服务分配这些端口。</p></li></ol><p>然而实际生活中，要常人识记IP地址还是有些困难的，所以就有了域名。例如：服务器IP地址是222.222.88.113，为了让大家便于记忆和访问，我们注册了域名。域名和IP地址是相对应的，网域名称系统（DNS，Domain Name System）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP地址数串。</p><h1 id="基本的网络API"><a href="#基本的网络API" class="headerlink" title="基本的网络API"></a>基本的网络API</h1><h2 id="使用InetAddress"><a href="#使用InetAddress" class="headerlink" title="使用InetAddress"></a>使用InetAddress</h2><p>此类表示互联网协议 (IP) 地址，它有两个子类Inet4Address和Inet6Address，分别对应IPV4和IPV6。InetAddress类没有提供公共的构造器，而是提供了如下几个静态方法来获取InetAddress实例。</p><p><strong>静态方法：</strong></p><ul><li>public static InetAddress getLocalHost()</li><li>public static InetAddress getByAddress(byte[] addr)</li><li>public static InetAddress getByName(String host)</li></ul><p><strong>InetAddress提供了如下几个常用的方法：</strong></p><ul><li>public String getHostAddress()：返回 IP 地址字符串（以文本表现形式）</li><li>public String getHostName()：获取此 IP 地址的主机名</li><li>public String getCanonicalHostName()：获取此 IP 地址的完全限定域名</li><li>public boolean isReachable(int timeout)：测试是否可以达到该地址。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.ip;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInetAddress</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">InetAddress ip1 = InetAddress.getLocalHost();</span><br><span class="line">System.out.println(ip1);<span class="comment">//Irene-PC/192.168.1.107</span></span><br><span class="line"></span><br><span class="line">InetAddress ip2 = InetAddress.getByName(<span class="string">"www.unclehe.net"</span>);</span><br><span class="line">System.out.println(ip2);<span class="comment">//www.unclehe.net/222.222.88.102</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] ip = &#123;(<span class="keyword">byte</span>)<span class="number">222</span>,(<span class="keyword">byte</span>)<span class="number">222</span>,<span class="number">88</span>,<span class="number">102</span>&#125;;</span><br><span class="line">InetAddress ip3 = InetAddress.getByAddress(ip);</span><br><span class="line">System.out.println(ip3);<span class="comment">//输出ip而不是域名。如果这个IP地址不存在或DNS服务器不允许进行ip--&gt;域名的映射，getHostName()方法就直接返回这个IP地址</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用URL"><a href="#使用URL" class="headerlink" title="使用URL"></a>使用URL</h2><p>URI(Uniform resource identifier)：表示一个统一资源标识符 (URI) 引用，用来唯一的标识一个资源。</p><p>URL(Uniform Resource Locator)：类 URL 代表一个统一资源定位符，它是指向互联网“资源”的指针。资源可以是简单的文件或目录，也可以是对更为复杂的对象的引用，例如对数据库或搜索引擎的查询。它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。URI不能用于定位任何资源，它的唯一作用是解析，而URL则包含一个可打开到达该资源的输入流。 URL的基本结构由5部分组成：</p><p>&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名</p><p>&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;?参数列表</p><p>其中#片段名：即锚点，例如看小说，直接定位到章节</p><p>例如：<a href="http://java.sun.com/index.html#chapter1" target="_blank" rel="noopener">http://java.sun.com/index.html#chapter1</a></p><p>参数列表格式：参数名=参数值&amp;参数名=参数值….</p><p>例如：<a href="http://192.168.1.100:8080/helloworld/index.jsp?username=admin&amp;password=123" target="_blank" rel="noopener">http://192.168.1.100:8080/helloworld/index.jsp?username=admin&amp;password=123</a></p><p><strong>URL构造方法：</strong></p><ul><li><p>public URL (String spec)：通过一个表示URL地址的字符串可以构造一个URL对象。</p><p>例如：URL url = new URL (“<a href="http://www.unclehe.net/&quot;">http://www.unclehe.net/&quot;</a>);</p></li><li><p>public URL(URL context, String spec)：通过基 URL 和相对 URL 构造一个 URL 对象。</p><p>例如：URL downloadUrl = new URL(url, “download.html”)</p></li><li><p>public URL(String protocol, String host, String file); </p><p>例如：new URL(“http”, “<a href="http://www.unclehe.net&quot;" target="_blank" rel="noopener">www.unclehe.net&quot;</a>, “download. html”);</p></li><li><p>public URL(String protocol, String host, int port, String file); </p><p>例如: URL gamelan = new URL(“http”, “<a href="http://www.unclehe.net&quot;" target="_blank" rel="noopener">www.unclehe.net&quot;</a>, 80, “download.html”);</p></li></ul><p><strong>URL的常用方法：</strong></p><ul><li>public String getProtocol()：获取该URL的协议名</li><li>public String getHost()：获取该URL的主机名</li><li>public String getPort()：获取该URL的端口号</li><li>public String getPath()：获取该URL的文件路径，即tomcat的webapps目录下级目录名也就是资源路径名</li><li>public String getFile()：获取该URL的文件名</li><li>public String getRef()：获取该URL在文件中的相对位置</li><li>public String getQuery()：获取该URL的查询名</li><li>public final InputStream openStream()：返回一个用于从该连接读入的 InputStream。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestURL</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com:80/index.html?keyword=java"</span>);</span><br><span class="line">System.out.println(<span class="string">"协议："</span> + url.getProtocol());</span><br><span class="line">System.out.println(<span class="string">"主机名："</span> + url.getHost());</span><br><span class="line">System.out.println(<span class="string">"端口号："</span> + url.getPort());</span><br><span class="line">System.out.println(<span class="string">"路径名："</span> + url.getPath());</span><br><span class="line">System.out.println(<span class="string">"文件名："</span> + url.getFile());</span><br><span class="line">System.out.println(<span class="string">"锚点："</span> + url.getRef());</span><br><span class="line">System.out.println(<span class="string">"查询名："</span> + url.getQuery());<span class="comment">//注意如果存在锚点，那么查询名返回null，因为#后面全部当做锚点了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestURLRead</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com/index.html"</span>);</span><br><span class="line"><span class="comment">/*html标签（格式化数据）、css：皮肤（美化数据）、js：互动（交互数据）、数据：*/</span></span><br><span class="line">InputStream input = url.openStream();</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=input.read(data))!=-<span class="number">1</span>)&#123;</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(data,<span class="number">0</span>,len,<span class="string">"UTF-8"</span>));</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用URLConnection"><a href="#使用URLConnection" class="headerlink" title="使用URLConnection"></a>使用URLConnection</h2><p>URL的方法openStream()，能从网络上读取数据，但是无法给服务器端发送数据，若希望给服务器端发送数据，则需URLConnection。</p><p>它代表应用程序和 URL 之间的通信链接。此类的实例可用于读取和写入此 URL 引用的资源。通常，创建一个到 URL 的连接需要几个步骤：</p><ol><li>通过 URL对象调用 openConnection 方法创建URLConnection连接对象。</li><li>处理设置参数和一般请求属性。</li><li>使用 connect 方法建立到远程对象的实际连接。</li><li>远程对象变为可用。远程对象的头字段和内容变为可访问。</li></ol><p><strong>URLConnection的常用方法：</strong></p><ul><li>public void setDoOutput(boolean dooutput)如果打算使用 URL 连接进行输出，例如给服务器传递请求参数，则将 DoOutput 标志设置为 true；如果不打算使用，则设置为 false。默认值为 false。 <code>必须在所有getXXX()和connect()方法之前。</code></li><li>public String getContentEncoding()：返回 content-encoding 头字段的值。</li><li>public int getContentLength()：返回 content-length 头字段的值。</li><li>public String getContentType()：返回 content-type 头字段的值。</li><li>public long getDate()：返回 date 头字段的值。</li><li>public long getLastModified()：返回 last-modified 头字段的值。结果为距离格林威治标准时间 1970 年 1 月 1 日的毫秒数。</li><li>public String getHeaderField(String name)：返回指定的头字段的值。</li><li>public InputStream getInputStream()返回从此打开的连接读取的输入流。</li><li>public OutputStream getOutputStream()返回写入到此连接的输出流。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestURLConnection</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://localhost/web1/denglu"</span>);</span><br><span class="line"><span class="comment">//通过 URL对象调用 openConnection 方法创建URLConnection连接对象</span></span><br><span class="line">URLConnection uc = url.openConnection();</span><br><span class="line"><span class="comment">//处理设置参数</span></span><br><span class="line">uc.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//给服务器发送请求参数</span></span><br><span class="line">uc.getOutputStream().write(<span class="string">"username=admin&amp;password=123"</span>.getBytes());</span><br><span class="line"><span class="comment">//使用 connect 方法建立到远程对象的实际连接。</span></span><br><span class="line">uc.connect();</span><br><span class="line"><span class="comment">//获取资源</span></span><br><span class="line">InputStream is = uc.getInputStream();</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is,<span class="string">"UTF-8"</span>));</span><br><span class="line">String str;</span><br><span class="line"><span class="keyword">while</span>((str=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">br.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>通信的两端都要有Socket（也可以叫“套接字”），是两台机器间通信的端点。网络通信其实就是Socket间的通信。Socket可以分为：</p><ul><li>流套接字（stream socket）：使用TCP提供可依赖的字节流服务</li><li>数据报套接字（datagram socket）：使用UDP提供“尽力而为”的数据报服务</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/network-programming3.png" alt="network-programming"></p><p><strong>Socket类的常用构造方法：</strong></p><ul><li>public Socket(InetAddress address,int port)：创建一个流套接字并将其连接到指定 IP 地址的指定端口号。</li><li>public Socket(String host,int port)：创建一个流套接字并将其连接到指定主机上的指定端口号。</li></ul><p><strong>Socket类的常用方法：</strong></p><ul><li>public InputStream getInputStream()：返回此套接字的输入流，可以用于接收消息</li><li>public OutputStream getOutputStream()：返回此套接字的输出流，可以用于发送消息</li><li>public InetAddress getInetAddress()：此套接字连接到的远程 IP 地址；如果套接字是未连接的，则返回 null。</li><li>public InetAddress getLocalAddress()：获取套接字绑定的本地地址。</li><li>public int getPort()：此套接字连接到的远程端口号；如果尚未连接套接字，则返回 0。</li><li>public int getLocalPort()：返回此套接字绑定到的本地端口。如果尚未绑定套接字，则返回 -1。</li><li>public void close()：关闭此套接字。套接字被关闭后，便不可在以后的网络连接中使用（即无法重新连接或重新绑定）。需要创建新的套接字对象。 关闭此套接字也将会关闭该套接字的 InputStream 和 OutputStream。</li><li>public void shutdownInput()：如果在套接字上调用 shutdownInput() 后从套接字输入流读取内容，则流将返回 EOF（文件结束符）。 即不能在从此套接字的输入流中接收任何数据。</li><li>public void shutdownOutput()：禁用此套接字的输出流。对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 如果在套接字上调用 shutdownOutput() 后写入套接字输出流，则该流将抛出 IOException。 即不能通过此套接字的输出流发送任何数据。</li></ul><p>注意：先后调用Socket的shutdownInput()和shutdownOutput()方法，仅仅关闭了输入流和输出流，并不等于调用Socket的close()方法。在通信结束后，仍然要调用Scoket的close()方法，因为只有该方法才会释放Socket占用的资源，比如占用的本地端口号等。</p><h1 id="基于TCP协议的网络编程"><a href="#基于TCP协议的网络编程" class="headerlink" title="基于TCP协议的网络编程"></a>基于TCP协议的网络编程</h1><p>TCP(Transmission Control Protocol，传输控制协议)被称作一种端对端协议。是一种面向连接的、可靠的、基于字节流的传输层的通信协议，可以连续传输大量的数据。类似于打电话的效果。</p><p>这是因为它为当一台计算机需要与另一台远程计算机连接时，TCP协议会采用“三次握手”方式让它们建立一个连接，用于发送和接收数据的虚拟链路。数据传输完毕TCP协议会采用“四次挥手”方式断开连接。</p><p>TCP协议负责收集这些信息包，并将其按适当的次序放好传送，在接收端收到后再将其正确的还原。TCP协议保证了数据包在传送中准确无误。TCP协议使用重发机制，当一个通信实体发送一个消息给另一个通信实体后，需要收到另一个通信实体确认信息，如果没有收到另一个通信实体确认信息，则会再次重复刚才发送的消息。</p><h2 id="基于TCP协议的网络通信程序结构"><a href="#基于TCP协议的网络通信程序结构" class="headerlink" title="基于TCP协议的网络通信程序结构"></a>基于TCP协议的网络通信程序结构</h2><p>Java语言的基于套接字TCP编程分为服务端编程和客户端编程</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/network-programming4.png" alt="network-programming"></p><p><strong>服务器程序的工作过程包含以下五个基本的步骤：</strong></p><ol><li>使用 ServerSocket(int port) ：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。</li><li>调用 accept()方法：监听连接请求，如果客户端请求连接，则接受连接，创建与该客户端的通信套接字对象。否则该方法将一直处于等待状态。</li><li>调用 该Socket对象的 getOutputStream() 和 getInputStream ()：获取输出流和输入流，开始网络数据的发送和接收。</li><li>关闭Socket对象：某客户端访问结束，关闭与之通信的套接字。</li><li>关闭ServerSocket：如果不再接收任何客户端的连接的话，调用close()进行关闭。</li></ol><p><strong>客户端Socket的工作过程包含以下四个基本的步骤：</strong></p><ol><li>创建 Socket：根据指定服务端的 IP 地址或端口号构造 Socket 类对象，创建的同时会自动向服务器方发起连接。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。</li><li>打开连接到Socket 的输入/出流：使用 getInputStream()方法获得输入流，使用 getOutputStream()方法获得输出流，进行数据传输。</li><li>进行读/写操作：通过输入流读取服务器发送的信息，通过输出流将信息发送给服务器。</li><li>关闭 Socket：断开客户端到服务器的连接</li></ol><p>注意：客户端和服务器端在获取输入流和输出流时要对应，否则容易死锁。例如：客户端先获取字节输出流（即先写），那么服务器端就先获取字节输入流（即先读）；反过来客户端先获取字节输入流（即先读），那么服务器端就先获取字节输出流（即先写）。</p><h2 id="TCP协议编程示例一"><a href="#TCP协议编程示例一" class="headerlink" title="TCP协议编程示例一"></a>TCP协议编程示例一</h2><p>一个客户端连接服务器，连接成功后，服务器给客户端发送“欢迎你登录”</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TCP：面向连接，可靠的，基于字节流的</span></span><br><span class="line"><span class="comment"> * 服务器：等待被连接的过程</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * ServerSocket：只负责接受和建立连接，不负责数据的传输</span></span><br><span class="line"><span class="comment"> * Socket：负责数据的传输</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 步骤：</span></span><br><span class="line"><span class="comment"> * 1、开启服务器</span></span><br><span class="line"><span class="comment"> *   指定服务器监听的端口号</span></span><br><span class="line"><span class="comment"> * 2、等待客户端并接受客户端的连接</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3、接受/发送数据</span></span><br><span class="line"><span class="comment"> * 发送方：输出流</span></span><br><span class="line"><span class="comment"> * 接受方：输入流</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4、断开连接</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 5、关闭服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1、开启服务器：网卡驱动就监听9999端口号的数据</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、等待客户端并接受客户端的连接</span></span><br><span class="line">Socket socket = server.accept();<span class="comment">//这句代码执行一次，就接受一个客户端连接</span></span><br><span class="line">System.out.println(<span class="string">"一个客户端连接成功!"</span>);</span><br><span class="line"><span class="comment">//3、例如：发送数据</span></span><br><span class="line"><span class="comment">//发送：欢迎你登录</span></span><br><span class="line"><span class="comment">//字节流，输出流  OutputStream</span></span><br><span class="line"><span class="comment">//(1)获取输出流</span></span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line"><span class="comment">//(2)发送数据</span></span><br><span class="line">out.write(<span class="string">"欢迎你登录"</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、断开连接</span></span><br><span class="line">socket.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、关闭服务器</span></span><br><span class="line">server.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TCP：</span></span><br><span class="line"><span class="comment"> *  客户端，主动连接服务器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Socket(InetAddress address, int port) </span></span><br><span class="line"><span class="comment"> * Socket(String host, int port)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 步骤：</span></span><br><span class="line"><span class="comment"> * 1、连接服务器</span></span><br><span class="line"><span class="comment"> * Socket socket = new Socket("192.168.30.142",9999);</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2、发送或接受数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3、断开连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//1、连接服务器</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"192.168.30.142"</span>,<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、例如：接受数据</span></span><br><span class="line"><span class="comment">//字节流，输入流，InputStream</span></span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = in.read(data)) != -<span class="number">1</span>)&#123;</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(data,<span class="number">0</span>,len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、断开</span></span><br><span class="line">socket.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP协议编程示例二"><a href="#TCP协议编程示例二" class="headerlink" title="TCP协议编程示例二"></a>TCP协议编程示例二</h2><p>一个客户端连接服务器，连接成功后，客户端给服务器先传一个“你好”，服务器给客户端返回“欢迎你登录”</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1、开启服务器：网卡驱动就监听9999端口号的数据</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、等待客户端并接受客户端的连接</span></span><br><span class="line">Socket socket = server.accept();<span class="comment">//这句代码执行一次，就接受一个客户端连接</span></span><br><span class="line">System.out.println(<span class="string">"一个客户端连接成功!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、接受数据</span></span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">System.out.println(<span class="string">"服务器收到："</span>);</span><br><span class="line"><span class="keyword">while</span>((len = in.read(data)) != -<span class="number">1</span>)&#123;</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(data,<span class="number">0</span>,len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、例如：发送数据</span></span><br><span class="line"><span class="comment">//发送：欢迎你登录</span></span><br><span class="line"><span class="comment">//字节流，输出流  OutputStream</span></span><br><span class="line"><span class="comment">//(1)获取输出流</span></span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line"><span class="comment">//(2)发送数据</span></span><br><span class="line">out.write(<span class="string">"欢迎你登录"</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、断开连接</span></span><br><span class="line">socket.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、关闭服务器</span></span><br><span class="line">server.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//1、连接服务器</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"192.168.30.142"</span>,<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、例如：发送你好</span></span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line">out.write(<span class="string">"你好"</span>.getBytes());</span><br><span class="line"><span class="comment">//out.close();//错误的，如果调用out.close()会导致socket的close()</span></span><br><span class="line"><span class="comment">//如果仅仅表示不发送了，还要接收，那么选择半关闭，只关闭输出通道</span></span><br><span class="line">socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、例如：接受数据</span></span><br><span class="line"><span class="comment">//字节流，输入流，InputStream</span></span><br><span class="line">System.out.println(<span class="string">"客户端收到："</span>);</span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = in.read(data)) != -<span class="number">1</span>)&#123;</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(data,<span class="number">0</span>,len));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、断开</span></span><br><span class="line">socket.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP协议编程示例三"><a href="#TCP协议编程示例三" class="headerlink" title="TCP协议编程示例三"></a>TCP协议编程示例三</h2><p>一个客户端连接服务器，连接成功后：</p><ol><li>客户端从键盘输入词语，给服务器发送，直到bye为止；</li><li>服务器每次手动词语，反转词语 ，然后返回给客户端，直到接收到bye为止</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 服务器端：</span></span><br><span class="line"><span class="comment"> * (1)接收客户端的连接</span></span><br><span class="line"><span class="comment"> *  (2)接收客户端的词语</span></span><br><span class="line"><span class="comment"> *  (3)把词语“反转”返回给客户端</span></span><br><span class="line"><span class="comment"> *  (2)(3)多次，直到客户端发送"bye"为止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1、开启服务器</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8989</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、接收一个客户端的连接</span></span><br><span class="line">Socket socket = server.accept();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、先获取输入流和输出流</span></span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 因为是接收一个词语，反转一个，返回一个</span></span><br><span class="line"><span class="comment"> * 那么如果仅仅使用字节流，不好区分词语</span></span><br><span class="line"><span class="comment"> * 需要用到字符流</span></span><br><span class="line"><span class="comment"> * 那么就意味着需要把字节流转为字符流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);<span class="comment">//这里不涉及编码问题，仅仅为了转换流的类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字符流中几个字符是一个词语</span></span><br><span class="line"><span class="comment"> * 那么我们这里选择“换行符”来作为词语的分割</span></span><br><span class="line"><span class="comment"> * 意味着我们可以按行读取Scanner或BufferedReader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 客户端收到字节，同样不方便处理几个字节是一个词语，仍然要把字节输出流转为字符流</span></span><br><span class="line"><span class="comment"> * 而且字符之间也不好区分，那么也选择“换行符”进行区别词语</span></span><br><span class="line"><span class="comment"> * 我们现在需要把OutputStream转为一个可以按行写的字符流或其他的处理流</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 可以按行写的：BufferedWriter(newLine())</span></span><br><span class="line"><span class="comment"> *    PrintStream(println())</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(out);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从客户端接收词语</span></span><br><span class="line">String word;</span><br><span class="line"><span class="keyword">while</span>((word = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"bye"</span>.equals(word))&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不是bye，要反转，并且返回</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(word);</span><br><span class="line">sb.reverse();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回给客户端</span></span><br><span class="line">ps.println(sb.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、断开</span></span><br><span class="line">socket.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、关闭服务器</span></span><br><span class="line">server.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 客户端：</span></span><br><span class="line"><span class="comment"> * （1）从键盘输入词语</span></span><br><span class="line"><span class="comment"> * （2）发送给服务器</span></span><br><span class="line"><span class="comment"> * （3）接收服务器返回的结果</span></span><br><span class="line"><span class="comment"> * （1）（2）（3）多次进行，直到键盘输入bye并发送给发服务器之后就结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//1、连接服务器</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"192.168.30.142"</span>,<span class="number">8989</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  * （1）从键盘输入词语</span></span><br><span class="line"><span class="comment"> * （2）发送给服务器</span></span><br><span class="line"><span class="comment"> * （3）接收服务器返回的结果</span></span><br><span class="line"><span class="comment"> * （1）（2）（3）多次进行，直到键盘输入bye并发送给发服务器之后就结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 同样考虑到发送词语，以及词语之间分割问题，那我们选择PrintStream和BufferedReader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//从键盘输入词语</span></span><br><span class="line">System.out.print(<span class="string">"请输入词语："</span>);</span><br><span class="line">String word = input.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送给服务器端</span></span><br><span class="line">ps.println(word);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">"bye"</span>.equals(word))&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收服务器返回的结果</span></span><br><span class="line">String result = br.readLine();</span><br><span class="line">System.out.println(<span class="string">"服务器返回的反转后的结果："</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input.close();</span><br><span class="line">socket.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP协议编程示例四"><a href="#TCP协议编程示例四" class="headerlink" title="TCP协议编程示例四"></a>TCP协议编程示例四</h2><p><strong>多个客户端</strong>同时连接服务器，连接成功后：</p><ol><li>客户端从键盘输入词语，给服务器发送，直到bye为止；</li><li>服务器每次手动词语，反转词语 ，然后返回给客户端，直到接收到bye为止</li></ol><p>示意图：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/network-programming5.png" alt="network-programming"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 服务器端：</span></span><br><span class="line"><span class="comment"> * (1)接收客户端的连接</span></span><br><span class="line"><span class="comment"> *  (2)接收客户端的词语</span></span><br><span class="line"><span class="comment"> *  (3)把词语“反转”返回给客户端</span></span><br><span class="line"><span class="comment"> *  (2)(3)多次，直到客户端发送"bye"为止</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> *  加一个条件，服务器端可以同时接收n个客户端连接</span></span><br><span class="line"><span class="comment"> *  服务器端得加多线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1、开启服务器</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8989</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag)&#123;</span><br><span class="line"><span class="comment">//2、接收一个客户端的连接</span></span><br><span class="line">Socket socket = server.accept();<span class="comment">//每个客户端的socket是独立的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为没一个客户端开启一个独立的线程维护它的通信</span></span><br><span class="line">MessageHandler mh = <span class="keyword">new</span> MessageHandler(socket);</span><br><span class="line">mh.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、关闭服务器</span></span><br><span class="line">server.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MessageHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.socket = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//3、先获取输入流和输出流</span></span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 因为是接收一个词语，反转一个，返回一个</span></span><br><span class="line"><span class="comment"> * 那么如果仅仅使用字节流，不好区分词语</span></span><br><span class="line"><span class="comment"> * 需要用到字符流</span></span><br><span class="line"><span class="comment"> * 那么就意味着需要把字节流转为字符流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);<span class="comment">//这里不涉及编码问题，仅仅为了转换流的类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字符流中几个字符是一个词语</span></span><br><span class="line"><span class="comment"> * 那么我们这里选择“换行符”来作为词语的分割</span></span><br><span class="line"><span class="comment"> * 意味着我们可以按行读取Scanner或BufferedReader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 客户端收到字节，同样不方便处理几个字节是一个词语，仍然要把字节输出流转为字符流</span></span><br><span class="line"><span class="comment"> * 而且字符之间也不好区分，那么也选择“换行符”进行区别词语</span></span><br><span class="line"><span class="comment"> * 我们现在需要把OutputStream转为一个可以按行写的字符流或其他的处理流</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 可以按行写的：BufferedWriter(newLine())</span></span><br><span class="line"><span class="comment"> *    PrintStream(println())</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(out);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从客户端接收词语</span></span><br><span class="line">String word;</span><br><span class="line"><span class="keyword">while</span>((word = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"bye"</span>.equals(word))&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不是bye，要反转，并且返回</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(word);</span><br><span class="line">sb.reverse();</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回给客户端</span></span><br><span class="line">ps.println(sb.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//4、断开</span></span><br><span class="line">socket.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 客户端：</span></span><br><span class="line"><span class="comment"> * （1）从键盘输入词语</span></span><br><span class="line"><span class="comment"> * （2）发送给服务器</span></span><br><span class="line"><span class="comment"> * （3）接收服务器返回的结果</span></span><br><span class="line"><span class="comment"> * （1）（2）（3）多次进行，直到键盘输入bye并发送给发服务器之后就结束</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 加一个条件，服务器端可以同时接收n个客户端连接</span></span><br><span class="line"><span class="comment"> * 客户端代码不用修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//1、连接服务器</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"192.168.30.142"</span>,<span class="number">8989</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * （1）从键盘输入词语</span></span><br><span class="line"><span class="comment"> * （2）发送给服务器</span></span><br><span class="line"><span class="comment"> * （3）接收服务器返回的结果</span></span><br><span class="line"><span class="comment"> * （1）（2）（3）多次进行，直到键盘输入bye并发送给发服务器之后就结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 同样考虑到发送词语，以及词语之间分割问题，那我们选择PrintStream和BufferedReader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(socket.getOutputStream());</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//从键盘输入词语</span></span><br><span class="line">System.out.print(<span class="string">"请输入词语："</span>);</span><br><span class="line">String word = input.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送给服务器端</span></span><br><span class="line">ps.println(word);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">"bye"</span>.equals(word))&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收服务器返回的结果</span></span><br><span class="line">String result = br.readLine();</span><br><span class="line">System.out.println(<span class="string">"服务器返回的反转后的结果："</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input.close();</span><br><span class="line">socket.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP协议编程示例五"><a href="#TCP协议编程示例五" class="headerlink" title="TCP协议编程示例五"></a>TCP协议编程示例五</h2><p>一个客户端连接服务器，连接成功后，给服务器上传一个文件，服务器接收到文件后存到upload的文件夹中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从客户端发送文件到服务器端</span></span><br><span class="line"><span class="comment"> * (1)接收客户端的连接</span></span><br><span class="line"><span class="comment"> * (2)接收文件名.后缀名</span></span><br><span class="line"><span class="comment"> * 思考：</span></span><br><span class="line"><span class="comment"> *  存哪里   ①在当前项目中找一个位置存储，例如：upload文件夹</span></span><br><span class="line"><span class="comment"> *  ②如何解决文件名重名的问题         文件名需要处理，加入时间戳或其他的唯一编码的UUID等值</span></span><br><span class="line"><span class="comment"> *  ③.后缀名需要保留，因为它代表文件的类型</span></span><br><span class="line"><span class="comment"> * (3)接收文件内容</span></span><br><span class="line"><span class="comment"> * (4)反馈结果</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 思考：</span></span><br><span class="line"><span class="comment"> * 这里既要接收文件名.后缀名，又要接收文件内容。</span></span><br><span class="line"><span class="comment"> * 这里既有  文本信息“文件名.后缀名”，又有其他类型的数据“文件内容”，只能选择字节流。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 如何区别，文件名.后缀名   与  文件内容呢</span></span><br><span class="line"><span class="comment"> * 想哪种字节输入流，可以处理字符串，和字节类型的数据。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * FileInputStream</span></span><br><span class="line"><span class="comment"> * BufferedInputStream</span></span><br><span class="line"><span class="comment"> * DataInputStream</span></span><br><span class="line"><span class="comment"> * ObjectInputStream</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这些里面：DataInputStream：readUTF() 和  read(byte[])</span></span><br><span class="line"><span class="comment"> * ObjectInputStream也可以，但是麻烦，我这里选择DataInputStream</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1、开启服务器</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、接收客户端的连接</span></span><br><span class="line">Socket socket = server.accept();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、获取输入流</span></span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(in);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收文件名.后缀名</span></span><br><span class="line">String fileName = dis.readUTF();</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理文件名</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 希望我要在服务器存储的文件名：   原来的文件名 + 时间戳</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">long</span> timestamp = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//.的下标</span></span><br><span class="line"><span class="keyword">int</span> index = fileName.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line"><span class="comment">//后缀名</span></span><br><span class="line">String ext = fileName.substring(index);</span><br><span class="line"><span class="comment">// 原来的文件名</span></span><br><span class="line">String name = fileName.substring(<span class="number">0</span>, index);</span><br><span class="line"><span class="comment">//新文件名</span></span><br><span class="line">String newFileName = <span class="string">"upload/"</span> + name + timestamp + ext;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建文件输出流，把接收到的文件内容，写入新文件</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(newFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收文件内容</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = dis.read(data))!=-<span class="number">1</span>)&#123;</span><br><span class="line">fos.write(data, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以给客户端反馈：文件接收完毕</span></span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(out);</span><br><span class="line">ps.println(<span class="string">"文件接收完毕!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//断开</span></span><br><span class="line">fos.close();</span><br><span class="line">socket.close();</span><br><span class="line">server.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test14;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从客户端发送文件到服务器端</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 客户端：</span></span><br><span class="line"><span class="comment"> * （1）从键盘输入文件的路径名，即选择要发送的文件</span></span><br><span class="line"><span class="comment"> * （2）给服务器先把“文件名.后缀名"</span></span><br><span class="line"><span class="comment"> * （3）发送文件内容</span></span><br><span class="line"><span class="comment"> * （4）接收服务器的反馈结果</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这里同样因为既要发送“文件名.后缀名"，又要发送“文件内容”，选择字节流，选择DataOutputStream</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//1、连接服务器</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"192.168.30.142"</span>,<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、从键盘输入文件的路径名，即选择要发送的文件</span></span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.print(<span class="string">"请选择你要发送的文件（例如：D:/JavaSE/资料.rar）："</span>);</span><br><span class="line">String fileName = input.nextLine();</span><br><span class="line">File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、给服务器发送“文件名.后缀名"</span></span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line">DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(out);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送“文件名.后缀名"</span></span><br><span class="line">dos.writeUTF(file.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、发送文件内容</span></span><br><span class="line"><span class="comment">//先从file文件读取内容</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = fis.read(data)) != -<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//一边读，一边给服务器发送</span></span><br><span class="line">dos.write(data,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line">socket.shutdownOutput();<span class="comment">//表示发送完毕了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5、接收反馈</span></span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">String result = br.readLine();</span><br><span class="line">System.out.println(<span class="string">"结果："</span> + result);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6、关闭</span></span><br><span class="line">socket.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP协议编程示例六"><a href="#TCP协议编程示例六" class="headerlink" title="TCP协议编程示例六"></a>TCP协议编程示例六</h2><p>多个客户端连接服务器，连接成功后，给服务器上传一个文件，服务器接收到文件后存到upload的文件夹中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test15;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1、开启服务器</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//2、接收客户端的连接</span></span><br><span class="line">Socket socket = server.accept();</span><br><span class="line"></span><br><span class="line">FileUploadThread ft = <span class="keyword">new</span> FileUploadThread(socket);</span><br><span class="line">ft.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//server.close();//不关闭服务器</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileUploadThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileUploadThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.socket = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//3、获取输入流</span></span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line">DataInputStream dis = <span class="keyword">new</span> DataInputStream(in);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收文件名.后缀名</span></span><br><span class="line">String fileName = dis.readUTF();</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理文件名</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 希望我要在服务器存储的文件名：   原来的文件名 + 时间戳</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">long</span> timestamp = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//.的下标</span></span><br><span class="line"><span class="keyword">int</span> index = fileName.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line"><span class="comment">//后缀名</span></span><br><span class="line">String ext = fileName.substring(index);</span><br><span class="line"><span class="comment">// 原来的文件名</span></span><br><span class="line">String name = fileName.substring(<span class="number">0</span>, index);</span><br><span class="line"><span class="comment">//新文件名</span></span><br><span class="line">String newFileName = <span class="string">"upload/"</span> + name + timestamp + ext;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建文件输出流，把接收到的文件内容，写入新文件</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(newFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收文件内容</span></span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = dis.read(data))!=-<span class="number">1</span>)&#123;</span><br><span class="line">fos.write(data, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以给客户端反馈：文件接收完毕</span></span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(out);</span><br><span class="line">ps.println(<span class="string">"文件接收完毕!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//断开</span></span><br><span class="line">fos.close();</span><br><span class="line">socket.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test15;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.DataOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//1、连接服务器</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"192.168.30.142"</span>,<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、从键盘输入文件的路径名，即选择要发送的文件</span></span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.print(<span class="string">"请选择你要发送的文件（例如：D:/尚硅谷_190513班_柴林燕_JavaSE/开学典礼所发资料.rar）："</span>);</span><br><span class="line">String fileName = input.nextLine();</span><br><span class="line">File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、给服务器发送“文件名.后缀名"</span></span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line">DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(out);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送“文件名.后缀名"</span></span><br><span class="line">dos.writeUTF(file.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、发送文件内容</span></span><br><span class="line"><span class="comment">//先从file文件读取内容</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = fis.read(data)) != -<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//一边读，一边给服务器发送</span></span><br><span class="line">dos.write(data,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line">socket.shutdownOutput();<span class="comment">//表示发送完毕了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5、接收反馈</span></span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">String result = br.readLine();</span><br><span class="line">System.out.println(<span class="string">"结果："</span> + result);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6、关闭</span></span><br><span class="line">socket.close();</span><br><span class="line">fis.close();</span><br><span class="line">input.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP协议编程示例七"><a href="#TCP协议编程示例七" class="headerlink" title="TCP协议编程示例七"></a>TCP协议编程示例七</h2><p>群聊</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Socket&gt; online = <span class="keyword">new</span> ArrayList&lt;Socket&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1、开启服务器</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//2、接收客户端的连接</span></span><br><span class="line">Socket socket = server.accept();</span><br><span class="line"></span><br><span class="line"><span class="comment">//把这个客户端加入到online中</span></span><br><span class="line">online.add(socket);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个客户端独立的线程</span></span><br><span class="line">MessageHandler mh = <span class="keyword">new</span> MessageHandler(socket);</span><br><span class="line">mh.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有的静态的内部类</span></span><br><span class="line"><span class="comment">//这里用内部类的原因，是为了用上面的online集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Socket socket;</span><br><span class="line"><span class="keyword">private</span> String ip;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MessageHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.socket = socket;</span><br><span class="line"><span class="keyword">this</span>.ip = socket.getInetAddress().getHostAddress();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//这个客户端的一连接成功，线程一启动，就可以告诉其他人我上线了</span></span><br><span class="line">sendToOthers(ip+<span class="string">"上线了"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * （1）接收当前的客户端发送的消息</span></span><br><span class="line"><span class="comment"> * （2）给其他在线的客户端转发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//（1）接收当前的客户端发送的消息</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">String content;</span><br><span class="line"><span class="keyword">while</span>((content = br.readLine()) !=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"bye"</span>.equals(content))&#123;</span><br><span class="line"><span class="comment">//给自己发一句bye</span></span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(out);</span><br><span class="line">ps.println(<span class="string">"bye"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收到一句，转发一句</span></span><br><span class="line">sendToOthers(ip+<span class="string">"说:"</span> + content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sendToOthers(ip+<span class="string">"下线了"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">sendToOthers(ip+<span class="string">"掉线了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为转发的代码也很长，独立为一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendToOthers</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"><span class="comment">//遍历所有online的客户端</span></span><br><span class="line">Iterator&lt;Socket&gt; iterator = online.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">Socket on = iterator.next();</span><br><span class="line"><span class="keyword">if</span>(!on.equals(socket))&#123;<span class="comment">//只给其他客户端转发</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">OutputStream out = on.getOutputStream();</span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(out);</span><br><span class="line"></span><br><span class="line">ps.println(str);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">//说明on这个客户端要么下线了，要么掉线了</span></span><br><span class="line">iterator.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test16;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 群聊</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//1、连接服务器</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(<span class="string">"192.168.30.142"</span>,<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、开启两个线程，一个收消息，一个发消息</span></span><br><span class="line">SendThread st = <span class="keyword">new</span> SendThread(socket);</span><br><span class="line">ReceiveThread rt = <span class="keyword">new</span> ReceiveThread(socket);</span><br><span class="line"></span><br><span class="line">st.start();</span><br><span class="line">rt.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//等发送线程停下来再往下走</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">st.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让接收数据的线程停下</span></span><br><span class="line">rt.setFlag(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等接收线程停下来，再往下走，断开连接</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">rt.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">socket.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SendThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.socket = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//键盘输入</span></span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">OutputStream out = socket.getOutputStream();</span><br><span class="line">PrintStream ps = <span class="keyword">new</span> PrintStream(out);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//从键盘输入</span></span><br><span class="line">System.out.print(<span class="string">"请输入要发送的消息："</span>);</span><br><span class="line">String content = input.nextLine();</span><br><span class="line">System.out.println(<span class="string">"content:"</span> + content);</span><br><span class="line"></span><br><span class="line"><span class="comment">//给服务器发送</span></span><br><span class="line">ps.println(content);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果bye，就结束发送</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">"bye"</span>.equals(content))&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiveThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Socket socket;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReceiveThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.socket = socket;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InputStream in = socket.getInputStream();</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(flag)&#123;</span><br><span class="line">String line = br.readLine();</span><br><span class="line">System.out.println(line);</span><br><span class="line"><span class="keyword">if</span>(<span class="string">"bye"</span>.equals(line))&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.flag = flag;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于UDP协议的网络编程"><a href="#基于UDP协议的网络编程" class="headerlink" title="基于UDP协议的网络编程"></a>基于UDP协议的网络编程</h1><p>UDP(User Datagram Protocol，用户数据报协议)：是一个无连接的传输层协议、提供面向事务的简单不可靠的信息传送服务，类似于短信。</p><p>UDP协议是一种<strong>面向非连接</strong>的协议，面向非连接指的是在正式通信前不必与对方先建立连接，不管对方状态就直接发送，至于对方是否可以接收到这些数据内容，UDP协议无法控制，因此说，UDP协议是一种<strong>不可靠的</strong>协议。无连接的好处就是快，省内存空间和流量，因为维护连接需要创建大量的数据结构。UDP会尽最大努力交付数据，但不保证可靠交付，没有TCP的确认机制、重传机制，如果因为网络原因没有传送到对端，UDP也不会给应用层返回错误信息。</p><p>UDP协议是面向数据报文的信息传送服务。UDP在发送端没有缓冲区，对于应用层交付下来的报文在添加了首部之后就直接交付于ip层，不会进行合并，也不会进行拆分，而是一次交付一个完整的报文。比如我们要发送100个字节的报文，我们调用一次send()方法就会发送100字节，接收方也需要用receive()方法一次性接收100字节，不能使用循环每次获取10个字节，获取十次这样的做法。</p><p>UDP协议没有拥塞控制，所以当网络出现的拥塞不会导致主机发送数据的速率降低。虽然UDP的接收端有缓冲区，但是这个缓冲区只负责接收，并不会保证UDP报文的到达顺序是否和发送的顺序一致。因为网络传输的时候，由于网络拥塞的存在是很大的可能导致先发的报文比后发的报文晚到达。如果此时缓冲区满了，后面到达的报文将直接被丢弃。这个对实时应用来说很重要，比如：视频通话、直播等应用。</p><p>因此UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境，数据报大小限制在64K以下。</p><h2 id="基于UDP协议的网络编程-1"><a href="#基于UDP协议的网络编程-1" class="headerlink" title="基于UDP协议的网络编程"></a>基于UDP协议的网络编程</h2><p>基于UDP协议的网络编程仍然需要在通信实例的两端各建立一个Socket，但这两个Socket之间并没有虚拟链路，这两个Socket只是发送、接收数据报的对象，Java提供了DatagramSocket对象作为基于UDP协议的Socket，使用DatagramPacket代表DatagramSocket发送、接收的数据报。</p><p><strong>DatagramSocket 类的常用方法：</strong></p><ul><li>public DatagramSocket(int port)创建数据报套接字并将其绑定到本地主机上的指定端口。套接字将被绑定到通配符地址，IP 地址由内核来选择。</li><li>public DatagramSocket(int port,InetAddress laddr)创建数据报套接字，将其绑定到指定的本地地址。本地端口必须在 0 到 65535 之间（包括两者）。如果 IP 地址为 0.0.0.0，套接字将被绑定到通配符地址，IP 地址由内核选择。</li><li>public void close()关闭此数据报套接字。</li><li>public void send(DatagramPacket p)从此套接字发送数据报包。DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号。</li><li>public void receive(DatagramPacket p)从此套接字接收数据报包。当此方法返回时，DatagramPacket 的缓冲区填充了接收的数据。数据报包也包含发送方的 IP 地址和发送方机器上的端口号。 此方法在接收到数据报前一直阻塞。数据报包对象的 length 字段包含所接收信息的长度。如果信息比包的长度长，该信息将被截短。</li></ul><p><strong>DatagramPacket类的常用方法：</strong></p><ul><li>public DatagramPacket(byte[] buf,int length)构造 DatagramPacket，用来接收长度为 length 的数据包。 length 参数必须小于等于 buf.length。</li><li>public DatagramPacket(byte[] buf,int length,InetAddress address,int port)构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。length 参数必须小于等于 buf.length。</li><li>public int getLength()返回将要发送或接收到的数据的长度。</li></ul><h3 id="“发送端”"><a href="#“发送端”" class="headerlink" title="“发送端”"></a>“发送端”</h3><p>步骤流程：</p><ol><li>建立发送端的DatagramSocket，需要指定本端的端口号</li><li>建立数据包DatagramPacket<ul><li>数据</li><li>接收端的IP地址</li><li>接收端的端口号</li></ul></li><li>调用DatagramSocket的发送方法</li><li>关闭DatagramSocket</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//1、建立发送端的DatagramSocket</span></span><br><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line"><span class="comment">//要发送的数据</span></span><br><span class="line">ArrayList&lt;String&gt; all = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">all.add(<span class="string">"你只管努力！"</span>);</span><br><span class="line">all.add(<span class="string">"剩下的交给天意！"</span>);</span><br><span class="line">all.add(<span class="string">"当你的才华撑不起你的野心的时候！"</span>);</span><br><span class="line">all.add(<span class="string">"那就必须静下心来学习！"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收方的IP地址</span></span><br><span class="line">InetAddress ip = InetAddress.getByName(<span class="string">"127.0.0.1"</span>);</span><br><span class="line"><span class="comment">//接收方的监听端口号</span></span><br><span class="line"><span class="keyword">int</span> port = <span class="number">9999</span>;</span><br><span class="line">         <span class="comment">//发送多个数据报</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all.size(); i++) &#123;</span><br><span class="line"><span class="comment">//2、建立数据包DatagramPacket</span></span><br><span class="line"><span class="keyword">byte</span>[] data = all.get(i).getBytes();</span><br><span class="line">DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(data, data.length, ip, port);</span><br><span class="line"><span class="comment">//3、调用Socket的发送方法</span></span><br><span class="line">ds.send(dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、关闭Socket</span></span><br><span class="line">ds.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="“接收端”"><a href="#“接收端”" class="headerlink" title="“接收端”"></a>“接收端”</h3><p>步骤流程：</p><ol><li><p>建立接收端的DatagramSocket，需要指定本端的IP地址和端口号</p></li><li><p>建立数据包DatagramPacket</p><ul><li>需要指定装数据的数组</li></ul></li><li><p>调用Socket的接收方法</p></li><li><p>拆封数据</p></li><li><p>关闭Socket</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receive</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//1、建立接收端的DatagramSocket，需要指定本端的监听端口号</span></span><br><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一直监听数据</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//2、建立数据包DatagramPacket</span></span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line">DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buffer , buffer.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、调用Socket的接收方法</span></span><br><span class="line">ds.receive(dp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、拆封数据</span></span><br><span class="line">String str = <span class="keyword">new</span> String(buffer,<span class="number">0</span>,dp.getLength());</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用MulticastSocket实现多点广播"><a href="#使用MulticastSocket实现多点广播" class="headerlink" title="使用MulticastSocket实现多点广播"></a>使用MulticastSocket实现多点广播</h2><p>Datagram只允许数据报发送给指定的目标地址，而MulticastSocket可以将数据报以广播方式发送到数量不等的多个客户端。</p><p>IP协议为多点广播提供了这批特殊的IP地址，这些IP地址的范围是224.0.0.0至239.255.255.255。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/network-programming6.png" alt="network-programming"></p><p><strong>MulticastSocket常用的方法：</strong></p><ul><li>MulticastSocket(int port) ：创建多播套接字并将其绑定到特定端口。创建一个MulticastSocket对象后，还需要将该MulticastSocket加入到指定的多点广播地址，如果结束也需要脱离多点广播地址。</li><li>void joinGroup(InetAddress mcastaddr) ：加入多播组。</li><li>void leaveGroup(InetAddress mcastaddr) ：离开多播组。</li><li>void setLoopbackMode(boolean disable) ：启用/禁用多播数据报的本地回送。true 表示禁用 LoopbackMode。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO流</title>
      <link href="/2020/06/21/java-io/"/>
      <url>/2020/06/21/java-io/</url>
      
        <content type="html"><![CDATA[<h1 id="IO流概念"><a href="#IO流概念" class="headerlink" title="IO流概念"></a>IO流概念</h1><p>I/O是输入/输出(Input/Output) 的缩写， I/O技术是非常实用的技术，如读/写文件，网络通讯等等。Java的IO支持通过java.io包下的类和接口来支持。</p><ul><li><p>I(Input输入)，从别的地方（文件、键盘、网络、内存等）读取数据到当前程序中</p></li><li><p>O(Output输出)，从程序把数据写/输出到文件、屏幕（控制台）、网络、内存等中</p></li></ul><h1 id="java-io-File类"><a href="#java-io-File类" class="headerlink" title="java.io.File类"></a>java.io.File类</h1><p>File类是java.io包下代表与平台无关的文件和目录，也就是说如果希望在程序中操作文件和目录都可以通过File类来完成，File类能新建、删除、重命名文件和目录。</p><p>在API中File的解释是文件和目录路径名的抽象表示形式，即File类是文件或目录的路径，而不是文件本身，因此File类不能直接访问文件内容本身，如果需要访问文件内容本身，则需要使用输入/输出流。</p><h2 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h2><p>File类可以使用文件路径字符串来创建File实例，该文件路径字符串既可以是绝对路径，也可以是相对路径，默认情况下，系统总是依据用户的工作路径来解释相对路径，这个路径由系统属性“user.dir”指定，通常也就是运行Java虚拟机时所作的路径。</p><ul><li>String getName()：返回此File对象的所表示的文件名（返回最后一级）</li><li>String getPath()：返回此File对象所对应的路径名。</li><li>String getAbsolutePath()：返回此File对象所对应的绝对路径名。</li><li>File getAbsoluteFile()：返回此File对象所对应的绝对路径名所对应的File对象</li><li>String getCanonicalPath()：返回此File对象所对应的规范路径名。所谓规范路径名，即对路径中的“..”等进行解析后的路径名。</li><li>File getCanonicalFile()：返回此File对象所对应的规范路径名所对应的File对象</li><li>String getParent()：返回此File对象的父目录名</li><li>File getParentFile()：返回此File对象的父目录名所对应的File对象</li></ul><h2 id="获取常规信息等方法"><a href="#获取常规信息等方法" class="headerlink" title="获取常规信息等方法"></a>获取常规信息等方法</h2><p><strong>文件和目录检测方法：</strong></p><ul><li><p>boolean exists()：判断File对象对应的文件或目录是否存在</p></li><li><p>canRead()：判断File对象对应的文件或目录是否可读</p></li><li><p>canWrite()：判断File对象对应的文件或目录是否可写</p></li><li><p>isHidden()：判断File对象对应的文件或目录是否是否隐藏</p></li><li><p>isFile()：判断File对象对应的是否是文件</p></li><li><p>isDirectory()：判断File对象对应的是否是目录</p></li><li><p>isAbsolute()：判断File对象对应的文件或目录是否是绝对路径</p></li></ul><p><strong>获取常规信息：</strong></p><ul><li><p>long lastModified()：返回File对象对应的文件或目录的最后修改时间（毫秒值）</p></li><li><p>long length()：返回File对象对应的文件的内容的长度（字节数），<strong>如果File对象对应的是目录，则结果是不确定的</strong></p></li></ul><p>以上都是对应于File对象的属性信息，如果File对象对应的文件或目录不存在，返回的都是对应属性的默认值，例如：length()返回为0，isFile()和isDirectory()返回为false等。</p><h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><ol><li><p>创建文件：boolean createNewFile() throws IOException</p><p>如果指定的文件不存在并成功地创建，则返回 true；如果指定的文件已经存在，则返回 false。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">  File file = <span class="keyword">new</span> File(<span class="string">"d:/unclehe/javase/HelloIO.java"</span>);</span><br><span class="line">  file.createNewFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建临时文件，通常会结合deleteOnExit()使用</li></ol><ul><li><p>public static File createTempFile(String prefix,String suffix) throws IOException在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。调用此方法等同于调用 createTempFile(prefix, suffix, null)。</p><ul><li>n prefix - 用于生成文件名的前缀字符串；必须至少三个字符。</li><li>suffix - 用于生成文件名的后缀字符串；如果为 null，默认为 “.tmp”</li></ul></li><li><p>public static File createTempFile(String prefix,String suffix,File directory)throws IOException在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。</p><ul><li>prefix - 用于生成文件名的前缀字符串；必须至少三个字符。</li><li>suffix - 用于生成文件名的后缀字符串；如果为 null，默认为 “.tmp”</li><li>directory - 将创建的文件所在的目录；如果使用默认临时文件目录，则该参数为 null </li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">  File tempFile = File.createTempFile(<span class="string">"Hello"</span>, <span class="string">".tmp"</span>);</span><br><span class="line">  System.out.println(tempFile.getAbsolutePath());</span><br><span class="line">  <span class="comment">//C:\Users\Irene\AppData\Local\Temp\Hello2541030191749214481.tmp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><ul><li><p>boolean delete() 当且仅当成功删除文件时，返回 true；否则返回 false。</p></li><li><p>public void delete OnExit()：当退出JVM时，删除文件，一般用于删除临时文件</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteOnExit</span><span class="params">()</span>：当退出JVM时，删除文件，一般用于删除临时文件</span></span><br><span class="line"><span class="function">  @Test</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  File file = <span class="keyword">new</span> File(<span class="string">"d:/unclehe/javase/HelloIO.java"</span>);</span><br><span class="line">  file.delete();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">  File tempFile = File.createTempFile(<span class="string">"Hello"</span>, <span class="string">".tmp"</span>);</span><br><span class="line">  <span class="comment">//....省略代码</span></span><br><span class="line">  tempFile.deleteOnExit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><ul><li>boolean renameTo(File dest)：此方法行为的许多方面都是与平台有关的：重命名操作无法将一个文件从一个文件系统移动到另一个文件系统，该操作不是不可分的，如果已经存在具有目标抽象路径名的文件，那么该操作可能无法获得成功。应该始终检查返回值，以确保重命名操作成功。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span>&#123;</span><br><span class="line">  File src = <span class="keyword">new</span> File(<span class="string">"d:/unclehe/javase/HelloIO.java"</span>);</span><br><span class="line">  File dest = <span class="keyword">new</span> File(<span class="string">"d:/unclehe/javase/HelloFile.java"</span>);</span><br><span class="line">  src.renameTo(dest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  File src = <span class="keyword">new</span> File(<span class="string">"d:/unclehe/javase/HelloIO.java"</span>);</span><br><span class="line">  File dest = <span class="keyword">new</span> File(<span class="string">"e:/HelloFile.java"</span>);</span><br><span class="line">  <span class="comment">//D盘和E盘相同的文件系统可以成功，例如都是NTFS。</span></span><br><span class="line">  src.renameTo(dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作目录"><a href="#操作目录" class="headerlink" title="操作目录"></a>操作目录</h2><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><ul><li><p>boolean mkdir() ：必须确保父目录存在，否则创建失败</p></li><li><p>boolean mkdirs()：如果父目录链不存在，会一同创建父目录链</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  File dir = <span class="keyword">new</span> File(<span class="string">"d:/unclehe/javase/io"</span>);</span><br><span class="line">  dir.mkdir();</span><br><span class="line">  <span class="comment">//如果d:/atguigu/javase不存在不会报错，只是没创建成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  File dir = <span class="keyword">new</span> File(<span class="string">"d:/unclehe/javase/io"</span>);</span><br><span class="line">  dir.mkdirs();</span><br><span class="line">  <span class="comment">//如果d:/atguigu/javase不存在，会一并创建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="列出目录内容"><a href="#列出目录内容" class="headerlink" title="列出目录内容"></a>列出目录内容</h3><ul><li><p>public String[] list()列出当前目录的下级目录或文件的名称</p></li><li><p>public File[] listFiles() 列出当前目录的下级的目录或文件对应的File对象  </p><p>配合递归可以列出下级的下级….</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  File dir = <span class="keyword">new</span> File(<span class="string">"d:/unclehe"</span>);</span><br><span class="line">  listSubFiles(dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listSubFiles</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dir != <span class="keyword">null</span> &amp;&amp; dir.isDirectory()) &#123;</span><br><span class="line">    File[] listFiles = dir.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (listFiles != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (File sub : listFiles) &#123;</span><br><span class="line">        listSubFiles(sub);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>public File[ ] listFiles (FileFilter filter) 返回所有满足指定过滤器的文件和目录。如果给定 filter 为 null，则接受所有路径名。否则，当且仅当在路径名上调用过滤器的 FileFilter.accept(java.io.File) 方法返回 true 时，该路径名才满足过滤器。如果当前File对象不表示一个目录，或者发生 I/O 错误，则返回 null。</li><li>public File[ ] listFiles (FilenameFilter filter) 返回所有满足指定过滤器的文件和目录。如果给定 filter 为 null，则接受所有路径名。否则，当且仅当在路径名上调用过滤器的 FilenameFilter.accept(java.io.File, java.lang.String) 方法返回 true 时，该路径名才满足过滤器。如果当前File对象不表示一个目录，或者发生 I/O 错误，则返回 null。</li><li>public static File[ ] listRoots() 列出可用的文件系统根。</li></ul><h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><ul><li>boolean delete()：只能删除空目录。否则需要先将目录下的所有内容删除才能将该目录删除。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  File dir = <span class="keyword">new</span> File(<span class="string">"D:/unclehe/javase"</span>);</span><br><span class="line">  forceDeleteDir(dir);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceDeleteDir</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dir != <span class="keyword">null</span> &amp;&amp; dir.isDirectory()) &#123;</span><br><span class="line">    File[] listFiles = dir.listFiles();</span><br><span class="line">    <span class="keyword">if</span>(listFiles!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span> (File sub : listFiles) &#123;</span><br><span class="line">        forceDeleteDir(sub);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dir.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重命名目录"><a href="#重命名目录" class="headerlink" title="重命名目录"></a>重命名目录</h3><ul><li>boolean renameTo(File dest)：如果是windows目录，只能在同一个盘下，不能从D盘移动到E盘。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  File dir = <span class="keyword">new</span> File(<span class="string">"D:/unclehe/javase"</span>);</span><br><span class="line">  File dest = <span class="keyword">new</span> File(<span class="string">"D:/unclehe/java代码"</span>);</span><br><span class="line">  dir.renameTo(dest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  File dir = <span class="keyword">new</span> File(<span class="string">"D:/unclehe/javase"</span>);</span><br><span class="line">  File dest = <span class="keyword">new</span> File(<span class="string">"D:/temp"</span>);</span><br><span class="line">  dir.renameTo(dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IO流的分类与设计"><a href="#IO流的分类与设计" class="headerlink" title="IO流的分类与设计"></a>IO流的分类与设计</h1><h2 id="java-io包中的IO流"><a href="#java-io包中的IO流" class="headerlink" title="java.io包中的IO流"></a>java.io包中的IO流</h2><p>java.io包中类太多了，简直是……“琳琅满目”“眼花缭乱”。你第一次（第二次，第三次，。。。）看到这些API时，“哦”愁眉苦脸时，放心，你不是唯一受到惊吓和困扰的人。但是，如果你好好梳理他们的关系，并掌握几个经典代表的使用方式，其他的也就等于掌握了。</p><p><strong>第一：</strong>其实不管有多少种IO流，最基本的只有四个。</p><p><strong>IO的四个超级父类，抽象基类</strong></p><ul><li><p>字节输入流：InputStream</p></li><li><p>字节输出流：OutputStream</p></li><li><p>字符输入流：Reader</p></li><li><p>字符输出流：Writer</p></li></ul><p><strong>第二：</strong>IO流类的设计选用了“装饰者”设计模式，即IO流分为两大类，“被装饰”的组件和“装饰”的组件。</p><p>例如：以InputStream为例</p><p>其中FileInputStream、ByteArrayInputStream等是“被装饰”的组件，依次用来连接和读取“文件”、“内存中的字节数组”的等。</p><p>而BufferedInputStream、DataInputStream、ObjectInputStream等是用来“装饰”的组件，依次是给其他InputStream的IO流提供装饰的辅助功能的，依次可以增加“提高效率的缓冲功能”、“按照Java数据类型读取数据的能力”、“读取并恢复Java对象的能力”等</p><p>你会发现OutputStream、Reader、Writer系列的流设计方式也是一样的。</p><p><strong>第三：</strong>IO流的选取可以通过以下几个分类来简化选取过程。</p><p><strong>按照IO流的方向：</strong></p><ul><li><p>输入流和输出流</p></li><li><p>I：代表Input</p></li><li><p>O：代表Output</p></li></ul><p>Java的IO流是单向的，只能从输入流（Input、Reader）中读取（read）数据，也只能往输出流（Output、Writer）中写（write、print）出数据。</p><p><strong>按照IO流的处理数据的基本单位分：</strong></p><ul><li><p>字节流（XxxStream）：直接处理二进制，一个字节一个字节处理，它适用于一切数据，包括纯文本、doc、xls、图片、音频、视频等等</p></li><li><p>字符流（XxxReader和XxxWriter）：一个字符一个字符处理，只能纯文本类的数据。</p></li></ul><p><strong>按照角色分：</strong></p><ul><li>节点流：连接源头、目的地，即被装饰者IO流</li><li>处理流：增强功能，提高性能，即装饰者IO流</li></ul><p>节点流处于IO操作的第一线，所有操作必须通过他们进行；处理流是通过包装节点流来完成功能的，处理流可以增加很多层。处理流必须依赖和包装节点流，而不能单独存在。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/io1.png" alt="io"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/io2.png" alt="io"></p><p>提示：装饰模式（Decorator Pattern）也称为包装模式（Wrapper Pattern），其使用一种对客户端透明的方式来动态地扩展对象的功能，它是通过继承扩展功能的替代方案之一。在现实生活中你也有很多装饰者的例子，例如：人需要各种各样的衣着，不管你穿着怎样，但是，对于你个人本质来说是不变的，充其量只是在外面加上了一些装饰，有，“遮羞的”、“保暖的”、“好看的”、“防雨的”….</p><h2 id="常见IO流"><a href="#常见IO流" class="headerlink" title="常见IO流"></a>常见IO流</h2><p><strong>文件IO流</strong></p><ul><li>从文件读取<ul><li>FileInputStream</li><li>FileReader</li></ul></li><li>写入到文件<ul><li>FileOutputStream</li><li>FileWriter</li></ul></li></ul><p><strong>缓冲IO流</strong></p><ul><li>从其他输入流中读取<ul><li>BufferedInputStream</li><li>BufferedReader</li></ul></li><li>写入到其他输出流中<ul><li>BufferedOutputStream</li><li>BufferedWriter</li></ul></li></ul><p><strong>转换流</strong></p><ul><li>从其他输入流读取，并解码<ul><li>InputStreamReader</li></ul></li><li>写入到其他输出流中，并编码<ul><li>OutputStreamWriter</li></ul></li></ul><p><strong>数据流</strong></p><ul><li>以与机器无关方式从底层输入流中读取基本 Java 数据类型<ul><li>DataInputStream</li></ul></li><li>以适当方式将基本 Java 数据类型写入输出流中<ul><li>DataOutputStream</li></ul></li></ul><p><strong>对象流</strong></p><ul><li>序列化<ul><li>ObjectOutputStream</li></ul></li><li>反序列化<ul><li>ObjectInputStream</li></ul></li></ul><p><strong>打印流</strong></p><ul><li>PrintStream</li><li>PrintWriter</li></ul><p><strong>其它流</strong></p><p>​    ……</p><h2 id="抽象基类的常用方法"><a href="#抽象基类的常用方法" class="headerlink" title="抽象基类的常用方法"></a>抽象基类的常用方法</h2><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><ul><li><p>int read()</p><p>从输入流中读取数据的下一个字节。返回 0 到 255 范围内的 int 字节值。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。</p></li><li><p>int read(byte[] b)</p><p>从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。否则以整数形式返回实际读取的字节数。</p></li><li><p>int read(byte[] b, int off,int len)</p><p>将输入流中最多 len 个数据字节读入 byte 数组。尝试读取 len 个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值 -1.</p></li><li><p>public void close() throws IOException</p><p>关闭此输入流并释放与该流关联的所有系统资源。 </p></li></ul><h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><ul><li><p>void write(int b)</p><p>将指定的字节写入此输出流。write 的常规协定是：向输出流写入一个字节。要写入的字节是参数 b 的八个低位。b 的 24 个高位将被忽略。 即写入0~255范围的</p></li><li><p>void write(byte[] b)</p><p>将 b.length 个字节从指定的 byte 数组写入此输出流。write(b) 的常规协定是：应该与调用 write(b, 0, b.length) 的效果完全相同。</p></li><li><p>void write(byte[] b,int off,int len)</p><p>将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。</p></li><li><p>public void flush()throws IOException </p><p>刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。</p></li><li><p>public void close() throws IOException</p><p>关闭此输出流并释放与该流关联的所有系统资源。</p></li></ul><h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><ul><li><p>int read()</p><p>读取单个字符。作为整数读取的字符，范围在 0 到 65535 之间 (0x00-0xffff)（2个字节的Unicode码），如果已到达流的末尾，则返回 -1 </p></li><li><p>int read(char[] cbuf)</p><p>将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。</p></li><li><p>int read(char[] cbuf,int off,int len)</p><p>将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。</p></li><li><p>public void close() throws IOException</p><p>关闭此输入流并释放与该流关联的所有系统资源。 </p></li></ul><h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3><ul><li><p>void write(int c)、Writer append(char c)</p><p>写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即写入0 到 65535 之间的Unicode码。</p></li><li><p>void write(char[] cbuf)、Writer append(CharSequence csq)</p><p>写入字符数组。 </p></li><li><p>void write(char[] cbuf,int off,int len)、Writer append(CharSequence csq, int start, int end)</p><p>写入字符数组的某一部分。从off开始，写入len个字符</p></li><li><p>void write(String str)</p><p>写入字符串。 </p></li><li><p>void write(String str,int off,int len)</p><p>写入字符串的某一部分。</p></li><li><p>void flush()</p><p>刷新该流的缓冲，则立即将它们写入预期目标。</p></li><li><p>public void close() throws IOException</p><p>关闭此输出流并释放与该流关联的所有系统资源。 </p></li></ul><h3 id="IO流使用步骤"><a href="#IO流使用步骤" class="headerlink" title="IO流使用步骤"></a>IO流使用步骤</h3><h4 id="读取-接收数据的步骤"><a href="#读取-接收数据的步骤" class="headerlink" title="读取/接收数据的步骤"></a>读取/接收数据的步骤</h4><p>第一步：选择IO流</p><ol><li><p>选择节点流</p><p>明确你要从哪里读取数据，即数据源是什么？</p><p>如果从文件中，就选择FileInputStream、FileReader；</p><p>如果从内存的数组中，就选择ByteArrayInputStream、CharArrayReader；</p><p>如果从网络中，就选择InputStream；</p></li><li><p>选择字节流还是字符流</p><p>如果可选，那么看数据是否是纯文本，如果是纯文本并且文本的编码方式与当前平台的编码方式一致，那么选择字符流的效率更高，否则选择字节流。</p></li><li><p>是否需要增加额外的辅助功能</p><ul><li><p>缓冲功能：BufferedReader、BufferedInputStream</p></li><li><p>是否需要按行读：BufferedReader、Scanner</p></li><li><p>是否需要以与机器无关方式从底层输入流中读取基本 Java 数据类型：DataInputStream</p></li><li><p>是否需要对象的反序列化：ObjectInputStream</p></li><li><p>是否需要对流中的数据进行解码的转换：InputStreamReader</p></li></ul></li></ol><p>第二步：循环读取数据</p><ul><li>read()</li><li>readLine()</li><li>readXxx()，例如：readInt()，readObject()，readUTF()等</li></ul><p>第三步：关闭close()</p><h4 id="写-发送数据的步骤"><a href="#写-发送数据的步骤" class="headerlink" title="写/发送数据的步骤"></a>写/发送数据的步骤</h4><p>第一步：选择IO流</p><ol><li><p>选择节点流</p><p>明确你要把数据写到哪里去，即数据的目的地是哪里？</p><p>如果写到文件中，就选择FileOutputStream、FileWriter；</p><p>如果写到内存某数组中，就选择ByteArrayOutputStream、CharArrayWriter；</p><p>如果发送到网络中，就选择OutputStream；</p></li><li><p>选择字节流还是字符流</p><p>如果可选，那么看数据是否是纯文本，如果是纯文本并且文本的编码方式与当前平台的编码方式一致，那么选择字符流的效率更高，否则选择字节流。</p></li><li><p>是否需要增加额外的辅助功能</p><p>缓冲功能：BufferedOutputStream、BufferedWriter</p><p>是否需要按行写：PrintStream、PrintWriter</p><p>是否需要以以适当方式将基本 Java 数据类型写入输出流：DataOutputStream</p><p>是否需要将对象的序列化：ObjectOutputStream</p><p>是否需要对流中的数据进行编码的转换：OutputStreamWriter</p></li></ol><p>第二步：循环写数据</p><ul><li><p>write(xx)</p></li><li><p>print(xx)和println(xx)</p></li><li><p>writeXxx：例如：writeInt(xx)、writeDouble(xx)、writeObject(xx)等</p></li></ul><p>第三步：关闭IO流</p><ul><li>close()</li></ul><h1 id="文件IO流"><a href="#文件IO流" class="headerlink" title="文件IO流"></a>文件IO流</h1><p>1、类型</p><p>FileInputStream：文件字节输入流，可以读取任意类型的文件</p><p>FileOutputStream：文件字节输出流，可以把字节数据输出到任意类型的文件</p><p>FileReader：文件字符输入流，只能读取纯文本的文件。按照平台默认的字符编码进行解码。</p><p>FileWriter：文件字符输出流，只能把字符数据输出到纯文本文件。按照平台默认的字符编码进行编码。</p><p>2、读写文件的代码</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(File src, File dest)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="comment">//选择IO流</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(dest);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读写</span></span><br><span class="line">    <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = fis.read(data);</span><br><span class="line">        <span class="keyword">if</span>(len==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fos.write(data,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">     fis.close();</span><br><span class="line">    fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="缓冲IO流"><a href="#缓冲IO流" class="headerlink" title="缓冲IO流"></a>缓冲IO流</h1><p>1、分为</p><p>BufferedInputStream：字节输入缓冲流，给InputStream系列IO流增加缓冲效果<br>BufferedOutputStream：字节输出缓冲流，给OutputStream系列IO流增加缓冲效果<br>BufferedReader：字符输入缓冲流，给Reader系列IO流增加缓冲效果</p><blockquote><p>String readLine()：按行读取</p></blockquote><p>BufferedWriter：字符输出缓冲流，给Writer系列IO流增加缓冲效果</p><blockquote><p>void newLine()：输出换行符</p></blockquote><p>2、默认的缓冲区的大小是8192 = 1024 * 8（字节/字符）</p><p>3、可以给读写的过程提高效率</p><blockquote><p>不仅仅是可以给文件IO流增加缓冲效果，可以给任意符合对应类型的IO流增加缓冲效果。</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyBuffer</span><span class="params">(File src, File dest)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="comment">//选择IO流</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(dest);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//BufferedInputStream只能给FileInputStream增加缓冲效果，读的过程加快了</span></span><br><span class="line">    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);<span class="comment">//fis在里面，bis在外面，fis比喻成内衣，bis比喻成外套</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//BufferedOutputStream只能FileOutputStream增加缓冲效果，写的过程加快了</span></span><br><span class="line">    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//数据流向：src--&gt;fis--&gt;bis（从fis先缓冲到bis）--&gt;data--&gt;bos（从data缓冲到bos中）--&gt;fos--&gt;dest</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读写</span></span><br><span class="line">    <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = bis.read(data);</span><br><span class="line">        <span class="keyword">if</span>(len==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bos.write(data,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    <span class="comment">//关闭比喻成脱衣服</span></span><br><span class="line">    bos.close();</span><br><span class="line">     fos.close();</span><br><span class="line">       </span><br><span class="line">    bis.close();<span class="comment">//先脱外套，再脱内衣</span></span><br><span class="line">    fis.close();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编码与解码的IO流（转换流）"><a href="#编码与解码的IO流（转换流）" class="headerlink" title="编码与解码的IO流（转换流）"></a>编码与解码的IO流（转换流）</h1><p>1、编码：OutputStreamWriter</p><p>​    可以把字符流转为字节流输出，并且在转换的过程中，可以指定字符编码。</p><p>2、解码：InputStreamReader</p><p>​    可以把字节输入流转为字符输入流，并且在转换的过程中，可以指定字符编码。</p><p>3、示例代码：解码（文件是GBK，当前平台是UTF-8）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">//因为这里想要用在程序中按照“指定”的编码方式进行解码，而不是按照平台“默认的”编码方式进行解码</span></span><br><span class="line"><span class="comment">//所以，我这里仍然用FileInputStream字节流，把文件编码后的数据，原样读取</span></span><br><span class="line"><span class="comment">//从文件到FileInputStream fis内存的过程中，先不解码</span></span><br><span class="line"><span class="comment">//因为如果选择FileReader，从文件到FileReader的过程中，就已经按照平台“默认的”编码方式解码好了，我们无法控制</span></span><br><span class="line"></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"d:/File类概述.txt"</span>);</span><br><span class="line"><span class="comment">//我要使用InputStreamReader，把FileInputStream转为字符流</span></span><br><span class="line"><span class="comment">//InputStreamReader isr = new InputStreamReader(fis);//如果没有指定，还是按照默认的编码方式</span></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">"GBK"</span>);<span class="comment">//如果指定，就按照指定的编码方式解码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件--&gt;fis（字节流）--&gt;解码--&gt;isr（字符流）--&gt;br -&gt;读取的是字符</span></span><br><span class="line"><span class="comment">//字符流，要么按照char[]读取，要么可以用BufferedReader包装按行读取</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line = br.readLine()) !=<span class="keyword">null</span>)&#123;</span><br><span class="line">System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">br.close();</span><br><span class="line">isr.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、示例代码：编码（文件是GBK，当前平台是UTF-8）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">String hua = <span class="string">"File类可以使用文件路径字符串来创建File实例"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为想要用在程序中进行编码，所以这里选用FileOutputStream</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:/File类概述.txt"</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里xx，想要直接操作字符串，那么必须是字符流，而fos是字节流，无法直接操作字符串</span></span><br><span class="line"><span class="comment">//xx.write("\r\n");</span></span><br><span class="line"><span class="comment">//xx.write(hua);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据流向：内存 --&gt; osw （字符流）--&gt;在写入fos过程中进行编码--&gt;fos（字节流）--&gt;文件</span></span><br><span class="line"></span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos,<span class="string">"GBK"</span>);</span><br><span class="line">osw.write(<span class="string">"\r\n"</span>);</span><br><span class="line">osw.write(hua);</span><br><span class="line"></span><br><span class="line">osw.close();</span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据IO流"><a href="#数据IO流" class="headerlink" title="数据IO流"></a>数据IO流</h1><p>1、类型</p><p>DataInputStream：允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型。<br>DataOutputStream：允许应用程序以适当方式将基本 Java 数据类型写入输出流中。</p><blockquote><p>它俩必须配对使用</p><p>读的顺序要与写的顺序一致</p></blockquote><p>2、API</p><table><thead><tr><th>DataOutputStream</th><th>DataInputStream</th></tr></thead><tbody><tr><td>writeInt(xx)：输出int类型整数</td><td>int readInt()</td></tr><tr><td>writeDouble(xx)：输出double类型</td><td>double readDouble()</td></tr><tr><td>writeBoolean(xx)</td><td>boolean readBoolean()</td></tr><tr><td>writeLong(xx)</td><td>long readLong()</td></tr><tr><td>writeChar(xx)</td><td>char readChar()</td></tr><tr><td>writeByte(xx)</td><td>byte readByte()</td></tr><tr><td>writeShort(xx)</td><td>short readShort()</td></tr><tr><td>writeFloat(xx)</td><td>float readFloat()</td></tr><tr><td>writeUTF(String str)：输出字符串的</td><td>String readUTF()</td></tr></tbody></table><h1 id="对象IO流"><a href="#对象IO流" class="headerlink" title="对象IO流"></a>对象IO流</h1><p>1、类型</p><p>ObjectOutputStream：对象序列化，输出对象，把对象转为字节序列输出</p><p>ObjectInputStream：对象反序列化，读取对象，把字节序列重构成Java对象</p><p>2、API</p><p>ObjectOutputStream：writeObject(对象)</p><p>ObjectInputStream：Object  readObject()</p><p>3、序列化需要注意哪些内容？</p><p>（1）所有要序列化的对象的类型都必须实现java.io.Serializable接口</p><blockquote><p>如果对象的属性类型也是引用数据类型，那么也要实现java.io.Serializable接口</p></blockquote><p>（2）希望类的修改对象反序列化不产生影响，那么我们最后能够增加一个序列化版本ID</p><blockquote><p>private static final long serialVersionUID = 1L;</p></blockquote><p>（3）如果有些属性不想要序列化，可以加transient</p><p>（4）如果某个属性前面有static修饰，也不参与序列化</p><p>4、除了Serializable接口之外，还可以实现java.io.Externalizable接口，但是要求重写：</p><p>void readExternal(ObjectInput in)<br>void writeExternal(ObjectOutput out)</p><p>  关于哪些属性序列化和反序列化，由程序员自己定。</p><h1 id="其他的IO流相关内容"><a href="#其他的IO流相关内容" class="headerlink" title="其他的IO流相关内容"></a>其他的IO流相关内容</h1><p>1、如果要实现按行读取，可选择什么类型？</p><p>BufferedReader：String readLine()</p><p>Scanner：String nextLine()</p><p>2、如果要按行输出，可以选择什么类型？</p><p>（1）自己处理\r\n</p><p>（2）BufferedWriter：newLine()</p><p>（3）PrintStream和PrintWriter：println()</p><h1 id="System中的IO流"><a href="#System中的IO流" class="headerlink" title="System中的IO流"></a>System中的IO流</h1><p>System.in和System.out分别代表了系统标准的输入和输出设备</p><ul><li>默认输入设备是键盘，输出设备是显示器</li><li>System.in的类型是InputStream</li><li>System.out的类型是PrintStream</li><li>System.err的类型是PrintStream，按照惯例，此输出流用于显示错误消息，或者显示那些即使用户输出流（变量 out 的值）已经重定向到通常不被连续监视的某一文件或其他目标，也应该立刻引起用户注意的其他信息。</li></ul><p>重定向：</p><ul><li>public static void setIn(InputStream in)</li><li>public static void setOut(PrintStream out)</li><li>public static void setErr(PrintStream err)</li></ul><p>控制台是个文件，查看System类中的initializeSystemClass()方法</p><ul><li>FileInputStream fdIn = new FileInputStream(FileDescriptor.in);</li><li>FileOutputStream fdOut = new FileOutputStream(FileDescriptor.out);</li><li>FileOutputStream fdErr = new FileOutputStream(FileDescriptor.err);</li></ul><h2 id="重定向System-in和System-out"><a href="#重定向System-in和System-out" class="headerlink" title="重定向System.in和System.out"></a>重定向System.in和System.out</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSystemIn</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//重定向从文件输入</span></span><br><span class="line">System.setIn(<span class="keyword">new</span> FileInputStream(<span class="string">"myjava\\info.txt"</span>));</span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">while</span>(input.hasNext())&#123;</span><br><span class="line">String str = input.nextLine();</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//重定向回键盘输入</span></span><br><span class="line">System.setIn(<span class="keyword">new</span> FileInputStream(FileDescriptor.in));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSystemOut</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">//重定向输出到文件</span></span><br><span class="line">System.setOut(<span class="keyword">new</span> PrintStream(<span class="string">"myjava\\print.txt"</span>));</span><br><span class="line">System.out.println(<span class="string">"world"</span>);</span><br><span class="line"><span class="comment">//重定向回控制台</span></span><br><span class="line">System.setOut(<span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(FileDescriptor.out)));</span><br><span class="line">System.out.println(<span class="string">"java"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为Scanner指定输入流"><a href="#为Scanner指定输入流" class="headerlink" title="为Scanner指定输入流"></a>为Scanner指定输入流</h2><p>java.util.Scanner是一个可以使用正则表达式来解析基本类型和字符串的简单文本扫描器。</p><p>示例代码：从键盘输入数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestScannerSystemIn</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"姓名："</span>);</span><br><span class="line">String name = input.nextLine();</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"性别："</span>);</span><br><span class="line"><span class="keyword">char</span> gender = input.next().charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"年龄："</span>);</span><br><span class="line"><span class="keyword">int</span> age = input.nextInt();</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"电话："</span>);</span><br><span class="line">String phone = input.next();</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"邮箱："</span>);</span><br><span class="line">String email = input.next();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"姓名："</span> + name);</span><br><span class="line">System.out.println(<span class="string">"性别："</span> + gender);</span><br><span class="line">System.out.println(<span class="string">"年龄："</span> + age);</span><br><span class="line">System.out.println(<span class="string">"电话："</span> + phone);</span><br><span class="line">System.out.println(<span class="string">"邮箱："</span> + email);</span><br><span class="line"></span><br><span class="line">input.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：从文件扫描数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestScanner</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> FileInputStream(<span class="string">"myjava\\info.txt"</span>));</span><br><span class="line"><span class="keyword">while</span>(input.hasNext())&#123;</span><br><span class="line">String str = input.nextLine();</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JDK1-7新特性：try…with…resources"><a href="#JDK1-7新特性：try…with…resources" class="headerlink" title="JDK1.7新特性：try…with…resources"></a>JDK1.7新特性：try…with…resources</h1><p>语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(需要关闭的资源对象的声明)&#123;</span><br><span class="line">    业务逻辑代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">    处理异常代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">    处理异常代码</span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>它没有finally，也不需要程序员去关闭资源对象，无论是否发生异常，都会关闭资源对象</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//从d:/1.txt(GBK)文件中，读取内容，写到项目根目录下1.txt(UTF-8)文件中</span></span><br><span class="line">  <span class="keyword">try</span>(</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"d:/1.txt"</span>);</span><br><span class="line">    InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">"GBK"</span>);</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"1.txt"</span>);</span><br><span class="line">    OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos,<span class="string">"UTF-8"</span>);</span><br><span class="line">    BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(osw);</span><br><span class="line">  )&#123;</span><br><span class="line">    String str;</span><br><span class="line">    <span class="keyword">while</span>((str = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">      bw.write(str);</span><br><span class="line">      bw.newLine();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>早期的java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。</p><p>NIO. 2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。Path可以看成是File类的升级版本，实际引用的资源也可以不存在。</p><p>在以前IO操作都是这样写的:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"index.html"</span>);</span><br></pre></td></tr></table></figure><p>但在Java7 中，我们可以这样写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Path; </span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths; </span><br><span class="line">Path path = Paths.get(<span class="string">"index.html"</span>);</span><br></pre></td></tr></table></figure><p>同时，NIO.2还提供了Files、Paths工具类，Files包含了大量静态的工具方法来操作文件；Paths则包含了两个返回Path的静态工厂方法。</p><ul><li>static Path get(String first, String … more) : 用于将多个字符串串连成路径</li><li>static Path get(URI uri): 返回指定uri对应的Path路径</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"io"</span>, <span class="string">"java"</span>, <span class="string">"1.txt"</span>);</span><br><span class="line">System.out.println(path);</span><br></pre></td></tr></table></figure><h2 id="Path接口"><a href="#Path接口" class="headerlink" title="Path接口"></a>Path接口</h2><ul><li>String toString() ： 返回调用 Path 对象的字符串表示形式</li><li>boolean startsWith(String path) : 判断是否以 path 路径开始</li><li>boolean endsWith(String path) : 判断是否以 path 路径结束</li><li>boolean isAbsolute() : 判断是否是绝对路径</li><li>Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</li><li>Path getRoot() ：返回调用 Path 对象的根路径</li><li>Path getFileName() : 返回与调用 Path 对象关联的文件名</li><li>Path getName(int idx) : 返回指定索引位置 idx 的路径名称</li><li>int getNameCount() : 返回Path 根目录后面元素的数量</li><li>Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象</li><li>Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象</li><li>File toFile(): 将Path转化为File类的对象</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//Path path = Paths.get("1.txt");</span></span><br><span class="line">  <span class="comment">//Path path = Paths.get("io", "java");</span></span><br><span class="line">  <span class="comment">//Path path = Paths.get("d:","unclehe");</span></span><br><span class="line">  Path path = Paths.get(<span class="string">"io"</span>, <span class="string">"java"</span>, <span class="string">"1.txt"</span>);</span><br><span class="line">  System.out.println(<span class="string">"toString:"</span>+path);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"startsWith:"</span>+path.startsWith(<span class="string">"io"</span>));</span><br><span class="line">  System.out.println(<span class="string">"endsWith:"</span>+path.endsWith(<span class="string">"1.txt"</span>));</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"parent:"</span>+path.getParent());<span class="comment">//io/java</span></span><br><span class="line">  System.out.println(<span class="string">"root:"</span>+path.getRoot());<span class="comment">//null  只有绝对路径才有根</span></span><br><span class="line">  System.out.println(<span class="string">"fileName："</span>+path.getFileName());</span><br><span class="line">  System.out.println(<span class="string">"FileSystem.separator:"</span>+path.getFileSystem().getSeparator());</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"nameCount:"</span>+path.getNameCount());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.getNameCount(); i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">"name("</span>+(i+<span class="number">1</span>)+<span class="string">"):"</span>+path.getName(i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"isAbsolutePath:"</span>+path.isAbsolute());</span><br><span class="line">  System.out.println(<span class="string">"toAbsolutePath:"</span>+path.toAbsolutePath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Files工具类"><a href="#Files工具类" class="headerlink" title="Files工具类"></a>Files工具类</h2><p>用于操作文件或目录的工具类：</p><ul><li>Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) : 创建一个目录</li><li>Path createDirectories(Path dir, FileAttribute&lt;?&gt;… attrs)  创建一个目录，通过创建所有不存在的父目录。</li><li>Path createFile(Path path, FileAttribute&lt;?&gt; … arr) : 创建一个文件</li><li>Path createLink(Path link, Path existing) 创建一个新的链接（目录项）为现有的文件（可选操作）。 </li><li>void delete(Path path) : 删除一个文件，如果不存在，执行报错</li><li>void deleteIfExists(Path path) : Path对应的文件如果存在，执行删除，如果不存在，就什么也不干</li><li>Path copy(Path src, Path dest, CopyOption … how) : 文件的复制</li><li>Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置</li><li>long size(Path path) : 返回 path 指定文件的大小</li></ul><p>Files常用方法：用于判断</p><ul><li>boolean exists(Path path, LinkOption … opts) : 判断文件是否存在</li><li>boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在</li><li>boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录</li><li>boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件</li><li>boolean isHidden(Path path) : 判断是否是隐藏文件</li><li>boolean isReadable(Path path) : 判断文件是否可读</li><li>boolean isWritable(Path path) : 判断文件是否可写</li></ul><p>Files常用方法：用于操作内容</p><ul><li><p>InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象</p></li><li><p>OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象</p></li></ul><p>Files其他方法：</p><ul><li>public static List<String> readAllLines(Path path,Charset cs)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> IO流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2020/06/20/java-%3CT%3E/"/>
      <url>/2020/06/20/java-%3CT%3E/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型的概述"><a href="#泛型的概述" class="headerlink" title="泛型的概述"></a>泛型的概述</h1><p>当我们使用集合时，一旦把一个对象“丢进”Java集合中，集合就会忘记对象的类型，把所有的对象当成Object类型处理。当程序从集合中取出对象后，就需要进行强制类型转换，这种强制类型转换不仅代码臃肿，而且容易引起ClassCastException异常。Java集合之所以被设计成这样，是因为设计集合的程序员不会知道我们需要用它来装什么类型的对象，所以他们把集合设计成能保存任何类型的对象，只要求具有很好的通用性。但这样做也带来了两个问题：</p><ul><li><p>集合对元素类型没有任何限制，这样可能引发一些问题：只想存储字符串对象，却不小心把Integer对象轻易的放进去，因为编译期间没有类型检查。</p></li><li><p>由于把对象“丢进”集合时，在编译期间，集合就忘记了对象的实际类型，集合只知道它盛装的是Object，因此取出集合元素后，该对象的编译时类型就变成了Object类型（其实际的运行时类型没变），如果要使用还需要强制类型转换。这种强制类型转换既会增加编程的复杂度，也可能引发ClassCastException。</p></li></ul><p>于是就有泛型的概念，可以形象的理解为“贴标签”</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/%3CT%3E1.png" alt="泛型"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/%3CT%3E2.png" alt="泛型"></p><p>泛型：参数化类型</p><p>类型形参：<T>，<E>，<K>，<V>，<U>，<R>。。。。</p><p>类型实参：必须是引用数据类型，不能是基本数据类型</p><p>​    <String>，<Integer>，<Student>，&lt;ArrayList<String>&gt;。。。</p><h1 id="泛型类与泛型接口"><a href="#泛型类与泛型接口" class="headerlink" title="泛型类与泛型接口"></a>泛型类与泛型接口</h1><p>我们可以为任何类和接口增加泛型声明，并不是只有集合类才可以使用泛型声明。</p><p>泛型形参的命名一般使用单个的大写字母，如果有多个类型形参，那么使用逗号分隔，例如：Map&lt;K,V&gt;。</p><p>常见字母（见名知意）：</p><ul><li><p>T：Type</p></li><li><p>K，V：Key，Value</p></li><li><p>E：Element</p></li></ul><p>1、声明语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名/接口&lt;类型形参列表&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名/接口&lt;类型形参1 <span class="keyword">extends</span> 父类上限&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名/接口&lt;类型形参1 <span class="keyword">extends</span> 父类上限 &amp; 父接口上限&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在类名或接口名后面声明的泛型形参类型，可以在当前类或接口中使用，用作声明成员变量、方法的形参、方法的返回值。</p><p>但是不能用于<strong>静态成员</strong>上</p></blockquote><p>2、使用语法格式</p><p>在（1）创建泛型类、泛型接口的对象时，为泛型形参指定具体类型</p><p>​    （2）在继承泛型类或实现泛型接口时，为泛型形参指定具体类型</p><p>示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//JDK1.7之后可以省略</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStringArrayList</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee e)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Arrays.sort(数组,  <span class="keyword">new</span>  Comparator&lt;泛型实参&gt;()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(泛型实参类型  o1, 泛型实参类型  o2)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3、泛型如果没有指定，会被擦除，按照最左边的上限处理，如果没有指定上限，按照Object处理</p><h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><p>1、声明的语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 &lt;泛型形参列表&gt;  返回值类型  方法名(【数据形参列表】)【<span class="keyword">throws</span> 异常列表】&#123;&#125;</span><br><span class="line">【修饰符】 &lt;泛型形参 extends 父类上限 &amp; 父接口上限&gt;  返回值类型  方法名(【数据形参列表】)【<span class="keyword">throws</span> 异常列表】&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>（1）在方法返回值类型前面声明的泛型形参类型，只能在当前方法中使用，用于表示形参的类型或返回值类型，或方法局部变量的类型，和别的方法无关。</p><p>（2）泛型方法可以是静态方法，也可以是非静态方法</p></blockquote><p>2、 使用</p><p>当调用方法，会根据具体的数据的实参的类型，来确定泛型实参的类型。</p><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p>当我们声明一个方法时，某个形参的类型是一个泛型类或泛型接口类型，但是在声明方法时，又不确定该泛型实际类型，我们可以考虑使用类型通配符。</p><p>（1）?：代表任意引用数据类型</p><p>（2）?  extends 上限：代表上限本身或它的子类</p><p>（3）? super 下限：代表下限本身或它的父类</p><p>例如：</p><p>ArrayList&lt;?&gt;：表示可以接受任意类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br></pre></td></tr></table></figure><p>ArrayList&lt;? extends 上限&gt;：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;? extends Person&gt; list &#x3D; new ArrayList&lt;Person&gt;();</span><br><span class="line">ArrayList&lt;? extends Person&gt; list &#x3D; new ArrayList&lt;Animal&gt;();&#x2F;&#x2F;Animal不行，因为Animal是父类</span><br><span class="line">ArrayList&lt;? extends Person&gt; list &#x3D; new ArrayList&lt;Student&gt;();</span><br><span class="line">ArrayList&lt;? extends Person&gt; list &#x3D; new ArrayList&lt;Dog&gt;();&#x2F;&#x2F;Dog也不行</span><br></pre></td></tr></table></figure><p>ArrayList&lt;? super 下限&gt;：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;? <span class="keyword">super</span> Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">ArrayList&lt;? <span class="keyword">super</span> Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line">ArrayList&lt;? <span class="keyword">super</span> Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();<span class="comment">//Student，因为Student是子类</span></span><br><span class="line">ArrayList&lt;? <span class="keyword">super</span> Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();<span class="comment">//Dog也不行</span></span><br></pre></td></tr></table></figure><blockquote><p>ArrayList&lt;?&gt;：不能添加元素，除了null</p><p>ArrayList&lt;? extends 上限&gt;：不能添加元素，除了null</p><p>ArrayList&lt;? super 下限&gt;：可以添加下限或下限子类的对象</p></blockquote><h1 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h1><p>参考操作数组的工具类：Arrays。</p><p>Collections 是一个操作 Set、List 和 Map 等集合的工具类。Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法：</p><ul><li>public static <T> boolean addAll(Collection&lt;? super T&gt; c,T… elements)将所有指定元素添加到指定 collection 中。</li><li>public static <T> int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list,T key)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且必须是可比较大小的，即支持自然排序的。而且集合也事先必须是有序的，否则结果不确定。</li><li>public static <T> int binarySearch(List&lt;? extends T&gt; list,T key,Comparator&lt;? super T&gt; c)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且集合也事先必须是按照c比较器规则进行排序过的，否则结果不确定。</li><li>public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，而且支持自然排序</li><li>public static <T> T max(Collection&lt;? extends T&gt; coll,Comparator&lt;? super T&gt; comp)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，按照比较器comp找出最大者</li><li>public static void reverse(List&lt;?&gt; list)反转指定列表List中元素的顺序。</li><li>public static void shuffle(List&lt;?&gt; list) List 集合元素进行随机排序，类似洗牌</li><li>public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List<T> list)根据元素的自然顺序对指定 List 集合元素按升序排序</li><li>public static <T> void sort(List<T> list,Comparator&lt;? super T&gt; c)根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li><li>public static void swap(List&lt;?&gt; list,int i,int j)将指定 list 集合中的 i 处元素和 j 处元素进行交换</li><li>public static int frequency(Collection&lt;?&gt; c,Object o)返回指定集合中指定元素的出现次数</li><li>public static <T> void copy(List&lt;? super T&gt; dest,List&lt;? extends T&gt; src)将src中的内容复制到dest中</li><li>public static <T> boolean replaceAll(List<T> list，T oldVal，T newVal)：使用新值替换 List 对象的所有旧值</li><li>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</li><li>Collections类中提供了多个unmodifiableXxx()方法，该方法返回指定 Xxx的不可修改的视图。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 泛型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="/2020/06/19/java-collection/"/>
      <url>/2020/06/19/java-collection/</url>
      
        <content type="html"><![CDATA[<h1 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h1><p>不管是哪一种数据结构，其实本质上都是容器来着，就是用来装对象的。因此，我们就要搞清楚两点：（1）如何存储（2）存储特点</p><p>数据结构：存储数据的某种结构</p><p>（1）底层的物理结构</p><p>​        ①数组：开辟连续的存储空间，每一个元素使用[下标]进行区别</p><p>​        ②链式：不需要开辟连续的存储空间，但是需要“结点”来包装要存储的数据，结点包含两部分内容：</p><p>​            A、数据</p><p>​            B、记录其他结点的地址，例如：next，pre，left，right，parent等</p><p>（2）表现出来的逻辑结构：动态数组、单向链表、双向链表、队列、栈、二叉树、哈希表、图等</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>逻辑结构：线性的</p></li><li><p>物理结构：顺序的存储结构</p></li><li><p>申请内存：一次申请一大段连续的空间，一旦申请到了，内存就固定了。</p></li><li><p>存储特点：所有数据存储在这个连续的空间中，数组中的每一个元素都是一个具体的数据（或对象），所有数据都紧密排布，不能有间隔。</p></li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection1.png" alt="Collection"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection2.png" alt="Collection"></p><ul><li><p>操作</p><ul><li>查询：每一个元素都有一个数值下标，可以通过下标瞬间定位到某个元素</li><li>增加：<ul><li>先使用total变量辅助记录实际存储元素个数</li><li>从尾部增加：数组名[total++]=新元素</li><li>从其他位置插入：先把index位置开始所有元素后移，然后数组名[index]=新元素</li></ul></li><li>删除：先把index后面的元素前移，然后数组名[total–] = null</li><li>改：直接数组名[index]=新元素</li></ul></li><li><p>优缺点</p><ul><li>优点：按索引查询效率高</li><li>缺点：添加/删除效率低，因为都涉及到移动元素；无法直接获取有效元素的个数，需要total来辅助</li></ul></li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection3.png" alt="Collection"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection4.png" alt="Collection"></p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>为了可以满足用户数据更多种的逻辑关系，而设计的一系列的不同于数组的可变的聚合的抽象数据类型。这些接口和类在java.util包中，因为类型很丰富，因此我们通常称为集合框架集</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection5.png" alt="Collection"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection6.png" alt="Collection"></p><ul><li>Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何直接实现：它提供更具体的子接口（如 Set 和 List、Queue）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。<ul><li>List：有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。</li><li>Queue：队列通常（但并非一定）以 FIFO（先进先出）的方式排序各个元素。不过优先级队列和 LIFO 队列（或堆栈）例外，前者根据提供的比较器或元素的自然顺序对元素进行排序，后者按 LIFO（后进先出）的方式对元素进行排序。</li><li>Set：一个不包含重复元素的 collection。更确切地讲，set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2，并且最多包含一个 null 元素。正如其名称所暗示的，此接口模仿了数学上的 set 抽象。<ul><li>SortedSet进一步提供关于元素的总体排序 的 Set。这些元素使用其自然顺序进行排序，或者根据通常在创建有序 set 时提供的 Comparator进行排序。该 set 的迭代器将按元素升序遍历 set。提供了一些附加的操作来利用这种排序。</li></ul></li></ul></li><li>Map：将键映射到值(key,value)的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。映射顺序 定义为迭代器在映射的 collection 视图上返回其元素的顺序。某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap 类。<ul><li>SortedMap进一步提供关于键的总体排序 的 Map。该映射是根据其键的自然顺序进行排序的，或者根据通常在创建有序映射时提供的 Comparator 进行排序。</li></ul></li></ul><h1 id="手动实现一些逻辑结构"><a href="#手动实现一些逻辑结构" class="headerlink" title="手动实现一些逻辑结构"></a>手动实现一些逻辑结构</h1><p>1、动态数组</p><p>包含：</p><p>（1）内部使用一个数组，用来存储数据</p><p>（2）内部使用一个total，记录实际存储的元素的个数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span> </span>&#123;</span><br><span class="line"><span class="comment">//为什么使用Object，因为只是说这个容器是用来装对象的，但是不知道用来装什么对象。</span></span><br><span class="line"><span class="keyword">private</span> Object[] data;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> total;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyArrayList</span><span class="params">()</span></span>&#123;</span><br><span class="line">data = <span class="keyword">new</span> Object[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="comment">//检查是否需要扩容</span></span><br><span class="line">checkCapacity();</span><br><span class="line">data[total++] = obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果data满了，就扩容为原来的2倍</span></span><br><span class="line"><span class="keyword">if</span>(total &gt;= data.length)&#123;</span><br><span class="line">data = Arrays.copyOf(data, data.length*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回实际元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回数组的实际容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> data.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取[index]位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="comment">//校验index的合理性范围</span></span><br><span class="line">checkIndex(index);</span><br><span class="line"><span class="keyword">return</span> data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=total)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(index+<span class="string">"对应位置的元素不存在"</span>);</span><br><span class="line"><span class="comment">//throw new IndexOutOfBoundsException(index+"越界");</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换[index]位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Object value)</span></span>&#123;</span><br><span class="line"><span class="comment">//校验index的合理性范围</span></span><br><span class="line">checkIndex(index);</span><br><span class="line"></span><br><span class="line">data[index] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在[index]位置插入一个元素value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, Object value)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)考虑下标的合理性</span></span><br><span class="line"><span class="comment"> * (2)总长度是否够</span></span><br><span class="line"><span class="comment"> * (3)[index]以及后面的元素往后移动，把[index]位置腾出来</span></span><br><span class="line"><span class="comment"> * (4)data[index]=value  放入新元素</span></span><br><span class="line"><span class="comment"> * (5)total++  有效元素的个数增加</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)考虑下标的合理性：校验index的合理性范围</span></span><br><span class="line">checkIndex(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)总长度是否够：检查是否需要扩容</span></span><br><span class="line">checkCapacity();</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)[index]以及后面的元素往后移动，把[index]位置腾出来</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 假设total = 5, data.length= 10, index= 1</span></span><br><span class="line"><span class="comment"> * 有效元素的下标[0,4]</span></span><br><span class="line"><span class="comment"> * 移动：[1]-&gt;[2],[2]-&gt;[3],[3]-&gt;[4],[4]-&gt;[5]</span></span><br><span class="line"><span class="comment"> * 移动元素的个数：total-index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.arraycopy(data, index, data, index+<span class="number">1</span>, total-index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)data[index]=value  放入新元素</span></span><br><span class="line">data[index] = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(5)total++  有效元素的个数增加</span></span><br><span class="line">total++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回所有实际存储的元素</span></span><br><span class="line"><span class="keyword">public</span> Object[] getAll()&#123;</span><br><span class="line"><span class="comment">//返回total个</span></span><br><span class="line"><span class="keyword">return</span> Arrays.copyOf(data, total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除[index]位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)校验index的合理性范围</span></span><br><span class="line"><span class="comment"> * (2)移动元素，把[index+1]以及后面的元素往前移动</span></span><br><span class="line"><span class="comment"> * (3)把data[total-1]=null  让垃圾回收器尽快回收</span></span><br><span class="line"><span class="comment"> * (4)总元素个数减少 total--</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)考虑下标的合理性：校验index的合理性范围</span></span><br><span class="line">checkIndex(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)移动元素，把[index+1]以及后面的元素往前移动</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 假设total=8, data.length=10, index = 3</span></span><br><span class="line"><span class="comment"> * 有效元素的范围[0,7]</span></span><br><span class="line"><span class="comment"> * 移动：[4]-&gt;[3],[5]-&gt;[4],[6]-&gt;[5],[7]-&gt;[6]</span></span><br><span class="line"><span class="comment"> * 移动了4个：total-index-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.arraycopy(data, index+<span class="number">1</span>, data, index, total-index-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)把data[total-1]=null  让垃圾回收器尽快回收</span></span><br><span class="line">data[total-<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)总元素个数减少 total--</span></span><br><span class="line">total--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询某个元素的下标</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(data[i] == <span class="keyword">null</span>)&#123;<span class="comment">//等价于 if(data[i] == obj)</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(obj.equals(data[i]))&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除数组中的某个元素</span></span><br><span class="line"><span class="comment">//如果有重复的，只删除第一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)先查询obj的[index]</span></span><br><span class="line"><span class="comment"> * (2)如果存在，就调用remove(index)删除就可以</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)先查询obj的[index]</span></span><br><span class="line"><span class="keyword">int</span> index = indexOf(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(index != -<span class="number">1</span>)&#123;</span><br><span class="line">remove(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不存在，可以什么也不做</span></span><br><span class="line"><span class="comment">//不存在，也可以抛异常</span></span><br><span class="line"><span class="comment">//throw new RuntimeException(obj + "不存在");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object old, Object value)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)查询old的[index]</span></span><br><span class="line"><span class="comment"> * (2)如果存在，就调用set(index, value)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)查询old的[index]</span></span><br><span class="line"><span class="keyword">int</span> index = indexOf(old);</span><br><span class="line"><span class="keyword">if</span>(index!=-<span class="number">1</span>)&#123;</span><br><span class="line">set(index, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不存在，可以什么也不做</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、单向链表</p><p>包含：</p><p>（1）包含一个Node类型的成员变量first：用来记录第一个结点的地址</p><p>​        如果这个链表是空的，还没有任何结点，那么first是null。</p><p>​        最后一个结点的特征：就是它的next是null</p><p>（2）内部使用一个total，记录实际存储的元素的个数</p><p>（3）使用了一个内部类Node</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里不需要数组，不需要其他的复杂的结构，我只要记录单向链表的“头”结点</span></span><br><span class="line"><span class="keyword">private</span> Node first;<span class="comment">//first中记录的是第一个结点的地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> total;<span class="comment">//这里我记录total是为了后面处理的方便，例如：当用户获取链表有效元素的个数时，不用现数，而是直接返回total等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 内部类，因为这种Node结点的类型，在别的地方没有用，只在单向链表中，用于存储和表示它的结点关系。</span></span><br><span class="line"><span class="comment"> * 因为我这里涉及为内部类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">Object data;<span class="comment">//因为数据可以是任意类型的对象，所以设计为Object</span></span><br><span class="line">Node next;<span class="comment">//因为next中记录的下一个结点的地址，因此类型是结点类型</span></span><br><span class="line"><span class="comment">//这里data,next没有私有化，是希望在外部类中可以不需要get/set，而是直接“结点对象.data","结点对象.next"使用</span></span><br><span class="line">Node(Object data, Node next)&#123;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)把obj的数据，包装成一个Node类型结点对象</span></span><br><span class="line"><span class="comment"> * (2)把新结点“链接”当前链表的最后</span></span><br><span class="line"><span class="comment"> * ①当前新结点是第一个结点</span></span><br><span class="line"><span class="comment"> * 如何判断是否是第一个   if(first==null)说明暂时还没有第一个</span></span><br><span class="line"><span class="comment"> * ②先找到目前的最后一个，把新结点链接到它的next中</span></span><br><span class="line"><span class="comment"> * 如何判断是否是最后一个   if(某个结点.next == null)说明这个结点是最后一个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//(1)把obj的数据，包装成一个Node类型结点对象</span></span><br><span class="line"><span class="comment">//这里新结点的next赋值为null，表示新结点是最后一个结点</span></span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//①当前新结点是第一个结点</span></span><br><span class="line"><span class="keyword">if</span>(first == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//说明newNode是第一个</span></span><br><span class="line">first = newNode;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//②先找到目前的最后一个，把新结点链接到它的next中</span></span><br><span class="line">Node node = first;</span><br><span class="line"><span class="keyword">while</span>(node.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出循环时node指向最后一个结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把新结点链接到它的next中</span></span><br><span class="line">node.next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">total++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object[] getAll()&#123;</span><br><span class="line"><span class="comment">//(1)创建一个数组，长度为total</span></span><br><span class="line">Object[] all = <span class="keyword">new</span> Object[total];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)把单向链表的每一个结点中的data，拿过来放到all数组中</span></span><br><span class="line">Node node = first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line"><span class="comment">//all[i] = 结点.data;</span></span><br><span class="line">all[i] = node.data;</span><br><span class="line"><span class="comment">//然后node指向下一个</span></span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)返回数组</span></span><br><span class="line"><span class="keyword">return</span> all;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//(1)先考虑是否是第一个</span></span><br><span class="line"><span class="keyword">if</span>(first!=<span class="keyword">null</span>)&#123;<span class="comment">//链表非空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要删除的结点正好是第一个结点</span></span><br><span class="line"><span class="keyword">if</span>(first.data == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//让第一个结点指向它的下一个</span></span><br><span class="line">first = first.next;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要删除的不是第一个结点</span></span><br><span class="line">Node node = first.next;<span class="comment">//第二个结点</span></span><br><span class="line">Node last = first;</span><br><span class="line"><span class="keyword">while</span>(node.next!=<span class="keyword">null</span>)&#123;<span class="comment">//这里不包括最后一个，因为node.next==null，不进入循环，而node.next==null是最后一个</span></span><br><span class="line"><span class="keyword">if</span>(node.data == <span class="keyword">null</span>)&#123;</span><br><span class="line">last.next = node.next;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">last = node;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单独判断最后一个是否是要删除的结点</span></span><br><span class="line"><span class="keyword">if</span>(node.data == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//要删除的是最后一个结点</span></span><br><span class="line">last.next = <span class="keyword">null</span>;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//(1)先考虑是否是第一个</span></span><br><span class="line"><span class="keyword">if</span>(first!=<span class="keyword">null</span>)&#123;<span class="comment">//链表非空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要删除的结点正好是第一个结点</span></span><br><span class="line"><span class="keyword">if</span>(obj.equals(first.data))&#123;</span><br><span class="line"><span class="comment">//让第一个结点指向它的下一个</span></span><br><span class="line">first = first.next;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要删除的不是第一个结点</span></span><br><span class="line">Node node = first.next;<span class="comment">//第二个结点</span></span><br><span class="line">Node last = first;</span><br><span class="line"><span class="keyword">while</span>(node.next!=<span class="keyword">null</span>)&#123;<span class="comment">//这里不包括最后一个，因为node.next==null，不进入循环，而node.next==null是最后一个</span></span><br><span class="line"><span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line">last.next = node.next;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">last = node;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单独判断最后一个是否是要删除的结点</span></span><br><span class="line"><span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line"><span class="comment">//要删除的是最后一个结点</span></span><br><span class="line">last.next = <span class="keyword">null</span>;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">Node node = first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(node.data == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Node node = first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><p>因为集合的类型很多，那么我们把它们称为集合框架。</p><p>集合框架分为两个家族：Collection（一组对象）和Map（一组映射关系、一组键值对）</p><p>Collection是代表一种对象的集合。它是Collection系列的根接口。</p><p>它们虽然：有些可能是有序的，有些可能是无序的，有些可能可以重复的，有些不能重复的，但是它们有共同的操作规范，因此这些操作的规范就抽象为了Collection接口。</p><p><strong>常用方法：</strong></p><ul><li><p>boolean add(Object obj)：添加一个</p></li><li><p>boolean addAll（Collection c）：添加多个</p></li><li><p>boolean remove(Object obj)：删除一个</p></li><li><p>boolean removeAll(Collection c )： 删除多个</p></li><li><p>boolean contains(Object c)：是否包含某个</p></li><li><p>boolean containsAll(Collection c)： 是否包含所有</p></li><li><p>boolean isEmpty()：是否为空</p></li><li><p>int size()：获取元素个数</p></li><li><p>void clear()：清空集合</p></li><li><p>Object[] toArray()：获取所有元素</p></li><li><p>Iterator iterator()： 获取遍历当前集合的迭代器对象</p></li><li><p>retainAll(Collection c)：求当前集合与c集合的交集</p></li></ul><h2 id="Collection系列的集合的遍历"><a href="#Collection系列的集合的遍历" class="headerlink" title="Collection系列的集合的遍历"></a>Collection系列的集合的遍历</h2><p>1、明确使用Iterator迭代器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection c = ....;</span><br><span class="line"></span><br><span class="line">Iterator iter = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hashNext())&#123;</span><br><span class="line">    Object obj = iter.next();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterator 接口的方法：</p><p>（1）boolean hasNext()</p><p>（2）Object next()</p><p>（3）void remove()</p><p>2、foreach</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Collection c &#x3D; ....;</span><br><span class="line"></span><br><span class="line">for(Object  obj :  c)&#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么样的集合（容器）能够使用foreach遍历？</p><p>（1）数组：</p><p>（2）实现了java.lang.Iterable接口</p><p>这个接口有一个抽象方法：Iterator iterator()</p><p>Iterator也是一个接口，它的实现类，通常在集合（容器）类中用内部类实现。并在iterator()的方法中创建它的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span> <span class="keyword">implements</span> <span class="title">Iterable</span></span>&#123;</span><br><span class="line"><span class="comment">//为什么使用Object，因为只是说这个容器是用来装对象的，但是不知道用来装什么对象。</span></span><br><span class="line"><span class="keyword">private</span> Object[] data;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> total;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他代码省略....</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyItr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyItr</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cursor;<span class="comment">//游标</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> cursor!=total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> data[cursor++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：如果遍历数组，什么情况下选用foreach，什么情况下选用for循环？</p><p>当如果你的操作中涉及到[下标]操作时，用for最好。</p><p>当你只是查看元素的内容，那么选foreach更简洁一些。</p><p>思考：如果遍历Collection系列集合，什么情况下选用foreach，是否能选用for循环？</p><p>首先考虑使用foreach，如果该集合也有索引信息的话，也可以通过for来操作，如果没有下标的信息，就不要用for。即，如果该集合的物理结构是数组的，那么可以用for，如果物理结构是链式，那么使用下标操作效率很低。</p><p>思考：如果遍历Collection系列集合，什么情况下选用foreach，什么情况下使用Iterator？</p><p>如果只是查看集合的元素，使用foreach，代码会更简洁。</p><p>但是如果要涉及到在遍历集合的同时根据某种条件要删除元素等操作，那么选用Iterator。</p><h2 id="Iterator迭代器遍历"><a href="#Iterator迭代器遍历" class="headerlink" title="Iterator迭代器遍历"></a>Iterator迭代器遍历</h2><p>因为Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，该对象可以用于迭代集合中的元素。</p><ul><li>Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建 Iterator 对象，则必须有一个被迭代的集合。</li><li>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素位置。</li></ul><p><strong>常用方法</strong></p><ul><li>boolean hasNext()：如果仍有元素可以迭代，则返回 true</li><li>Object next()：返回迭代的下一个元素。</li><li>void remove()：从迭代器指向的 collection 中移除迭代器返回的最后一个元素（可选操作）</li></ul><p><strong>注意</strong></p><ul><li>建议在调用it.next()方法之前调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。</li><li>如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection8.png" alt="Collection"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection9.png" alt="Collection"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection10.png" alt="Collection"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection11.png" alt="Collection"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  c.add(<span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">"张三"</span>));</span><br><span class="line">  c.add(<span class="keyword">new</span> Student(<span class="number">2</span>,<span class="string">"李四"</span>));</span><br><span class="line">  c.add(<span class="keyword">new</span> Student(<span class="number">3</span>,<span class="string">"王五"</span>));</span><br><span class="line">  c.add(<span class="keyword">new</span> Student(<span class="number">4</span>,<span class="string">"赵六"</span>));</span><br><span class="line">  c.add(<span class="keyword">new</span> Student(<span class="number">5</span>,<span class="string">"钱七"</span>));</span><br><span class="line"></span><br><span class="line">  Iterator iterator = c.iterator();</span><br><span class="line">  <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    Student next = (Student) iterator.next();</span><br><span class="line">    <span class="comment">//例如：要删除学号为1的学生对象</span></span><br><span class="line">    <span class="keyword">if</span>(next.getId()==<span class="number">1</span>)&#123;</span><br><span class="line">      iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h1><p>List集合类中元素有序、且可重复。这就像银行门口客服，给每一个来办理业务的客户分配序号：第一个来的是“张三”，客服给他分配的是0；第二个来的是“李四”，客服给他分配的1；以此类推，最后一个序号应该是“总人数-1”。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/list.png" alt="list"></p><p>List：是Collection的子接口。</p><p>List系列的集合：有序的、可重复的</p><p>List系列的常用集合：ArrayList、Vector、LinkedList、Stack</p><p><strong>注意</strong></p><p>在JavaSE中List名称的类型有两个，一个是java.util.List集合接口，一个是java.awt.List图形界面的组件，别导错包了。</p><p>List集合关心元素是否有序，而不关心是否重复，请大家记住这个原则。例如“张三”可以领取两个号。</p><h2 id="List接口常用方法"><a href="#List接口常用方法" class="headerlink" title="List接口常用方法"></a>List接口常用方法</h2><ul><li><p>boolean add(Object obj)：添加一个</p></li><li><p>boolean addAll（Collection c）：添加多个</p></li><li><p>void add(int index, Object obj)：添加一个，指定位置添加</p></li><li><p>void addAll(int index, Collection c）：添加多个</p></li><li><p>boolean remove(Object obj)：删除一个</p></li><li><p>Object remove(int index)：删除指定位置的元素，并返回刚刚删除的元素</p></li><li><p>boolean removeAll(Collection c )： 删除多个</p></li><li><p>boolean contains(Object c)：是否包含某个</p></li><li><p>boolean containsAll(Collection c)： 是否包含所有</p></li><li><p>boolean isEmpty()：是否为空</p></li><li><p>int size()：获取元素个数</p></li><li><p>void clear()：清空集合</p></li><li><p>Object[] toArray()：获取所有元素</p></li><li><p>Iterator iterator()： 获取遍历当前集合的迭代器对象</p></li><li><p>retainAll(Collection c)：求当前集合与c集合的交集</p></li><li><p>ListIterator listIterator()：获取遍历当前集合的迭代器对象，这个迭代器可以往前、往后遍历</p></li><li><p>ListIterator listIterator(int index)：从[index]位置开始，往前或往后遍历</p></li><li><p>Object get(int index)：返回index位置的元素</p></li><li><p>List  subList(int start, int end)：截取[start,end)部分的子列表</p></li></ul><h2 id="接口的实现类"><a href="#接口的实现类" class="headerlink" title="接口的实现类"></a>接口的实现类</h2><p>Vector 类：动态数组</p><p>ArrayList类：动态数组</p><p>Stack类：堆栈</p><p>LinkedList：双向链表，从JDK1.6之后又实现了双端队列</p><h3 id="ArrayList与Vector的区别？"><a href="#ArrayList与Vector的区别？" class="headerlink" title="ArrayList与Vector的区别？"></a>ArrayList与Vector的区别？</h3><p>它们的底层物理结构都是数组，我们称为动态数组。</p><ul><li>ArrayList是新版的动态数组，线程不安全，效率高，Vector是旧版的动态数组，线程安全，效率低。</li><li>动态数组的扩容机制不同，ArrayList扩容为原来的1.5倍，Vector扩容增加为原来的2倍。</li><li>数组的初始化容量，如果在构建ArrayList与Vector的集合对象时，没有显式指定初始化容量，那么Vector的内部数组的初始容量默认为10，而ArrayList在JDK1.6及之前的版本也是10，而JDK1.7之后的版本ArrayList初始化为长度为0的空数组，之后在添加第一个元素时，再创建长度为10的数组。</li><li>Vector因为版本古老，支持Enumeration 迭代器。但是该迭代器不支持快速失败。而Iterator和ListIterator迭代器支持快速失败。如果在迭代器创建后的任意时间从结构上修改了向量（通过迭代器自身的 remove 或 add 方法之外的任何其他方式），则迭代器将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就完全失败，而不是冒着在将来不确定的时间任意发生不确定行为的风险。</li></ul><p><strong>提示：</strong>在List列表集合实现中都有一个变量modCount，每次添加、删除都会使得modCount变量增加，因此用foreach和Iterator迭代时，如果再通过集合的add和remove等方法修改集合，会抛出 ConcurrentModificationException。</p><h3 id="Vector与Stack的区别与联系？"><a href="#Vector与Stack的区别与联系？" class="headerlink" title="Vector与Stack的区别与联系？"></a>Vector与Stack的区别与联系？</h3><p>Stack类是Vector的子类。</p><p>Stack类表示后进先出（LIFO）的对象堆栈。它通过五个操作对类 Vector 进行了扩展 ，允许将向量视为堆栈。它提供了通常的 push 和 pop 操作，以及取堆栈顶点的 peek 方法、测试堆栈是否为空的 empty 方法、在堆栈中查找项并确定到堆栈顶距离的 search 方法。</p><h3 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h3><p>除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。</p><p>代码示例一：作为List的普通列表形式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLinkedList</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Object object : list) &#123;</span><br><span class="line">System.out.println(object);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.6之后LinkedList实现了Deque接口。双端队列也可用作 LIFO（后进先出）堆栈。如果要使用堆栈结构的集合，可以考虑使用LinkedList，而不是Stack。</p><table><thead><tr><th>堆栈方法</th><th>等效Deque方法</th></tr></thead><tbody><tr><td>push(e)</td><td>addFirst(e)</td></tr><tr><td>pop()</td><td>removeFirst()</td></tr><tr><td>peek()</td><td>peekFirst()</td></tr></tbody></table><p>代码示例二：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList();</span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line">list.addFirst(<span class="number">1</span>);</span><br><span class="line">list.addFirst(<span class="number">2</span>);</span><br><span class="line">list.addFirst(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈： LIFO（后进先出）</span></span><br><span class="line">System.out.println(list.removeFirst());<span class="comment">//3</span></span><br><span class="line">System.out.println(list.removeFirst());<span class="comment">//2</span></span><br><span class="line">System.out.println(list.removeFirst());<span class="comment">//1</span></span><br><span class="line"><span class="comment">//栈空了，会报异常java.util.NoSuchElementException</span></span><br><span class="line">System.out.println(list.removeFirst());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用作队列时，将得到 FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。</p><table><thead><tr><th>Queue 方法</th><th>等效 Deque 方法</th></tr></thead><tbody><tr><td>add(e)</td><td>addLast(e)</td></tr><tr><td>offer(e)</td><td>offerLast(e)</td></tr><tr><td>remove()</td><td>removeFirst()</td></tr><tr><td>poll()</td><td>pollFirst()</td></tr><tr><td>element()</td><td>getFirst()</td></tr><tr><td>peek()</td><td>peekFirst()</td></tr></tbody></table><p>代码示例三：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList();</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line">list.addLast(<span class="number">1</span>);</span><br><span class="line">list.addLast(<span class="number">2</span>);</span><br><span class="line">list.addLast(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队， FIFO（先进先出）</span></span><br><span class="line">System.out.println(list.pollFirst());<span class="comment">//1</span></span><br><span class="line">System.out.println(list.pollFirst());<span class="comment">//2</span></span><br><span class="line">System.out.println(list.pollFirst());<span class="comment">//3</span></span><br><span class="line"><span class="comment">//队空了，返回null</span></span><br><span class="line">System.out.println(list.pollFirst());<span class="comment">//null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。</p><table><thead><tr><th></th><th>第一个元素（头部）</th><th></th><th>最后一个元素（尾部）</th><th></th></tr></thead><tbody><tr><td></td><td>抛出异常</td><td>特殊值</td><td>抛出异常</td><td>特殊值</td></tr><tr><td>插入</td><td>addFirst(e)</td><td>offerFirst(e)</td><td>addLast(e)</td><td>offerLast(e)</td></tr><tr><td>移除</td><td>removeFirst()</td><td>pollFirst()</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>检查</td><td>getFirst()</td><td>peekFirst()</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><h2 id="List集合的遍历"><a href="#List集合的遍历" class="headerlink" title="List集合的遍历"></a>List集合的遍历</h2><h3 id="普通for循环遍历"><a href="#普通for循环遍历" class="headerlink" title="普通for循环遍历"></a>普通for循环遍历</h3><p>对于ArrayList和Vector这样的动态数组，也可以使用普通for循环进行遍历。</p><h3 id="ListIterator迭代器"><a href="#ListIterator迭代器" class="headerlink" title="ListIterator迭代器"></a>ListIterator迭代器</h3><p>List 集合额外提供了一个 listIterator() 方法，该方法返回一个 ListIterator 对象， ListIterator 接口继承了 Iterator 接口，提供了专门操作 List 的方法：</p><ul><li>void add()：通过迭代器添加元素到对应集合</li><li>void set(Object obj)：通过迭代器替换正迭代的元素</li><li>void remove()：通过迭代器删除刚迭代的元素</li></ul><ul><li>boolean hasPrevious()：如果以逆向遍历列表，往前是否还有元素。</li><li>Object previous()：返回列表中的前一个元素。</li><li>int previousIndex()：返回列表中的前一个元素的索引</li></ul><ul><li>boolean hasNext()</li><li>Object next()</li><li>int nextIndex()</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="number">10</span>);<span class="comment">//指定初始容量initialCapacity为10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);<span class="comment">//指定capacityIncrement增量为0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement增量为<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  <span class="comment">//判断了形参初始容量initialCapacity的合法性</span></span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                       initialCapacity);</span><br><span class="line">  <span class="comment">//创建了一个Object[]类型的数组</span></span><br><span class="line">  <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];<span class="comment">//默认是10</span></span><br><span class="line">  <span class="comment">//增量，默认是0，如果是0，后面就按照2倍增加，如果不是0，后面就按照你指定的增量进行增量</span></span><br><span class="line">  <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//synchronized意味着线程安全的   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//看是否需要扩容</span></span><br><span class="line">  ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//把新的元素存入[elementCount]，存入后，elementCount元素的个数增1</span></span><br><span class="line">  elementData[elementCount++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="comment">//看是否超过了当前数组的容量</span></span><br><span class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    grow(minCapacity);<span class="comment">//扩容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//获取目前数组的长度</span></span><br><span class="line">  <span class="comment">//如果capacityIncrement增量是0，新容量 = oldCapacity的2倍</span></span><br><span class="line">  <span class="comment">//如果capacityIncrement增量是不是0，新容量 = oldCapacity + capacityIncrement增量;</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                   capacityIncrement : oldCapacity);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果按照上面计算的新容量还不够，就按照你指定的需要的最小容量来扩容minCapacity</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果新容量超过了最大数组限制，那么单独处理</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//把旧数组中的数据复制到新数组中，新数组的长度为newCapacity</span></span><br><span class="line">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> removeElement(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeElement</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//查找obj在当前Vector中的下标</span></span><br><span class="line">  <span class="keyword">int</span> i = indexOf(obj);</span><br><span class="line">  <span class="comment">//如果i&gt;=0，说明存在，删除[i]位置的元素</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    removeElementAt(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> indexOf(o, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;<span class="comment">//要查找的元素是null值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">      <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)<span class="comment">//如果是null值，用==null判断</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//要查找的元素是非null值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">      <span class="keyword">if</span> (o.equals(elementData[i]))<span class="comment">//如果是非null值，用equals判断</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//判断下标的合法性</span></span><br><span class="line">  <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">                                             elementCount);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//j是要移动的元素的个数</span></span><br><span class="line">  <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//如果需要移动元素，就调用System.arraycopy进行移动</span></span><br><span class="line">  <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//把index+1位置以及后面的元素往前移动</span></span><br><span class="line">    <span class="comment">//index+1的位置的元素移动到index位置，依次类推</span></span><br><span class="line">    <span class="comment">//一共移动j个</span></span><br><span class="line">    System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//元素的总个数减少</span></span><br><span class="line">  elementCount--;</span><br><span class="line">  <span class="comment">//将elementData[elementCount]这个位置置空，用来添加新元素，位置的元素等着被GC回收</span></span><br><span class="line">  elementData[elementCount] = <span class="keyword">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h3><p>JDK1.6：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="number">10</span>);<span class="comment">//指定初始容量为10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  <span class="comment">//检查初始容量的合法性</span></span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> + initialCapacity);</span><br><span class="line">  <span class="comment">//数组初始化为长度为initialCapacity的数组</span></span><br><span class="line">  <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.7</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;<span class="comment">//默认初始容量10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="comment">//数组初始化为一个空数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  elementData[size++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;<span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">    <span class="comment">//minCapacity按照 默认初始容量和minCapacity中的的最大值处理</span></span><br><span class="line">    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//看是否需要扩容处理</span></span><br><span class="line">  ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>JDK1.8</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<span class="comment">//初始化为空数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//存入新元素到[size]位置，然后size自增1</span></span><br><span class="line">  elementData[size++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">  <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    <span class="comment">//那么minCapacity取DEFAULT_CAPACITY与minCapacity的最大值</span></span><br><span class="line">    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//查看是否需要扩容</span></span><br><span class="line">  ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果需要的最小容量  比  当前数组的长度  大，即当前数组不够存，就扩容</span></span><br><span class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//当前数组容量</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//新数组容量是旧数组容量的1.5倍</span></span><br><span class="line">  <span class="comment">//看旧数组的1.5倍是否够</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line">  <span class="comment">//看旧数组的1.5倍是否超过最大数组限制</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//复制一个新数组</span></span><br><span class="line">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先找到o在当前ArrayList的数组中的下标</span></span><br><span class="line">  <span class="comment">//分o是否为空两种情况讨论</span></span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">      <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;<span class="comment">//null值用==比较</span></span><br><span class="line">        fastRemove(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">      <span class="keyword">if</span> (o.equals(elementData[index])) &#123;<span class="comment">//非null值用equals比较</span></span><br><span class="line">        fastRemove(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line">  <span class="comment">//需要移动的元素个数</span></span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                     numMoved);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">  modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被删除的元素，用于最后返回被删除的元素</span></span><br><span class="line">  E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//需要移动的元素个数</span></span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                     numMoved);</span><br><span class="line">  <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被替换的元素，用于最后返回被替换的元素</span></span><br><span class="line">  E oldValue = elementData(index);</span><br><span class="line">  <span class="comment">//用element替换[index]位置的元素</span></span><br><span class="line">  elementData[index] = element;</span><br><span class="line">  <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elementData(index);<span class="comment">//返回[index]位置的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//从前往后找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//从后往前找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">Node&lt;E&gt; first;<span class="comment">//记录第一个结点的位置</span></span><br><span class="line">Node&lt;E&gt; last;<span class="comment">//记录最后一个结点的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  E item;<span class="comment">//元素数据</span></span><br><span class="line">  Node&lt;E&gt; next;<span class="comment">//下一个结点</span></span><br><span class="line">  Node&lt;E&gt; prev;<span class="comment">//前一个结点</span></span><br><span class="line"></span><br><span class="line">  Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.item = element;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">    <span class="keyword">this</span>.prev = prev;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  linkLast(e);<span class="comment">//默认把新元素链接到链表尾部</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; l = last;<span class="comment">//用l 记录原来的最后一个结点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建新结点</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">//现在的新结点是最后一个结点了</span></span><br><span class="line">  last = newNode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果l==null，说明原来的链表是空的</span></span><br><span class="line">  <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">//那么新结点同时也是第一个结点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">//否则把新结点链接到原来的最后一个结点的next中</span></span><br><span class="line">    l.next = newNode;</span><br><span class="line">  <span class="comment">//元素个数增加</span></span><br><span class="line">  size++;</span><br><span class="line">  <span class="comment">//修改次数增加</span></span><br><span class="line">  modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//分o是否为空两种情况</span></span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//找到o对应的结点x</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">        unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//找到o对应的结点x</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">        unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;<span class="comment">//x是要被删除的结点</span></span><br><span class="line">  <span class="comment">// assert x != null;</span></span><br><span class="line">  <span class="keyword">final</span> E element = x.item;<span class="comment">//被删除结点的数据</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; next = x.next;<span class="comment">//被删除结点的下一个结点</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="comment">//被删除结点的上一个结点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果被删除结点的前面没有结点，说明被删除结点是第一个结点</span></span><br><span class="line">  <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//那么被删除结点的下一个结点变为第一个结点</span></span><br><span class="line">    first = next;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是第一个结点</span></span><br><span class="line">    <span class="comment">//被删除结点的上一个结点的next指向被删除结点的下一个结点</span></span><br><span class="line">    prev.next = next;</span><br><span class="line">    <span class="comment">//断开被删除结点与上一个结点的链接</span></span><br><span class="line">    x.prev = <span class="keyword">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果被删除结点的后面没有结点，说明被删除结点是最后一个结点</span></span><br><span class="line">  <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//那么被删除结点的上一个结点变为最后一个结点</span></span><br><span class="line">    last = prev;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是最后一个结点</span></span><br><span class="line">    <span class="comment">//被删除结点的下一个结点的prev执行被删除结点的上一个结点</span></span><br><span class="line">    next.prev = prev;</span><br><span class="line">    <span class="comment">//断开被删除结点与下一个结点的连接</span></span><br><span class="line">    x.next = <span class="keyword">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//把被删除结点的数据也置空，使得GC回收</span></span><br><span class="line">  x.item = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//元素个数减少</span></span><br><span class="line">  size--;</span><br><span class="line">  <span class="comment">//修改次数增加</span></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//返回被删除结点的数据</span></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h1><p>Set接口是Collection的子接口，set接口没有提供额外的方法。因此Set集合支持的遍历方式和Collection集合一样：foreach和Iterator。</p><p>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。</p><p>Set的常用实现类有：HashSet、TreeSet、LinkedHashSet。</p><blockquote><p>Set系列的集合：不可重复的<br>Set系列的集合，有有序的也有无序的。HashSet无序的，TreeSet按照元素的大小顺序遍历，LinkedHashSet按照元素的添加顺序遍历。</p></blockquote><h2 id="实现类的特点"><a href="#实现类的特点" class="headerlink" title="实现类的特点"></a>实现类的特点</h2><h3 id="HashSet和LinkedHashSet"><a href="#HashSet和LinkedHashSet" class="headerlink" title="HashSet和LinkedHashSet"></a>HashSet和LinkedHashSet</h3><p>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。</p><p>HashSet底层是HashMap实现。添加到HashSet的元素是作为HashMap的key，value是一个Object类型的常量对象PRESENT。依赖于元素的hashCode()和equals()保证元素的不可重复，存储位置和hashCode()值有关，根据hashCode()来算出它在底层table数组中的[index]</p><p>HashSet 和LinkedHashSet按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。HashSet 和LinkedHashSet集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。因此，存储到HashSet和LinkedHashSet的元素要重写hashCode和equals方法。</p><p>LinkedHashSet是HashSet的子类，它在HashSet的基础上，在结点中增加两个属性before和after维护了结点的前后添加顺序。LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。</p><p>底层是LinkedHashMap。添加到LinkedHashSet的元素是作为LinkedHashMap的key，value是一个Object类型的常量对象PRESENT。LinkedHashSet是HashSet的子类，比父类多维护了元素的添加顺序。当且仅当，你既想要元素不可重复，又要保证元素的添加顺序时，再使用它。</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>底层是TreeMap实现。添加到TreeSet的元素是作为TreeMap的key，value是一个Object类型的常量对象PRESENT。</p><p>依赖于元素的大小，要么是java.lang.Comparable接口compareTo(Object obj)，要么是java.util.Comparator接口的compare(Object o1, Object o2)来比较元素的大小。认为大小相等的两个元素就是重复元素。</p><p>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。使用元素的自然顺序(Comparable)对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。</p><h1 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h1><p>用来存储键值对，映射关系的集合。所有的Map的key都不能重复。</p><p>键值对、映射关系的类型：Entry类型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entry接口是Map接口的内部接口。所有的Map的键值对的类型都实现了这个接口。</span><br><span class="line">HashMap中的映射关系，是有一个内部类来实现Entry的接口，JDK1.7是一个叫做Entry的内部类实现Entry接口。</span><br><span class="line">JDK1.8是一个叫做Node的内部类实现Entry接口。</span><br><span class="line">TreeMap中的映射关系，是有一个内部类Entry来实现Entry的接口</span><br></pre></td></tr></table></figure><ul><li><p>Map 中的 key 和 value 都可以是任何引用类型的数据</p></li><li><p>Map 中的 key 不允许重复</p></li><li><p>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value。</p></li></ul><p>Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。映射顺序 定义为迭代器在映射的 collection 视图上返回其元素的顺序。某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap 类</p><h2 id="Map的方法"><a href="#Map的方法" class="headerlink" title="Map的方法"></a>Map的方法</h2><p>1、添加操作</p><ul><li><p>Object put(Object key,Object value)</p></li><li><p>void putAll(Map t)</p></li></ul><p>2、删除</p><ul><li><p>void clear()</p></li><li><p>Object remove(Object key)</p></li></ul><p>3、元素查询的操作</p><ul><li><p>Object get(Object key)</p></li><li><p>boolean containsKey(Object key)</p></li><li><p>boolean containsValue(Object value)</p></li><li><p>boolean isEmpty()</p></li></ul><p>4、元视图操作的方法：</p><ul><li><p>Set keySet()</p></li><li><p>Collection values()</p></li><li><p>Set entrySet()</p></li></ul><p>5、其他方法</p><ul><li>int size()</li></ul><h2 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h2><p>Collection集合的遍历：（1）foreach（2）通过Iterator对象遍历</p><p>Map的遍历，不能支持foreach</p><p>（1）分开遍历：单独遍历所有key</p><p>​      单独遍历所有value</p><p>（2）成对遍历：遍历的是映射关系Map.Entry</p><p>Map.Entry是Map接口的内部接口。每一种Map内部有自己的Map.Entry的实现类</p><p>在Map中存储数据，实际上是将Key—-&gt;value的数据存储在Map.Entry接口的实例中，再在Map集合中插入Map.Entry的实例化对象</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/map.png" alt="map"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMap</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"许仙"</span>, <span class="string">"白娘子"</span>);</span><br><span class="line">map.put(<span class="string">"董永"</span>, <span class="string">"七仙女"</span>);</span><br><span class="line">map.put(<span class="string">"牛郎"</span>, <span class="string">"织女"</span>);</span><br><span class="line">map.put(<span class="string">"许仙"</span>, <span class="string">"小青"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"所有的key:"</span>);</span><br><span class="line">Set keySet = map.keySet();</span><br><span class="line"><span class="keyword">for</span> (Object key : keySet) &#123;</span><br><span class="line">System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"所有的value："</span>);</span><br><span class="line">Collection values = map.values();</span><br><span class="line"><span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"所有的映射关系"</span>);</span><br><span class="line">Set entrySet = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Object entry : entrySet) &#123;</span><br><span class="line">System.out.println(entry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map的实现类们的区别"><a href="#Map的实现类们的区别" class="headerlink" title="Map的实现类们的区别"></a>Map的实现类们的区别</h2><ul><li><p>HashMap：</p><p>依据key的hashCode()和equals()来保证key是否重复。</p><p>key如果重复，新的value会替换旧的value。</p><p>hashCode()决定了映射关系在table数组中的存储的位置，index = hash(key.hashCode()) &amp; table.length-1 </p><p>HashMap的底层实现：JDK1.7是数组+链表；JDK1.8是数组+链表/红黑树</p></li><li><p>TreeMap</p><p>依据key的大小来保证key是否重复。key如果重复，新的value会替换旧的value。</p><p>key的大小依赖于，java.lang.Comparable或java.util.Comparator。</p></li><li><p>LinkedHashMap</p><p>依据key的hashCode()和equals()来保证key是否重复。key如果重复，新的value会替换旧的value。</p><p>LinkedHashMap是HashMap的子类，比HashMap多了添加顺序</p></li><li><p>Properties</p><p>Properties 类是 Hashtable 的子类，Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。</p><p>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Properties properties = System.getProperties();</span><br><span class="line">String p2 = properties.getProperty(<span class="string">"file.encoding"</span>);<span class="comment">//当前源文件字符编码</span></span><br><span class="line">System.out.println(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><h3 id="JDK1-6源码："><a href="#JDK1-6源码：" class="headerlink" title="JDK1.6源码："></a>JDK1.6源码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//this.loadFactor加载因子，影响扩容的频率</span></span><br><span class="line">  <span class="comment">//DEFAULT_LOAD_FACTOR：默认加载因子0.75</span></span><br><span class="line">  <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">  <span class="comment">//threshold阈值 = 容量 * 加载因子</span></span><br><span class="line">  <span class="comment">//threshold阈值，当size达到threhold时，考虑扩容</span></span><br><span class="line">  <span class="comment">//扩容需要两个条件同时满足：（1）size &gt;= threhold （2）table[index]！=null，即新映射关系要存入的位置非空</span></span><br><span class="line">  threshold = (<span class="keyword">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</span><br><span class="line">  <span class="comment">//table是数组，</span></span><br><span class="line">  <span class="comment">//DEFAULT_INITIAL_CAPACITY：默认是16</span></span><br><span class="line">  table = <span class="keyword">new</span> Entry[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">  init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK1-7源码："><a href="#JDK1-7源码：" class="headerlink" title="JDK1.7源码："></a>JDK1.7源码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//DEFAULT_INITIAL_CAPACITY：默认初始容量16</span></span><br><span class="line">  <span class="comment">//DEFAULT_LOAD_FACTOR：默认加载因子0.75</span></span><br><span class="line">  <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//校验initialCapacity合法性</span></span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">  <span class="comment">//校验initialCapacity合法性                                       </span></span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">  <span class="comment">//校验loadFactor合法性</span></span><br><span class="line">  <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line">                                               </span><br><span class="line"><span class="comment">//加载因子，初始化为0.75</span></span><br><span class="line">  <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">  <span class="comment">// threshold 初始为初始容量                                  </span></span><br><span class="line">  threshold = initialCapacity;</span><br><span class="line">  init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果table数组是空的，那么先创建数组</span></span><br><span class="line">  <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">    <span class="comment">//threshold一开始是初始容量的值</span></span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果key是null，单独处理</span></span><br><span class="line">  <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对key的hashCode进行干扰，算出一个hash值</span></span><br><span class="line">  <span class="keyword">int</span> hash = hash(key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算新的映射关系应该存到table[i]位置，</span></span><br><span class="line">  <span class="comment">//i = hash &amp; table.length-1，可以保证i在[0,table.length-1]范围内</span></span><br><span class="line">  <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查table[i]下面有没有key与我新的映射关系的key重复，如果重复替换value</span></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">    Object k;</span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      e.value = value;</span><br><span class="line">      e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//添加新的映射关系</span></span><br><span class="line">  addEntry(hash, key, value, i);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">  <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);<span class="comment">//容量是等于toSize值的最接近的2的n次方</span></span><br><span class="line">  <span class="comment">//计算阈值 = 容量 * 加载因子</span></span><br><span class="line">  threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//创建Entry[]数组，长度为capacity</span></span><br><span class="line">  table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">  initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果key是null，直接存入[0]的位置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判断是否有重复的key，如果有重复的，就替换value</span></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      e.value = value;</span><br><span class="line">      e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//把新的映射关系存入[0]的位置，而且key的hash值用0表示</span></span><br><span class="line">  addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判断是否需要库容</span></span><br><span class="line">  <span class="comment">//扩容：（1）size达到阈值（2）table[i]正好非空</span></span><br><span class="line">  <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">    <span class="comment">//table扩容为原来的2倍，并且扩容后，会重新调整所有映射关系的存储位置</span></span><br><span class="line">    resize(<span class="number">2</span> * table.length);</span><br><span class="line">    <span class="comment">//新的映射关系的hash和index也会重新计算</span></span><br><span class="line">    hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">    bucketIndex = indexFor(hash, table.length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//存入table中</span></span><br><span class="line">  createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">  Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">  <span class="comment">//原来table[i]下面的映射关系作为新的映射关系next</span></span><br><span class="line">  table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">  size++;<span class="comment">//个数增加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>put(key,value)</strong></p><ul><li><p>当第一次添加映射关系时，数组初始化为一个长度为<strong>16</strong>的<strong>HashMap$Entry</strong>的数组，这个HashMap$Entry类型是实现了java.util.<strong>Map.Entry</strong>接口</p></li><li><p>特殊考虑：如果key为null，index直接是[0]</p></li><li><p>在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p></li><li><p>计算index = table.length-1 &amp; hash;</p></li><li><p>如果table[index]下面，已经有映射关系的key与我要添加的新的映射关系的key相同了，会用新的value替换旧的value。</p></li><li><p>如果没有相同的，会把新的映射关系添加到链表的头，原来table[index]下面的Entry对象连接到新的映射关系的next中。</p></li><li><p>添加之前先判断if(size &gt;= threshold  &amp;&amp;  table[index]!=null)如果该条件为true，会扩容</p></li></ul><p>​    if ( size &gt;= threshold  &amp;&amp;  table[index]!=null ) {</p><p>​        ①会扩容</p><p>​        ②会重新计算key的hash</p><p>​        ③会重新计算index</p><p>​    }</p><p><strong>get(key)</strong></p><ul><li><p>计算key的hash值，用这个方法hash(key)</p></li><li><p>找index = table.length-1 &amp; hash;</p></li><li><p>如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就返回它的value</p></li></ul><p><strong>remove(key)</strong></p><ul><li><p>计算key的hash值，用这个方法hash(key)</p></li><li><p>找index = table.length-1 &amp; hash;</p></li><li><p>如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</p></li></ul><h3 id="JDK1-8源码"><a href="#JDK1-8源码" class="headerlink" title="JDK1.8源码"></a>JDK1.8源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">几个常量和变量：</span><br><span class="line">（<span class="number">1</span>）DEFAULT_INITIAL_CAPACITY：默认的初始容量 <span class="number">16</span></span><br><span class="line">（<span class="number">2</span>）MAXIMUM_CAPACITY：最大容量  <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br><span class="line">（<span class="number">3</span>）DEFAULT_LOAD_FACTOR：默认加载因子 <span class="number">0.75</span></span><br><span class="line">（<span class="number">4</span>）TREEIFY_THRESHOLD：默认树化阈值<span class="number">8</span>，当链表的长度达到这个值后，要考虑树化</span><br><span class="line">（<span class="number">5</span>）UNTREEIFY_THRESHOLD：默认反树化阈值<span class="number">6</span>，当树中的结点的个数达到这个阈值后，要考虑变为链表</span><br><span class="line">（<span class="number">6</span>）MIN_TREEIFY_CAPACITY：最小树化容量<span class="number">64</span></span><br><span class="line">当单个的链表的结点个数达到<span class="number">8</span>，并且table的长度达到<span class="number">64</span>，才会树化。</span><br><span class="line">当单个的链表的结点个数达到<span class="number">8</span>，但是table的长度未达到<span class="number">64</span>，会先扩容</span><br><span class="line">（<span class="number">7</span>）Node&lt;K,V&gt;[] table：数组</span><br><span class="line">（<span class="number">8</span>）size：记录有效映射关系的对数，也是Entry对象的个数</span><br><span class="line">（<span class="number">9</span>）<span class="keyword">int</span> threshold：阈值，当size达到阈值时，考虑扩容</span><br><span class="line">（<span class="number">10</span>）<span class="keyword">double</span> loadFactor：加载因子，影响扩容的频率</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">  <span class="comment">// all other fields defaulted，其他字段都是默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目的：干扰hashCode值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="comment">//如果key是null，hash是0</span></span><br><span class="line">  <span class="comment">//如果key非null，用key的hashCode值 与 key的hashCode值高16进行异或</span></span><br><span class="line">  <span class="comment">//即就是用key的hashCode值高16位与低16位进行了异或的干扰运算</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">index = hash &amp; table.length-1</span></span><br><span class="line"><span class="comment">如果用key的原始的hashCode值  与 table.length-1 进行按位与，那么基本上高16没机会用上。</span></span><br><span class="line"><span class="comment">这样就会增加冲突的概率，为了降低冲突的概率，把高16位加入到hash信息中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; <span class="comment">//数组</span></span><br><span class="line">  Node&lt;K,V&gt; p; <span class="comment">//一个结点</span></span><br><span class="line">  <span class="keyword">int</span> n, i;<span class="comment">//n是数组的长度   i是下标</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//tab和table等价</span></span><br><span class="line">  <span class="comment">//如果table是空的</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)&#123;</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">tab = resize();</span></span><br><span class="line"><span class="comment">n = tab.length;*/</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">如果table是空的，resize()完成了①创建了一个长度为16的数组②threshold = 12</span></span><br><span class="line"><span class="comment">n = 16</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//i = (n - 1) &amp; hash ，下标 = 数组长度-1 &amp; hash</span></span><br><span class="line">  <span class="comment">//p = tab[i] 第1个结点</span></span><br><span class="line">  <span class="comment">//if(p==null) 条件满足的话说明 table[i]还没有元素</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//把新的映射关系直接放入table[i]</span></span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//newNode（）方法就创建了一个Node类型的新结点，新结点的next是null</span></span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; </span><br><span class="line">    K k;</span><br><span class="line">    <span class="comment">//p是table[i]中第一个结点</span></span><br><span class="line">    <span class="comment">//if(table[i]的第一个结点与新的映射关系的key重复)</span></span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">      e = p;<span class="comment">//用e记录这个table[i]的第一个结点</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123;<span class="comment">//如果table[i]第一个结点是一个树结点</span></span><br><span class="line">      <span class="comment">//单独处理树结点</span></span><br><span class="line">      <span class="comment">//如果树结点中，有key重复的，就返回那个重复的结点用e接收，即e!=null</span></span><br><span class="line">      <span class="comment">//如果树结点中，没有key重复的，就把新结点放到树中，并且返回null，即e=null</span></span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//table[i]的第一个结点不是树结点，也与新的映射关系的key不重复</span></span><br><span class="line">      <span class="comment">//binCount记录了table[i]下面的结点的个数</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="comment">//如果p的下一个结点是空的，说明当前的p是最后一个结点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//把新的结点连接到table[i]的最后</span></span><br><span class="line">          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//如果binCount&gt;=8-1，达到7个时</span></span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)&#123; <span class="comment">// -1 for 1st</span></span><br><span class="line">            <span class="comment">//要么扩容，要么树化</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果key重复了，就跳出for循环，此时e结点记录的就是那个key重复的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = e;<span class="comment">//下一次循环，e=p.next，就类似于e=e.next，往链表下移动</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果这个e不是null，说明有key重复，就考虑替换原来的value</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)&#123;</span><br><span class="line">        e.value = value;</span><br><span class="line">      &#125;</span><br><span class="line">      afterNodeAccess(e);<span class="comment">//什么也没干</span></span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++modCount;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//元素个数增加</span></span><br><span class="line">  <span class="comment">//size达到阈值</span></span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)&#123;</span><br><span class="line">    resize();<span class="comment">//一旦扩容，重新调整所有映射关系的位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  afterNodeInsertion(evict);<span class="comment">//什么也没干</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//oldTab原来的table</span></span><br><span class="line">  <span class="comment">//oldCap：原来数组的长度</span></span><br><span class="line">  <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//oldThr：原来的阈值</span></span><br><span class="line">  <span class="keyword">int</span> oldThr = threshold;<span class="comment">//最开始threshold是0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//newCap，新容量</span></span><br><span class="line">  <span class="comment">//newThr：新阈值</span></span><br><span class="line">  <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//说明原来不是空数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//是否达到数组最大限制</span></span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">              oldCap &gt;= DEFAULT_INITIAL_CAPACITY)&#123;</span><br><span class="line">      <span class="comment">//newCap = 旧的容量*2 ，新容量&lt;最大数组容量限制</span></span><br><span class="line">      <span class="comment">//新容量：32,64，...</span></span><br><span class="line">      <span class="comment">//oldCap &gt;= 初始容量16</span></span><br><span class="line">      <span class="comment">//新阈值重新算 = 24，48 ....</span></span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)&#123; <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//新容量是默认初始化容量16</span></span><br><span class="line">    <span class="comment">//新阈值= 默认的加载因子 * 默认的初始化容量 = 0.75*16 = 12</span></span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  threshold = newThr;<span class="comment">//阈值赋值为新阈值12，24.。。。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建了一个新数组，长度为newCap，16，32,64.。。</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;<span class="comment">//原来不是空数组</span></span><br><span class="line">    <span class="comment">//把原来的table中映射关系，倒腾到新的table中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;<span class="comment">//e是table下面的结点</span></span><br><span class="line">        oldTab[j] = <span class="keyword">null</span>;<span class="comment">//把旧的table[j]位置清空</span></span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)<span class="comment">//如果是最后一个结点</span></span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;<span class="comment">//重新计算e的在新table中的存储位置，然后放入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果e是树结点</span></span><br><span class="line">          <span class="comment">//把原来的树拆解，放到新的table</span></span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">把原来table[i]下面的整个链表，重新挪到了新的table中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建一个新结点</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, index; </span><br><span class="line">  Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="comment">//MIN_TREEIFY_CAPACITY：最小树化容量64</span></span><br><span class="line">  <span class="comment">//如果table是空的，或者  table的长度没有达到64</span></span><br><span class="line">  <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">    resize();<span class="comment">//先扩容</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//用e记录table[index]的结点的地址</span></span><br><span class="line">    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">do...while，把table[index]链表的Node结点变为TreeNode类型的结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">        hd = p;<span class="comment">//hd记录根结点</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        p.prev = tl;</span><br><span class="line">        tl.next = p;</span><br><span class="line">      &#125;</span><br><span class="line">      tl = p;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果table[index]下面不是空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">      hd.treeify(tab);<span class="comment">//将table[index]下面的链表进行树化</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加过程</strong></p><ul><li><p>当第一次添加映射关系时，数组初始化为一个长度为<strong>16</strong>的<strong>HashMap$Node</strong>的数组，这个HashMap$Node类型是实现了java.util.<strong>Map.Entry</strong>接口</p></li><li><p>在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p></li></ul><blockquote><p>JDK1.8关于hash(key)方法的实现比JDK1.7要简洁。 key.hashCode() ^ key.Code()&gt;&gt;&gt;16;</p></blockquote><ul><li><p>计算index = table.length-1 &amp; hash;</p></li><li><p>如果table[index]下面，已经有映射关系的key与我要添加的新的映射关系的key相同了，会用新的value替换旧的value。</p></li><li><p>如果没有相同的，</p><p>① table[index]链表的长度没有达到8个，会把新的映射关系添加到链表的尾</p><p>② table[index]链表的长度达到8个，但是table.length没有达到64，会先对table进行扩容，然后再添加</p><p>③ table[index]链表的长度达到8个，并且table.length达到64，会先把该分支进行树化，结点的类型变为TreeNode，然后把链表转    为一棵红黑树</p><p>④table[index]本来就已经是红黑树了，那么直接连接到树中，可能还会考虑考虑左旋右旋以保证树的平衡问题</p></li><li><p>添加完成后判断 if (size &gt; threshold ){</p><p>① 会扩容</p><p>② 会重新计算key的hash</p><p>③ 会重新计算index</p></li></ul><p>​    }</p><p><strong>remove(key)</strong></p><ul><li>计算key的hash值，用这个方法hash(key)</li><li>找index = table.length-1 &amp; hash;</li><li>如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</li><li>如果table[index]下面原来是红黑树，结点删除后，个数小于等于6，会把红黑树变为链表</li></ul><h3 id="关于HashMap的面试问题"><a href="#关于HashMap的面试问题" class="headerlink" title="关于HashMap的面试问题"></a>关于HashMap的面试问题</h3><p>1、HashMap的底层实现</p><blockquote><p>答：JDK1.7是数组+链表，JDK1.8是数组+链表/红黑树</p></blockquote><p>2、HashMap的数组的元素类型</p><blockquote><p>答：java.util.Map$Entry接口类型。</p><p>JDK1.7的HashMap中有内部类Entry实现Entry接口</p><p>JDK1.8的HashMap中有内部类Node和TreeNode类型实现Entry接口</p></blockquote><p>3、为什么要使用数组？</p><blockquote><p> 答：因为数组的访问的效率高</p></blockquote><p>4、为什么数组还需要链表？或问如何解决hash或[index]冲突问题？</p><blockquote><p> 答：为了解决hash和[index]冲突问题</p><p> （1）两个不相同的key的hashCode值本身可能相同</p><p> （2）两个hashCode不相同的key，通过hash(key)以及 hash &amp; table.length-1运算得到的[index]可能相同</p><p> 那么意味着table[index]下可能需要存储多个Entry的映射关系对象，所以需要链表</p></blockquote><p>5、HashMap的数组的初始化长度</p><blockquote><p>答：默认的初始容量值是16</p></blockquote><p>6、HashMap的映射关系的存储索引index如何计算</p><blockquote><p>答：hash &amp; table.length-1</p></blockquote><p>7、为什么要使用hashCode()? 空间换时间</p><blockquote><p>答：因为hashCode()是一个整数值，可以用来直接计算index，效率比较高，用数组这种结构虽然会浪费一些空间，但是可以提高查询效率。</p></blockquote><p>8、hash()函数的作用是什么</p><blockquote><p> 答：在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p><p> JDK1.8关于hash(key)方法的实现比JDK1.7要简洁。 key.hashCode() ^ key.Code()&gt;&gt;&gt;16; 因为这样可以使得hashCode的高16位信息也能参与到运算中来</p></blockquote><p>9、HashMap的数组长度为什么一定要是2的幂次方</p><blockquote><p>答：因为2的n次方-1的二进制值是前面都0，后面几位都是1，这样的话，与hash进行&amp;运算的结果就能保证在[0,table.length-1]范围内，而且是均匀的。</p></blockquote><p>10、HashMap 为什么使用 &amp;按位与运算代替%模运算？</p><blockquote><p>答：因为&amp;效率高</p></blockquote><p>11、HashMap的数组什么时候扩容？</p><blockquote><p>答：JDK1.7版：当要添加新Entry对象时发现（1）size达到threshold（2）table[index]!=null时，两个条件同时满足会扩容</p><p>JDK1.8版：当要添加新Entry对象时发现（1）size达到threshold（2）当table[index]下的结点个数达到8个但是table.length又没有达到64。两种情况满足其一都会导致数组扩容</p><p>而且数组一旦扩容，不管哪个版本，都会导致所有映射关系重新调整存储位置。</p></blockquote><p>12、如何计算扩容阈值(临界值)？</p><blockquote><p>答：threshold = capacity * loadfactor</p></blockquote><p>13、loadFactor为什么是0.75，如果是1或者0.1呢有什么不同？</p><blockquote><p>答：1的话，会导致某个table[index]下面的结点个数可能很长</p><p>0.1的话，会导致数组扩容的频率太高</p></blockquote><p>14、JDK1.8的HashMap什么时候树化？</p><blockquote><p>答：当table[index]下的结点个数达到8个但是table.length已经达到64</p></blockquote><p>15、JDK1.8的HashMap什么时候反树化？</p><blockquote><p>答：当table[index]下的树结点个数少于6个</p></blockquote><p>16、JDK1.8的HashMap为什么要树化？</p><blockquote><p>答：因为当table[index]下的结点个数超过8个后，查询效率就低下了，修改为红黑树的话，可以提高查询效率</p></blockquote><p>17、JDK1.8的HashMap为什么要反树化？</p><blockquote><p>答：因为因为当table[index]下树的结点个数少于6个后，使用红黑树反而过于复杂了，此时使用链表既简洁又效率也不错</p></blockquote><p>18、作为HashMap的key类型重写equals和hashCode方法有什么要求</p><p>​    （1）equals与hashCode一起重写</p><p>​    （2）重写equals()方法，但是有一些注意事项；</p><ul><li>自反性：x.equals(x)必须返回true。<br>对称性：x.equals(y)与y.equals(x)的返回值必须相等。<br>传递性：x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)必须为true。<br>一致性：如果对象x和y在equals()中使用的信息都没有改变，那么x.equals(y)值始终不变。<br>非null：x不是null，y为null，则x.equals(y)必须为false。</li></ul><p>​    （3）重写hashCode（）的注意事项</p><ul><li>如果equals返回true的两个对象，那么hashCode值一定相同，并且只要参与equals判断属性没有修改，hashCode值也不能修改；<br>如果equals返回false的两个对象，那么hashCode值可以相同也可以不同；<br>如果hashCode值不同的，equals一定要返回false；<br>hashCode不宜过简单，太简单会导致冲突严重，hashCode也不宜过于复杂，会导致性能低下；</li></ul><p>19、为什么大部分 hashcode 方法使用 31？</p><blockquote><p> 答：因为31是一个不大不小的素数</p></blockquote><p>20、请问已经存储到HashMap中的key的对象属性是否可以修改？为什么？</p><blockquote><p>答：如果该属性参与hashCode的计算，那么不要修改。因为一旦修改hashCode()已经不是原来的值。<br>而存储到HashMap中时，key的hashCode()–&gt;hash()–&gt;hash已经确定了，不会重新计算。用新的hashCode值再查询get(key)/删除remove(key)时，算的hash值与原来不一样就不找不到原来的映射关系了。</p></blockquote><p>21、所以为什么，我们实际开发中，key的类型一般用String和Integer</p><blockquote><p>答：因为他们不可变。</p></blockquote><p>22、为什么HashMap中的Node或Entry类型的hash变量与key变量加final声明？</p><blockquote><p> 答：因为不希望你修改hash和key值</p></blockquote><p>23、为什么HashMap中的Node或Entry类型要单独存储hash？</p><blockquote><p> 答：为了在添加、删除、查找过程中，比较hash效率更高，不用每次重新计算key的hash值</p></blockquote><p>24、请问已经存储到HashMap中的value的对象属性是否可以修改？为什么？</p><blockquote><p>答：可以。因为我们存储、删除等都是根据key，和value无关。</p></blockquote><p>25、如果key是null是如何存储的？</p><blockquote><p>答：会存在table[0]中</p></blockquote><h1 id="集合框架图"><a href="#集合框架图" class="headerlink" title="集合框架图"></a>集合框架图</h1><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection12.png" alt="collection"></p>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用类</title>
      <link href="/2020/06/17/java-common-class/"/>
      <url>/2020/06/17/java-common-class/</url>
      
        <content type="html"><![CDATA[<h1 id="包装类Wrapper"><a href="#包装类Wrapper" class="headerlink" title="包装类Wrapper"></a>包装类Wrapper</h1><p>Java并不是纯面向对象的语言。Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的。基本数据类型有它的优势：性能（效率高，节省空间）。</p><p>但是我们在实际使用中经常需要将基本数据类型转化成对象，便于操作。比如：（1）集合的操作，（2）使用Object类型接收任意类型的数据等，（3）泛型实参，这时，我们就需要将基本数据类型数据转化为对象。</p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>包装类均位于java.lang包，包装类和基本数据类型的对应关系</p><table><thead><tr><th align="center">序号</th><th align="center">基本数据类型</th><th align="center">包装类</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">byte</td><td align="center">Byte</td></tr><tr><td align="center">2</td><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center">3</td><td align="center">int</td><td align="center">Integer</td></tr><tr><td align="center">4</td><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">5</td><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">6</td><td align="center">double</td><td align="center">Double</td></tr><tr><td align="center">7</td><td align="center">char</td><td align="center">Character</td></tr><tr><td align="center">8</td><td align="center">boolean</td><td align="center">Boolean</td></tr><tr><td align="center">9</td><td align="center">void</td><td align="center">Void</td></tr></tbody></table><h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h2><p>JDK1.5之前需要手动装箱与拆箱，JDK1.5之后支持自动装箱与自动拆箱。</p><p>注意：只能与自己对应的类型之间才能实现自动装箱与拆箱。</p><p>装箱：把基本数据类型转为包装类对象。</p><blockquote><p>转为包装类的对象，是为了使用专门为对象设计的API和特性</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本数据类型就自动的封装到与它相同类型的包装中，如：</span></span><br><span class="line">Integer i = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//本质上是，编译器编译时为我们添加了：</span></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>拆箱：把包装类对象拆为基本数据类型。</p><blockquote><p>转为基本数据类型，一般是因为需要运算，Java中的大多数运算符是为基本数据类型设计的。比较、算术等</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包装类对象自动转换成基本类型数据。如：</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//本质上，编译器编译时为我们添加了：</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="keyword">new</span> Integer(<span class="number">100</span>).intValue();</span><br></pre></td></tr></table></figure><h2 id="包装类的一些API"><a href="#包装类的一些API" class="headerlink" title="包装类的一些API"></a>包装类的一些API</h2><p>1、基本数据类型和字符串之间的转换</p><p>（1）把基本数据类型转为字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//String str = a;//错误的</span></span><br><span class="line"><span class="comment">//方式一：</span></span><br><span class="line">String str = a + <span class="string">""</span>;</span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line">String str = String.valueOf(a);</span><br></pre></td></tr></table></figure><p>（2）把字符串转为基本数据类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = Integer.parseInt(<span class="string">"整数的字符串"</span>);</span><br><span class="line"><span class="keyword">double</span> a = Double.parseDouble(<span class="string">"小数的字符串"</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = Boolean.parseBoolean(<span class="string">"true或false"</span>);</span><br></pre></td></tr></table></figure><p>2、数据类型的最大最小值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.MAX_VALUE和Integer.MIN_VALUE</span><br><span class="line">Long.MAX_VALUE和Long.MIN_VALUE</span><br><span class="line">Double.MAX_VALUE和Double.MIN_VALUE</span><br></pre></td></tr></table></figure><p>3、转大小写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Character.toUpperCase(<span class="string">'x'</span>);</span><br><span class="line">Character.toLowerCase(<span class="string">'X'</span>);</span><br></pre></td></tr></table></figure><p>4、转进制</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.toBinaryString(<span class="keyword">int</span> i) </span><br><span class="line">Integer.toHexString(<span class="keyword">int</span> i)</span><br><span class="line">Integer.toOctalString(<span class="keyword">int</span> i)</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="包装类对象的缓存问题"><a href="#包装类对象的缓存问题" class="headerlink" title="包装类对象的缓存问题"></a>包装类对象的缓存问题</h2><table><thead><tr><th>包装类</th><th>缓存对象</th></tr></thead><tbody><tr><td>Byte</td><td>-128~127</td></tr><tr><td>Short</td><td>-128~127</td></tr><tr><td>Integer</td><td>-128~127</td></tr><tr><td>Long</td><td>-128~127</td></tr><tr><td>Float</td><td>没有</td></tr><tr><td>Double</td><td>没有</td></tr><tr><td>Character</td><td>0~127</td></tr><tr><td>Boolean</td><td>true和false</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>;</span><br><span class="line">Integer j = <span class="number">1</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="number">128</span>;</span><br><span class="line">Integer j = <span class="number">128</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);<span class="comment">//新new的在堆中</span></span><br><span class="line">Integer j = <span class="number">1</span>;<span class="comment">//这个用的是缓冲的常量对象，在方法区</span></span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);<span class="comment">//新new的在堆中</span></span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);<span class="comment">//另一个新new的在堆中</span></span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//true，凡是和基本数据类型比较，都会先拆箱，按照基本数据类型的规则比较</span></span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h2><p>1、字符串String类型本身是final声明的，意味着我们不能继承String。</p><p>2、字符串的对象也是不可变对象，意味着一旦进行修改，就会产生新对象</p><blockquote><p>我们修改了字符串后，如果想要获得新的内容，必须重新接受。</p><p>如果程序中涉及到大量的字符串的修改操作，那么此时的时空消耗比较高。可能需要考虑使用StringBuilder或StringBuffer。</p></blockquote><p>3、String对象内部是用字符数组进行保存的</p><blockquote><p>JDK1.9之前有一个char[] value数组，JDK1.9之后byte[]数组</p></blockquote><p>4、String类中这个char[] values数组也是final修饰的，意味着这个数组不可变，然后它是private修饰，外部不能直接操作它，String类型提供的所有的方法都是用新对象来表示修改后内容的，所以保证了String对象的不可变。</p><p>5、就因为字符串对象设计为不可变，那么所以字符串有常量池来保存很多常量对象</p><p>常量池在方法区。</p><p>如果细致的划分：</p><p>（1）JDK1.6及其之前：方法区</p><p>（2）JDK1.7：堆，即在堆中单独划分了一块内存</p><p>（3）JDK1.8：元空间（meta space），即类似于方法区</p><h2 id="String对象的创建"><a href="#String对象的创建" class="headerlink" title="String对象的创建"></a>String对象的创建</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = “hello”;</span><br><span class="line">String  s1 = <span class="keyword">new</span> String();   <span class="comment">//  本质上  this.value = new char[0];</span></span><br><span class="line">String  s2 = <span class="keyword">new</span> String(String original);  <span class="comment">//this.value = original.value;</span></span><br><span class="line">String  s3 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a);  <span class="comment">//this.value = Arrays.copyOf(value, value.length);</span></span><br><span class="line">String  s4 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> count)</span><br><span class="line"><span class="comment">//.......</span></span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/string1.png" alt="String"></p><h2 id="字符串对象是如何存储的"><a href="#字符串对象是如何存储的" class="headerlink" title="字符串对象是如何存储的"></a>字符串对象是如何存储的</h2><p>字符串常量存储在字符串常量池，目的是共享</p><p>字符串非常量对象存储在堆中。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/string2.png" alt="String"></p><h2 id="String的拼接"><a href="#String的拼接" class="headerlink" title="String的拼接"></a>String的拼接</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/string3.png" alt="String"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/string4.png" alt="String"></p><p>结论：<br>常量与常量的拼接结果在常量池<br>只要其中有一个是变量，结果就在堆中<br>如果拼接的结果调用intern()方法，就在常量池中</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/string5.png" alt="String"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/string6.png" alt="String"></p><h2 id="字符串对象的比较"><a href="#字符串对象的比较" class="headerlink" title="字符串对象的比较"></a>字符串对象的比较</h2><p>1、==：比较是对象的地址</p><blockquote><p>只有两个字符串变量都是指向字符串的常量对象时，才会返回true</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"hello"</span>;</span><br><span class="line">String str2 = <span class="string">"hello"</span>;</span><br><span class="line">str1 == str2<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>2、equals：比较是对象的内容，因为String类型重写equals，区分大小写</p><p>只要两个字符串的字符内容相同，就会返回true</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">str1.equals(strs) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>3、equalsIgnoreCase：比较的是对象的内容，不区分大小写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"HELLO"</span>);</span><br><span class="line">str1.equalsIgnoreCase(strs) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>4、compareTo：String类型重写了Comparable接口的抽象方法，自然排序，按照字符的Unicode编码值进行比较大小的，严格区分大小写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"hello"</span>;</span><br><span class="line">String str2 = <span class="string">"world"</span>;</span><br><span class="line">str1.compareTo(str2) <span class="comment">//小于0的值</span></span><br></pre></td></tr></table></figure><p>5、compareToIgnoreCase：不区分大小写，其他按照字符的Unicode编码值进行比较大小</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"HELLO"</span>);</span><br><span class="line">str1.compareToIgnoreCase(str2)  <span class="comment">//等于0</span></span><br></pre></td></tr></table></figure><h2 id="空字符串的比较"><a href="#空字符串的比较" class="headerlink" title="空字符串的比较"></a>空字符串的比较</h2><p>1、哪些是空字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">""</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String();</span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>空字符串：长度为0</p><p>2、如何判断某个字符串是否是空字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">""</span>.equals(str))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str!=<span class="keyword">null</span>  &amp;&amp; str.isEmpty())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str!=<span class="keyword">null</span> &amp;&amp; str.equals(<span class="string">""</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str!=<span class="keyword">null</span> &amp;&amp; str.length()==<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="字符串的对象的个数"><a href="#字符串的对象的个数" class="headerlink" title="字符串的对象的个数"></a>字符串的对象的个数</h2><p>1、字符串常量对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"hello"</span>;<span class="comment">//1个，在常量池中</span></span><br></pre></td></tr></table></figure><p>2、字符串的普通对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String();</span><br><span class="line">String str22 = <span class="keyword">new</span> String(<span class="string">""</span>);</span><br><span class="line"><span class="comment">//两个对象，一个是常量池中的空字符串对象，一个是堆中的空字符串对象</span></span><br><span class="line"><span class="comment">//堆中的这个字符串对象char[]的value数组，指向常量池中“hello”的char[]的value</span></span><br></pre></td></tr></table></figure><p>3、字符串的普通对象和常量对象一起</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">//str3首先指向堆中的一个字符串对象，然后堆中字符串的value数组指向常量池中常量对象的value数组</span></span><br></pre></td></tr></table></figure><h2 id="字符串拼接结果"><a href="#字符串拼接结果" class="headerlink" title="字符串拼接结果"></a>字符串拼接结果</h2><p>原则：</p><p>（1）常量+常量：结果是常量池</p><p>（2）常量与变量 或 变量与变量：结果是堆</p><p>（3）拼接后调用intern方法：结果在常量池</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = <span class="string">"helloworld"</span>;</span><br><span class="line"></span><br><span class="line">String s4 = (s1 + <span class="string">"world"</span>).intern();<span class="comment">//把拼接的结果放到常量池中</span></span><br><span class="line">String s5 = (s1 + s2).intern();</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">final</span> String s1 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">final</span> String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = <span class="string">"helloworld"</span>;</span><br><span class="line"></span><br><span class="line">String s4 = s1 + <span class="string">"world"</span>;<span class="comment">//s4字符串内容也helloworld，s1是常量，"world"常量，常量+ 常量 结果在常量池中</span></span><br><span class="line">String s5 = s1 + s2;<span class="comment">//s5字符串内容也helloworld，s1和s2都是常量，常量+ 常量 结果在常量池中</span></span><br><span class="line">String s6 = <span class="string">"hello"</span> + <span class="string">"world"</span>;<span class="comment">//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = <span class="string">"helloworld"</span>;</span><br><span class="line"></span><br><span class="line">String s4 = s1 + <span class="string">"world"</span>;<span class="comment">//s4字符串内容也helloworld，s1是变量，"world"常量，变量 + 常量的结果在堆中</span></span><br><span class="line">String s5 = s1 + s2;<span class="comment">//s5字符串内容也helloworld，s1和s2都是变量，变量 + 变量的结果在堆中</span></span><br><span class="line">String s6 = <span class="string">"hello"</span> + <span class="string">"world"</span>;<span class="comment">//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串的API"><a href="#字符串的API" class="headerlink" title="字符串的API"></a>字符串的API</h2><p><strong>常用方法</strong></p><ul><li>int length()：返回字符串的长度： return value.length;</li><li>boolean isEmpty()：判断是否是空字符串：return value.length == 0;</li><li>String toLowerCase()：使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</li><li>String toUpperCase()：使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</li><li>String trim()：返回字符串的副本，忽略前导空白和尾部空白。</li><li>boolean equals(Object obj)：比较字符串的内容</li><li>boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写</li><li>String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”</li></ul><p><strong>String类和字符相关操作</strong></p><ul><li>char[] toCharArray()：将此字符串转换为一个新的字符数组</li><li>char charAt(int index)： 返回某索引处的字符return value[index];</li><li>String(char[] value)：分配一个新的 String，使其表示字符数组参数中当前包含的字符序列。</li><li>String(char[] value, int offset, int count)：分配一个新的 String，它包含取自字符数组参数一个子数组的字符。</li></ul><p><strong>String类字节与字符串操作方法</strong></p><p>编码：把字符–&gt;字节</p><ul><li>byte[] getBytes()：使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</li><li>byte[] getBytes(Charset charset) ：使用给定的 charset 将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。</li><li>byte[] getBytes(String charsetName) ：使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</li></ul><p>解码：把字节–&gt;字符</p><ul><li>String(byte[] bytes) ：通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。</li><li>String(byte[] bytes, Charset charset)：通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。</li><li>String(byte[] bytes, int offset, int length) ：通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的 String。</li><li>String(byte[] bytes, int offset, int length, Charset charset)：通过使用指定的 charset 解码指定的 byte 子数组，构造一个新的 String。</li><li>String(byte[] bytes, int offset, int length, String charsetName)：通过使用指定的字符集解码指定的 byte 子数组，构造一个新的 String。</li><li>String(byte[] bytes, String charsetName)：通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。</li></ul><p><strong>String类判断是否以指定内容开头或结尾</strong></p><ul><li>boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束。</li><li>boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始。</li><li>boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</li></ul><p><strong>String类字符串查找操作</strong></p><ul><li>boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true。</li><li>int indexOf(int ch)：返回指定字符在此字符串中第一次出现处的索引。 </li><li>int indexOf(int ch, int fromIndex)：返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 </li><li>int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引。 </li><li>int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 </li><li>int lastIndexOf(int ch)：返回指定字符在此字符串中最后一次出现处的索引。 </li><li>int lastIndexOf(int ch, int fromIndex)：返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 </li><li>int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引。 </li><li>int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</li></ul><blockquote><p>indexOf和lastIndexOf方法如果未找到都是返回-1</p></blockquote><p><strong>String类字符串截取操作</strong></p><ul><li>String substring(int beginIndex) ：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。 </li><li>String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</li></ul><p><strong>String类是否匹配正则</strong></p><ul><li>boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。</li></ul><p><strong>String类替换操作</strong></p><ul><li><p>String replace(char oldChar, char newChar)： 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 </p></li><li><p>String replace(CharSequence target, CharSequence replacement)： 使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。 </p></li><li><p>String replaceAll(String regex, String replacement)： 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 </p></li><li><p>String replaceFirst(String regex, String replacement)： 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 </p></li></ul><p><strong>String类字符串拆分操作</strong></p><ul><li><p>String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。 </p></li><li><p>String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</p></li></ul><p>面试题：字符串的length和数组的length有什么不同？</p><p>字符串的length()，数组的length属性</p><h1 id="可变字符序列：字符串缓冲区"><a href="#可变字符序列：字符串缓冲区" class="headerlink" title="可变字符序列：字符串缓冲区"></a>可变字符序列：字符串缓冲区</h1><p>1、可变字符序列：StringBuilder和StringBuffer</p><p>一个类似于 String 的字符串缓冲区，但能被修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容，所有对StringBuffer或StringBuilder对象的字符序列的修改不会产生新的StringBuffer或StringBuilder对象，这点和String很大的不同。</p><p>StringBuffer：老的，线程安全的（因为它的方法有synchronized修饰）</p><p>StringBuilder：线程不安全的</p><p>2、面试题：String和StringBuilder、StringBuffer的区别？</p><p>String：不可变对象，不可变字符序列</p><p>StringBuilder、StringBuffer： 可变字符序列</p><p>3、常用的API，StringBuilder、StringBuffer的API是完全一致的</p><p><strong>构造器</strong></p><p>StringBuffer或StringBuilder对象的创建必须用new+构造器。</p><ul><li><p>StringBuffer()  初始容量为16的字符串缓冲区</p></li><li><p>StringBuffer(int size)  构造指定容量的字符串缓冲区</p></li><li><p>StringBuffer(String str)  将内容初始化为指定字符串内容</p></li></ul><p><strong>常用方法</strong></p><ul><li><p>StringBuffer append(xx)：提供了很多的append()方法，用于进行字符串拼接</p></li><li><p>StringBuffer delete(int start,int end)：删除指定位置的内容</p></li><li><p>StringBuffer insert(int offset, xx)：在指定位置插入xx</p></li><li><p>StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str</p></li><li><p>StringBuffer reverse() ：把当前字符序列逆转</p><p>….</p></li></ul><h1 id="System系统类"><a href="#System系统类" class="headerlink" title="System系统类"></a>System系统类</h1><p>System 类包含一些有用的类字段和方法。它不能被实例化。 </p><p>在 System 类提供的设施中，有标准输入、标准输出和错误输出流；对外部定义的属性和环境变量的访问；加载文件和库的方法；还有快速复制数组的一部分的实用方法。</p><h2 id="标准输入、标准输出和错误输出流对象"><a href="#标准输入、标准输出和错误输出流对象" class="headerlink" title="标准输入、标准输出和错误输出流对象"></a>标准输入、标准输出和错误输出流对象</h2><p>PrintStream err：“标准”错误输出流。 </p><p>InputStream in：“标准”输入流。 </p><p>PrintStream out：“标准”输出流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSystem</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.print(<span class="string">"请输入成绩："</span>);</span><br><span class="line"><span class="keyword">int</span> score = input.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(score&gt;=<span class="number">0</span> &amp;&amp; score&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"成绩是："</span> + score);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.err.println(<span class="string">"输入有误，成绩应该在[0,100]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li><p>void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) ：从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。</p></li><li><p>long currentTimeMillis() ：返回以毫秒为单位的当前时间。</p></li><li><p>void exit(int status) ：终止当前正在运行的 Java 虚拟机。</p></li><li><p>void gc()：运行垃圾回收器。</p></li><li><p>Properties getProperties()：确定当前的系统属性。</p></li><li><p>String getProperty(String key)：获取指定键指示的系统属性。</p></li><li><p>void setErr(PrintStream err) ：重新分配“标准”错误输出流。</p></li><li><p>void setIn(InputStream in)：重新分配“标准”输入流。</p></li><li><p>void setOut(PrintStream out)：重新分配“标准”输出流。</p></li><li><p>String setProperty(String key, String value) ：设置指定键指示的系统属性。</p></li></ul><h1 id="数学相关类"><a href="#数学相关类" class="headerlink" title="数学相关类"></a>数学相关类</h1><h2 id="java-lang-Math类"><a href="#java-lang-Math类" class="headerlink" title="java.lang.Math类"></a>java.lang.Math类</h2><p>java.lang.Math提供了一系列静态方法用于科学计算；其方法的参数和返回值类型一般为double型。</p><ul><li><p>abs()   绝对值</p></li><li><p>acos,asin,atan,cos,sin,tan  三角函数</p></li><li><p>sqrt()  平方根</p></li><li><p>pow(double a,doble b)   a的b次幂</p></li><li><p>log()   自然对数</p></li><li><p>exp   e为底指数</p></li><li><p>max(x,y)  找x,y最大值</p></li><li><p>min(x,y)  找x,y找最小值</p></li><li><p>random()    返回0.0到1.0的随机数</p></li><li><p>long round(double a)   double型数据a转换为long型（四舍五入）</p></li><li><p>toDegrees(double angrad)   弧度—&gt;角度</p></li><li><p>toRadians(double angdeg)   角度—&gt;弧度</p></li><li><p>random()  返回[0,1)范围的小数</p></li><li><p>round(x)：四舍五入</p></li><li><p>ceil(x)：进一法/上取整</p></li><li><p>floor(x)：退一法/下取整</p><p>…..</p></li></ul><h2 id="java-math包"><a href="#java-math包" class="headerlink" title="java.math包"></a>java.math包</h2><h3 id="BigInteger-大整数"><a href="#BigInteger-大整数" class="headerlink" title="BigInteger 大整数"></a>BigInteger 大整数</h3><p>Integer类作为int的包装类，能存储的最大整型值为231-1，Long类也是有限的，最大为263-1如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。</p><p>java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。</p><p><strong>构造方法</strong></p><ul><li>BigInteger(String val)：根据字符串构建BigInteger对象</li></ul><p><strong>常用方法</strong></p><ul><li>BigInteger add(BigInteger val) ：返回其值为 (this + val) 的 BigInteger。</li><li>BigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigInteger。</li><li>BigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigInteger。</li><li>BigInteger divide(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数相除只保留整数部分。</li><li>BigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。</li><li>BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (this / val) 后跟 (this % val) 的两个 BigInteger 的数组。</li><li>BigInteger pow(int exponent) ：返回其值为 (this^exponent) 的 BigInteger。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//long num1 = 12345678901234567890L;//out of range 超过long的范围</span></span><br><span class="line">BigInteger num1 = <span class="keyword">new</span> BigInteger(<span class="string">"12345678901234567890"</span>);</span><br><span class="line">BigInteger num2 = <span class="keyword">new</span> BigInteger(<span class="string">"92345678901234567890"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println("和：" + (num1 + num2));//错误的</span></span><br><span class="line">System.out.println(<span class="string">"和："</span> + num1.add(num2));</span><br><span class="line">System.out.println(<span class="string">"减："</span> + num1.subtract(num2));</span><br><span class="line">System.out.println(<span class="string">"乘："</span> + num1.multiply(num2));</span><br><span class="line">System.out.println(<span class="string">"除："</span> + num2.divide(num1));<span class="comment">//两个整数相除只保留整数部分</span></span><br><span class="line">System.out.println(<span class="string">"幂次方："</span> + num2.pow(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BigDecimal-大小数"><a href="#BigDecimal-大小数" class="headerlink" title="BigDecimal 大小数"></a>BigDecimal 大小数</h3><p>一般的Float类和Double类可以用来做科学计算或工程计算，但是在商业计算中，要求数字精度比较高，所以用到java.math.BigDecimal类。BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p><p><strong>构造器</strong></p><ul><li>BigDecimal(double val)</li><li>BigDecimal(String val)</li></ul><p><strong>常用方法</strong></p><ul><li>BigDecimal add(BigDecimal augend) :返回一个 BigDecimal，其值为 (this + augend)，其标度为 max(this.scale(), augend.scale())。</li><li>BigDecimal subtract(BigDecimal subtrahend) ：返回一个 BigDecimal，其值为 (this - subtrahend)，其标度为 max(this.scale(), subtrahend.scale())。</li><li>BigDecimal multiply(BigDecimal multiplicand)：返回一个 BigDecimal，其值为 (this × multiplicand)，其标度为 (this.scale() + multiplicand.scale())。</li><li>BigDecimal pow(int n) ：返回其值为 (thisn) 的 BigDecimal，准确计算该幂，使其具有无限精度。</li><li>BigDecimal divide(BigDecimal divisor)： 返回一个 BigDecimal，其值为 (this / divisor)，其首选标度为 (this.scale() - divisor.scale())；如果无法表示准确的商值（因为它有无穷的十进制扩展），则抛出 ArithmeticException。</li><li>BigDecimal divide(BigDecimal divisor, int roundingMode) ：返回一个 BigDecimal，其值为 (this / divisor)，其标度为 this.scale()。</li><li>BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) ：返回一个 BigDecimal，其值为 (this / divisor)，其标度为指定标度。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">BigDecimal num1 = <span class="keyword">new</span> BigDecimal(<span class="string">"-12.1234567890123456567899554544444332"</span>);</span><br><span class="line">BigDecimal num2 = <span class="keyword">new</span> BigDecimal(<span class="string">"89.6734567890123456567899554544444333"</span>);</span><br><span class="line">System.out.println(<span class="string">"和："</span> + num1.add(num2));</span><br><span class="line">System.out.println(<span class="string">"减："</span> + num1.subtract(num2));</span><br><span class="line">System.out.println(<span class="string">"乘："</span> + num1.multiply(num2));</span><br><span class="line">System.out.println(<span class="string">"除："</span> + num2.divide(<span class="keyword">new</span> BigDecimal(<span class="string">"2"</span>)));<span class="comment">//可以整除（除尽）就对，不能整除就报异常</span></span><br><span class="line">System.out.println(<span class="string">"除："</span> + num2.divide(num1,BigDecimal.ROUND_HALF_UP));</span><br><span class="line">System.out.println(<span class="string">"除："</span> + num2.divide(num1,BigDecimal.ROUND_DOWN));<span class="comment">//往零的方向舍去</span></span><br><span class="line">System.out.println(<span class="string">"除："</span> + num2.divide(num1,BigDecimal.ROUND_FLOOR));<span class="comment">//往小的方向舍去</span></span><br><span class="line">System.out.println(<span class="string">"除："</span> + num2.divide(num1,BigDecimal.ROUND_CEILING));<span class="comment">//往大的方向舍去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="日期时间API"><a href="#日期时间API" class="headerlink" title="日期时间API"></a>日期时间API</h1><h2 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h2><h3 id="java-lang-System"><a href="#java-lang-System" class="headerlink" title="java.lang.System"></a>java.lang.System</h3><p>System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒GMT之间以毫秒为单位的时间差。此方法适于计算时间差。</p><h3 id="java-util-Date"><a href="#java-util-Date" class="headerlink" title="java.util.Date"></a>java.util.Date</h3><p>它的对象表示一个特定的瞬间，精确到毫秒。</p><p>Java中时间的表示说白了也是数字，是从标准纪元1970年1月1日0时0分0秒GMT到某个时刻的毫秒数，类型是long</p><p>理解：一维的时间轴，选择1970年1月1日0时0分0秒时间为0刻度，1毫秒一刻度</p><p><strong>构造方法：</strong></p><ul><li>Date()：    源代码：this(System.currentTimeMillis());</li><li>Date(long date)</li></ul><p><strong>常用方法：</strong></p><ul><li><p>getTime():返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</p></li><li><p>toString():把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)， zzz是时间标准。</p></li></ul><p><strong>已过时的方法：</strong></p><ul><li><p>public Date(int year,int month,int date,int hrs,int min,int sec)</p><p>参数：</p><p>​    year - 减 1900 的年份。</p><p>​    month - 0-11 之间的月份。</p><p>​    date - 一月中 1-31 之间的某一天。</p><p>​    hrs - 0-23 之间的小时数。</p><p>​    min - 0-59 之间的分钟数。</p><p>​    sec - 0-59 之间的秒数。</p></li><li><p>getYear() 从 JDK 1.1 开始，由 Calendar.get(Calendar.YEAR) - 1900 取代。</p></li><li><p>getMonth()从 JDK 1.1 开始，由 Calendar.get(Calendar.MONTH) 取代。返回的值在 0 和 11 之间，值 0 表示 1 月。 </p></li><li><p>getDate() JDK 1.1 开始，由 Calendar.get(Calendar.DAY_OF_MONTH) 取代。返回的值在 1 和 31 之间</p></li><li><p>getDay()从 JDK 1.1 开始，由 Calendar.get(Calendar.DAY_OF_WEEK) 取代。 返回值 (0 = Sunday, 1 = Monday, 2 = Tuesday, 3 = Wednesday, 4 = Thursday, 5 = Friday, 6 = Saturday) 表示一周中的某一天</p></li><li><p>getHours()从 JDK 1.1 开始，由 Calendar.get(Calendar.HOUR_OF_DAY) 取代。返回值是一个数字（0 至 23）</p></li><li><p>getMinutes()从 JDK 1.1 开始，由 Calendar.get(Calendar.MINUTE) 取代。 返回值在 0 和 59 之间。 </p></li><li><p>getSeconds()从 JDK 1.1 开始，由 Calendar.get(Calendar.SECOND) 取代。回的值在 0 和 61 之间。值 60 和 61 只可能发生在考虑了闰秒的 Java 虚拟机上。</p></li></ul><h3 id="java-util-TimeZone和Locale"><a href="#java-util-TimeZone和Locale" class="headerlink" title="java.util.TimeZone和Locale"></a>java.util.TimeZone和Locale</h3><p>Locale 对象表示了特定的地理、政治和文化地区。需要 Locale 来执行其任务的操作称为语言环境敏感的 操作，它使用 Locale 为用户量身定制信息。例如，显示一个数值，日期就是语言环境敏感的操作，应该根据用户的国家、地区或文化的风俗/传统来格式化该数值。</p><p><strong>获取Locale对象：</strong></p><ul><li><p>Locale(String language)</p></li><li><p>Locale(String language, String country)</p></li><li><p>Locale.CHINA、Locale.US等</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Locale loc = Locale.CHINA;</span><br><span class="line">System.out.println(loc);<span class="comment">//zh_CN</span></span><br><span class="line">System.out.println(Locale.US);<span class="comment">//en_US</span></span><br><span class="line">System.out.println(Locale.JAPAN);<span class="comment">//ja_JP</span></span><br><span class="line"></span><br><span class="line">Locale c = <span class="keyword">new</span> Locale(<span class="string">"zh"</span>,<span class="string">"CN"</span>);</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常，使用 TimeZone的getDefault 获取 TimeZone，getDefault 基于程序运行所在的时区创建 TimeZone。例如，对于在日本运行的程序，getDefault 基于日本标准时间创建 TimeZone 对象。 </p><p>也可以用TimeZone的 getTimeZone 及时区 ID 获取 TimeZone 。例如美国太平洋时区的时区 ID 是 “America/Los_Angeles”。因此，可以使用下面语句获得美国太平洋时间 TimeZone 对象：</p><p>TimeZone tz = TimeZone.getTimeZone(“America/Los_Angeles”);</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">TimeZone t = TimeZone.getDefault();</span><br><span class="line">System.out.println(t);</span><br><span class="line"></span><br><span class="line">TimeZone t1 = TimeZone.getTimeZone(<span class="string">"America/New_York"</span>);</span><br><span class="line">System.out.println(t1);</span><br><span class="line"></span><br><span class="line">TimeZone t2 = TimeZone.getTimeZone(<span class="string">"Asia/Shanghai"</span>);</span><br><span class="line">System.out.println(t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String[] all = TimeZone.getAvailableIDs();</span><br><span class="line"><span class="keyword">for</span> (String id : all) &#123;</span><br><span class="line">  System.out.println(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-util-Calendar"><a href="#java-util-Calendar" class="headerlink" title="java.util.Calendar"></a>java.util.Calendar</h3><p>Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。瞬间可用毫秒值来表示，它是距历元（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00.000，格里高利历）的偏移量。 </p><p>人们对于时间的认识是：某年某月某日，这样的日期概念。计算机是long类型的数字。通过Calendar在二者之间搭起桥梁。而且Calendar提供了很多关于日期时间计算的方法。</p><p>GregorianCalendar（公历）是Calendar的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。</p><p><strong>注意：</strong></p><p>月份：一月是0，二月是1，以此类推，12月是11</p><p>星期：周日是1，周二是2,。。。。周六是7</p><p>public static Calendar getInstance()使用默认时区和语言环境获得一个日历。返回的 Calendar 基于当前时间，使用了默认时区和默认语言环境。 </p><p>public static Calendar getInstance(TimeZone zone, Locale aLocale)使用指定时区和语言环境获得一个日历。返回的 Calendar 基于当前时间，使用了给定的时区和给定的语言环境。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">System.out.println(c);</span><br><span class="line"></span><br><span class="line">Calendar c2 = Calendar.getInstance(TimeZone.getTimeZone(<span class="string">"Asia/Shanghai"</span>), Locale.CHINA);</span><br><span class="line">System.out.println(c2);</span><br><span class="line"></span><br><span class="line">Calendar c3 = Calendar.getInstance(TimeZone.getTimeZone(<span class="string">"America/New_York"</span>), Locale.US);</span><br><span class="line">System.out.println(c3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-text-DateFormat和SimpleDateFormat"><a href="#java-text-DateFormat和SimpleDateFormat" class="headerlink" title="java.text.DateFormat和SimpleDateFormat"></a>java.text.DateFormat和SimpleDateFormat</h3><p>完成字符串和时间对象的转化：</p><ul><li><p>String format(date)</p></li><li><p>Date parse(string)</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss 是本年的第几D"</span>);</span><br><span class="line">System.out.println(sf.format(date));</span><br><span class="line"></span><br><span class="line">String s = <span class="string">"2016-12-01 14:12:23"</span>;</span><br><span class="line">SimpleDateFormat sf2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Date d = sf2.parse(s);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/date.png" alt="date"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">String str = <span class="string">"2019年06月06日 16时03分14秒 545毫秒  星期四 +0800"</span>;</span><br><span class="line">SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒  E Z"</span>);</span><br><span class="line">Date d = sf.parse(str);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span>&#123;</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒  E Z"</span>);</span><br><span class="line"><span class="comment">//把Date日期转成字符串，按照指定的格式转</span></span><br><span class="line">String str = sf.format(d);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">String[] all = TimeZone.getAvailableIDs();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all.length; i++) &#123;</span><br><span class="line">System.out.println(all[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">TimeZone t = TimeZone.getTimeZone(<span class="string">"America/Los_Angeles"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//getInstance(TimeZone zone)</span></span><br><span class="line">Calendar c = Calendar.getInstance(t);</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">System.out.println(c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">System.out.println(year);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> month = c.get(Calendar.MONTH)+<span class="number">1</span>;</span><br><span class="line">System.out.println(month);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> time = Long.MAX_VALUE;</span><br><span class="line">Date d = <span class="keyword">new</span> Date(time);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> time = <span class="number">1559807047979L</span>;</span><br><span class="line">Date d = <span class="keyword">new</span> Date(time);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="keyword">long</span> time = d.getTime();</span><br><span class="line">System.out.println(time);<span class="comment">//1559807047979</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">System.out.println(time);<span class="comment">//1559806982971</span></span><br><span class="line"><span class="comment">//当前系统时间距离1970-1-1 0:0:0 0毫秒的时间差，毫秒为单位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h2><p>Java1.0中包含了一个Date类，但是它的大多数方法已经在Java 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是：</p><ul><li><p>可变性：象日期和时间这样的类对象应该是不可变的。Calendar类中可以使用三种方法更改日历字段：set()、add() 和 roll()。</p></li><li><p>偏移性：Date中的年份是从1900开始的，而月份都是从0开始的。</p></li><li><p>格式化：格式化只对Date有用，Calendar则不行。</p></li></ul><p>此外，它们也不是线程安全的，不能处理闰秒等。</p><p>Date的API：</p><p>尽管 Date 类打算反映协调世界时 (UTC)，但无法做到如此准确，这取决于 Java 虚拟机的主机环境。当前几乎所有操作系统都假定 1 天 = 24 × 60 × 60 = 86400 秒。但对于 UTC，大约每一两年出现一次额外的一秒，称为“闰秒”。闰秒始终作为当天的最后一秒增加，并且始终在 12 月 31 日或 6 月 30 日增加。例如，1995 年的最后一分钟是 61 秒，因为增加了闰秒。大多数计算机时钟不是特别的准确，因此不能反映闰秒的差别。</p><p>在类 Date 所有可以接受或返回年、月、日期、小时、分钟和秒值的方法中，将使用下面的表示形式： </p><ul><li><p>年份 y 由整数 y - 1900 表示。 </p></li><li><p>月份由从 0 至 11 的整数表示；0 是一月、1 是二月等等；因此 11 是十二月。 </p></li><li><p>日期（一月中的某天）按通常方式由整数 1 至 31 表示。 </p></li><li><p>小时由从 0 至 23 的整数表示。因此，从午夜到 1 a.m. 的时间是 0 点，从中午到 1 p.m. 的时间是 12 点。 </p></li><li><p>分钟按通常方式由 0 至 59 的整数表示。 </p></li><li><p>秒由 0 至 61 的整数表示；值 60 和 61 只对闰秒发生，尽管那样，也只用在实际正确跟踪闰秒的 Java 实现中。于按当前引入闰秒的方式，两个闰秒在同一分钟内发生是极不可能的，但此规范遵循 ISO C 的日期和时间约定。 </p></li></ul><p>在所有情形中，针对这些目的赋予方法的参数不需要在指定的范围内；例如，可以把日期指定为 1 月 32 日，并把它解释为 2 月 1 日的相同含义。</p><p>​        Date date = new Date(2017-1900,8-1,28);</p><p>​        System.out.println(date);//Mon Aug 28 00:00:00 CST 2017</p><p>可以说，对日期和时间的操作一直是Java程序员最痛苦的地方之一。第三次引入的API是成功的，并且java 8中引入的java.time API 已经纠正了过去的缺陷，将来很长一段时间内它都会为我们服务。</p><p>Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。</p><ul><li><p>java.time – 包含值对象的基础包</p></li><li><p>java.time.chrono – 提供对不同的日历系统的访问。</p></li><li><p>java.time.format – 格式化和解析时间和日期</p></li><li><p>java.time.temporal – 包括底层框架和扩展特性</p></li><li><p>java.time.zone – 包含时区支持的类</p></li></ul><p>Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。新的 java.time 中包含了所有关于时钟（Clock），本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了了日期时间和本地化的管理。</p><p>说明：大多数开发者只会用到基础包和format包，也可能会用到temporal包。因此，尽管有68个新的公开类型，大多数开发者，大概将只会用到其中的很少一部分。</p><p><strong>java.time</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/time.png" alt="time"></p><blockquote><p>注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是公历。</p></blockquote><p><strong>java.time.chrono</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/time2.png" alt="time"></p><h3 id="java-time"><a href="#java-time" class="headerlink" title="java.time"></a>java.time</h3><p>本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）</p><p>LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储“生日、纪念日”等日期。</p><p>LocalTime表示一个时间，而不是日期</p><p>LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。</p><p>（1）now()：获取系统日期或时间</p><p>（2）of(xxx)：或者指定的日期或时间</p><p>（3）运算：运算后得到新对象，需要重新接受</p><p>plusXxx()：在当前日期或时间对象上加xx</p><p>minusXxx() ：在当前日期或时间对象上减xx</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>now() / now(ZoneId zone)</td><td>静态方法，根据当前时间创建对象/指定时区的对象</td></tr><tr><td>of()</td><td>静态方法，根据指定日期/时间创建对象</td></tr><tr><td>getDayOfMonth()/getDayOfYear()</td><td>获得月份天数(1-31) /获得年份天数(1-366)</td></tr><tr><td>getDayOfWeek()</td><td>获得星期几(返回一个 DayOfWeek 枚举值)</td></tr><tr><td>getMonth()</td><td>获得月份, 返回一个 Month 枚举值</td></tr><tr><td>getMonthValue() / getYear()</td><td>获得月份(1-12) /获得年份</td></tr><tr><td>getHours()/getMinute()/getSecond()</td><td>获得当前对象对应的小时、分钟、秒</td></tr><tr><td>withDayOfMonth()/withDayOfYear()/withMonth()/withYear()</td><td>将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</td></tr><tr><td>with(TemporalAdjuster t)</td><td>将当前日期时间设置为校对器指定的日期时间</td></tr><tr><td>plusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours()</td><td>向当前对象添加几天、几周、几个月、几年、几小时</td></tr><tr><td>minusMonths() / minusWeeks()/minusDays()/minusYears()/minusHours()</td><td>从当前对象减去几月、几周、几天、几年、几小时</td></tr><tr><td>plus(TemporalAmount t)/minus(TemporalAmount t)</td><td>添加或减少一个 Duration 或 Period</td></tr><tr><td>isBefore()/isAfter()</td><td>比较两个 LocalDate</td></tr><tr><td>isLeapYear()</td><td>判断是否是闰年（在LocalDate类中声明）</td></tr><tr><td>format(DateTimeFormatter t)</td><td>格式化本地日期、时间，返回一个字符串</td></tr><tr><td>parse(Charsequence text)</td><td>将指定格式的字符串解析为日期、时间</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//now()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLocalDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">  LocalDate date = LocalDate.now();</span><br><span class="line">  LocalTime time = LocalTime.now();</span><br><span class="line">  LocalDateTime datetime = LocalDateTime.now();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//of()或parse</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLocalDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// LocalDate date = LocalDate.now();</span></span><br><span class="line">  <span class="comment">// LocalDate date = LocalDate.of(2017, 3, 20);</span></span><br><span class="line">  LocalDate date = LocalDate.parse(<span class="string">"2017-03-12"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  LocalDateTime t = LocalDateTime.now();</span><br><span class="line">  System.out.println(<span class="string">"这一天是这一年的第几天："</span>+t.getDayOfYear());</span><br><span class="line">  System.out.println(<span class="string">"年："</span>+t.getYear());</span><br><span class="line">  System.out.println(<span class="string">"月："</span>+t.getMonth());</span><br><span class="line">  System.out.println(<span class="string">"月份值："</span>+t.getMonthValue());</span><br><span class="line">  System.out.println(<span class="string">"日："</span>+t.getDayOfMonth());</span><br><span class="line">  System.out.println(<span class="string">"星期："</span>+t.getDayOfWeek());</span><br><span class="line">  System.out.println(<span class="string">"时："</span>+t.getHour());</span><br><span class="line">  System.out.println(<span class="string">"分："</span>+t.getMinute());</span><br><span class="line">  System.out.println(<span class="string">"秒："</span>+t.getSecond());</span><br><span class="line">  System.out.println(t.getMonthValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLocalDate2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LocalDate date = LocalDate.now();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//withXxx()方法，不改变原来的date对象，返回一个新的对象，不可变性</span></span><br><span class="line">  <span class="comment">// LocalDate date2 = date.withDayOfMonth(1);//获取这个月的第一天</span></span><br><span class="line">  LocalDate date2 = date.with(TemporalAdjusters.firstDayOfMonth());<span class="comment">// 获取这个月的第一天</span></span><br><span class="line">  System.out.println(date2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取这个月的最后一天</span></span><br><span class="line">  LocalDate date3 = date.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">  System.out.println(date3);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//45天后的日期</span></span><br><span class="line">  LocalDate date4 = date.plusDays(<span class="number">45</span>);</span><br><span class="line">  System.out.println(date4);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//20天前的日期</span></span><br><span class="line">  LocalDate date5 = date.minusDays(<span class="number">20</span>);</span><br><span class="line">  System.out.println(date5);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> before = date.isBefore(date5);</span><br><span class="line">  System.out.println(date+<span class="string">"是否比"</span>+date5+<span class="string">"早"</span> + before);</span><br><span class="line"></span><br><span class="line">  System.out.println(date+<span class="string">"是否是闰年："</span>+date.isLeapYear());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MonthDay month = MonthDay.of(<span class="number">8</span>, <span class="number">14</span>);</span><br><span class="line">MonthDay today = MonthDay.from(date);</span><br><span class="line">System.out.println(<span class="string">"今天是否是生日："</span> + month.equals(today));</span><br></pre></td></tr></table></figure><h3 id="瞬时：Instant"><a href="#瞬时：Instant" class="headerlink" title="瞬时：Instant"></a>瞬时：Instant</h3><p>Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。</p><p>在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位。</p><p>java.time包通过值类型Instant提供机器视图。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/time3.png" alt="time"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/time4.png" alt="time"></p><p>时间戳：指格林威治时间1970年01月01日00时00分00秒（北京时间1970年01月01日08时00分00秒）起至现在的总秒数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Instant t = Instant.now();</span><br><span class="line">System.out.println(t);</span><br><span class="line"></span><br><span class="line"><span class="comment">//偏移8个小时</span></span><br><span class="line">OffsetDateTime atOffset = t.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">System.out.println(atOffset);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> milli = t.toEpochMilli();</span><br><span class="line">System.out.println(milli);</span><br><span class="line"></span><br><span class="line">Instant in2 = Instant.ofEpochSecond(<span class="number">10000000</span>);</span><br><span class="line">System.out.println(in2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带时区的日期、时间的处理"><a href="#带时区的日期、时间的处理" class="headerlink" title="带时区的日期、时间的处理"></a>带时区的日期、时间的处理</h3><p>作为一个开发者，如果不用去处理时区和它带来的复杂性，那是幸运的。java.time包下的LocalDate、LocalTime、LocalDateTime和Instant基本能满足需求。当你不可避免时区时，ZonedDateTime等类可以满足我们的需求。</p><p>ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12-03T10:15:30+01:00 Europe/Paris。</p><ul><li><p>其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如：Asia/Shanghai等</p></li><li><p>now()：使用系统时间获取当前的ZonedDateTime</p></li><li><p>now(ZoneId)：返回指定时区的ZonedDateTime</p></li></ul><p>ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris</p><ul><li><p>getAvailableZoneIds()：静态方法，可以获取所有时区信息</p></li><li><p>of(String id)：静态方法，用指定的时区信息获取ZoneId对象</p></li></ul><p>Clock：使用时区提供对当前即时、日期和时间的访问的时钟。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line">  <span class="keyword">for</span> (String string : availableZoneIds) &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ZonedDateTime t = ZonedDateTime.now();</span><br><span class="line">  System.out.println(t);</span><br><span class="line"></span><br><span class="line">  ZonedDateTime t1 = ZonedDateTime.now(ZoneId.of(<span class="string">"America/New_York"</span>));</span><br><span class="line">  System.out.println(t1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Clock clock = Clock.systemDefaultZone();</span></span><br><span class="line">  Clock c = Clock.system(ZoneId.of(<span class="string">"America/New_York"</span>));</span><br><span class="line">  System.out.println(c.getZone());</span><br><span class="line">  System.out.println(c.instant());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="持续时间：Duration"><a href="#持续时间：Duration" class="headerlink" title="持续时间：Duration"></a>持续时间：Duration</h3><p>Duration:用于计算两个“时间”间隔</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  LocalDateTime t1 = LocalDateTime.now();</span><br><span class="line">  LocalDateTime t2 = LocalDateTime.of(<span class="number">2017</span>, <span class="number">8</span>, <span class="number">29</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  Duration between = Duration.between(t1, t2);</span><br><span class="line">  System.out.println(between);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"相差的总天数："</span>+between.toDays());</span><br><span class="line">  System.out.println(<span class="string">"相差的总小时数："</span>+between.toHours());</span><br><span class="line">  System.out.println(<span class="string">"相差的总分钟数："</span>+between.toMinutes());</span><br><span class="line">  System.out.println(<span class="string">"相差的总秒数："</span>+between.getSeconds());</span><br><span class="line">  System.out.println(<span class="string">"相差的总毫秒数："</span>+between.toMillis());</span><br><span class="line">  System.out.println(<span class="string">"相差的总纳秒数："</span>+between.toNanos());</span><br><span class="line">  System.out.println(<span class="string">"不够一秒的纳秒数："</span>+between.getNano());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="日期间隔：Period"><a href="#日期间隔：Period" class="headerlink" title="日期间隔：Period"></a>日期间隔：Period</h3><p>Period:用于计算两个“日期”间隔</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  LocalDate t1 = LocalDate.now();</span><br><span class="line">  LocalDate t2 = LocalDate.of(<span class="number">2018</span>, <span class="number">12</span>, <span class="number">31</span>);</span><br><span class="line">  Period between = Period.between(t1, t2);</span><br><span class="line">  System.out.println(between);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"相差的年数："</span>+between.getYears());<span class="comment">//1年</span></span><br><span class="line">  System.out.println(<span class="string">"相差的月数："</span>+between.getMonths());<span class="comment">//又7个月</span></span><br><span class="line">  System.out.println(<span class="string">"相差的天数："</span>+between.getDays());<span class="comment">//零25天</span></span><br><span class="line">  System.out.println(<span class="string">"相差的总数："</span>+between.toTotalMonths());<span class="comment">//总共19个月</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-time-temporal-TemporalAdjuster-时间校正器"><a href="#java-time-temporal-TemporalAdjuster-时间校正器" class="headerlink" title="java.time.temporal .TemporalAdjuster : 时间校正器"></a>java.time.temporal .TemporalAdjuster : 时间校正器</h3><p>TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。</p><p>TemporalAdjusters : 该类通过静态方法(firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用 TemporalAdjuster 的实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  LocalDate now = LocalDate.now();</span><br><span class="line">  System.out.println(<span class="string">"下一个周日:"</span>+now.with(TemporalAdjusters.next(DayOfWeek.SUNDAY)));</span><br><span class="line">  System.out.println(<span class="string">"下周五"</span> + now.with(TemporalAdjusters.next(DayOfWeek.FRIDAY)));</span><br><span class="line">  System.out.println(<span class="string">"本月最后一天:"</span>+now.with(TemporalAdjusters.lastDayOfMonth()));<span class="comment">//2017-08-31</span></span><br><span class="line">  LocalDate week = LocalDate.now().with(<span class="keyword">new</span> TemporalAdjuster()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Temporal <span class="title">adjustInto</span><span class="params">(Temporal temporal)</span> </span>&#123;</span><br><span class="line">      LocalDate date = (LocalDate) temporal;</span><br><span class="line">      <span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.MONDAY))&#123;</span><br><span class="line">        <span class="keyword">return</span> date.plusDays(<span class="number">7</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.TUESDAY))&#123;</span><br><span class="line">        <span class="keyword">return</span> date.plusDays(<span class="number">6</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.WEDNESDAY))&#123;</span><br><span class="line">        <span class="keyword">return</span> date.plusDays(<span class="number">5</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.THURSDAY))&#123;</span><br><span class="line">        <span class="keyword">return</span> date.plusDays(<span class="number">4</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.FRIDAY))&#123;</span><br><span class="line">        <span class="keyword">return</span> date.plusDays(<span class="number">3</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.SATURDAY))&#123;</span><br><span class="line">        <span class="keyword">return</span> date.plusDays(<span class="number">2</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date.plusDays(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  System.out.println(<span class="string">"下一个工作日："</span> + week);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-time-format-DateTimeFormatter"><a href="#java-time-format-DateTimeFormatter" class="headerlink" title="java.time.format.DateTimeFormatter"></a>java.time.format.DateTimeFormatter</h3><p>该类提供了三种格式化方法：</p><p>预定义的标准格式。如：ISO_DATE_TIME;ISO_DATE</p><p>本地化相关的格式。如：ofLocalizedDate(FormatStyle.MEDIUM)</p><p>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test12</span><span class="params">()</span></span>&#123;</span><br><span class="line">  LocalDateTime now = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">  DateTimeFormatter df = DateTimeFormatter.ofPattern(<span class="string">"yyyy年MM月dd日 HH时mm分ss秒  SSS毫秒  E 是这一年的D天"</span>);</span><br><span class="line">  String string = df.format(now);</span><br><span class="line">  System.out.println(string);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//预定义模式</span></span><br><span class="line">  DateTimeFormatter df2 = DateTimeFormatter.ISO_DATE_TIME;</span><br><span class="line">  System.out.println(df2.format(now));</span><br><span class="line"></span><br><span class="line">  DateTimeFormatter df3 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line">  System.out.println(df3.format(now));</span><br><span class="line"></span><br><span class="line">  DateTimeFormatter df4 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);</span><br><span class="line">  System.out.println(df4.format(now));</span><br><span class="line"></span><br><span class="line">  DateTimeFormatter df5 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM);</span><br><span class="line">  System.out.println(df5.format(now));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与传统日期处理的转换"><a href="#与传统日期处理的转换" class="headerlink" title="与传统日期处理的转换"></a>与传统日期处理的转换</h3><table><thead><tr><th>类</th><th>To 遗留类</th><th>From 遗留类</th></tr></thead><tbody><tr><td>java.time.Instant与java.util.Date</td><td>Date.from(instant)</td><td>date.toInstant()</td></tr><tr><td>java.time.Instant与java.sql.Timestamp</td><td>Timestamp.from(instant)</td><td>timestamp.toInstant()</td></tr><tr><td>java.time.ZonedDateTime与java.util.GregorianCalendar</td><td>GregorianCalendar.from(zonedDateTime)</td><td>cal.toZonedDateTime()</td></tr><tr><td>java.time.LocalDate与java.sql.Time</td><td>Date.valueOf(localDate)</td><td>date.toLocalDate()</td></tr><tr><td>java.time.LocalTime与java.sql.Time</td><td>Date.valueOf(localDate)</td><td>date.toLocalTime()</td></tr><tr><td>java.time.LocalDateTime与java.sql.Timestamp</td><td>Timestamp.valueOf(localDateTime)</td><td>timestamp.toLocalDateTime()</td></tr><tr><td>java.time.ZoneId与java.util.TimeZone</td><td>Timezone.getTimeZone(id)</td><td>timeZone.toZoneId()</td></tr><tr><td>java.time.format.DateTimeFormatter与java.text.DateFormat</td><td>formatter.toFormat()</td><td>无</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 常用类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程基础</title>
      <link href="/2020/06/16/java-thread/"/>
      <url>/2020/06/16/java-thread/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h1><h2 id="相关的概念"><a href="#相关的概念" class="headerlink" title="相关的概念"></a>相关的概念</h2><p>前面我们写的程序都是单线程的，它们都只有一条顺序执行流：程序从main方法开始执行，依次向下执行每行代码，如果程序执行某行代码遇到了阻塞，则程序将会停滞在该处。如果我们使用Eclipse等IDE工具的单步调试功能将可以非常清楚地看出这一点。</p><p>多线程听上去是非常专业的概念，但其实非常简单：单线程的程序只有一条执行路径，多线程的程序则包含多条执行路径，多条执行路径之间互不干扰</p><p>1、程序（Program）</p><p>​    为了实现一个功能，完成一个任务而选择一种编程语言编写的一组指令的集合。</p><p>2、进程（Process）</p><p>​    几乎所有操作系统都支持进程的概念，所有运行中的任务通常对应一条进程（Process）。当一个程序进入内存运行，即变成一个进程。进程是处于运行过程中的程序，并且具有一定独立功能，进程是操作系统进行资源分配和调度的一个独立单位。</p><p>​    一般而言，进程包含如下三个特性：</p><ul><li><p>独立性：进程是操作系统进行资源分配和调度的一个独立单位，每一个进程都拥有自己私有的地址空间。在没有经过进程本身允许的情况下，一个用户进程不可以直接访问其他进程的地址空间。哪怕在同一台计算机上运行，进程之间通信可能也需要通过网络、独立于进程的文件来交换数据。</p></li><li><p>动态性：程序只是一个静态的指令的集合，而进程是一个正在系统中运行的活动的指令集合，即进程是处于运行过程中的程序。在进程中加入了时间的概念，进程具有自己的生命周期和各种不同状态，这些概念在程序中都是不具备的。</p></li><li><p>并发性：多个进程可以在单个处理器上并发执行，多个进程之间不会相互影响。</p><p>现代的操作系统都支持多进程的并发，但在具体的实现细节上可能因为硬件和操作系统的不同而采用不同的策略，目前大多数采用效率更高的抢占式多任务策略。对于一个CPU而言，它在某个时间点上只能执行一个程序，也就是只能运行一个进程，CPU不断的在这些进程之间轮换执行。那么，我们为什么可以一边用开发工具写程序，一边听音乐，一边还上网查资料…..，我们没有感觉到中断和轮换呢？这是因为CPU的执行速度相对于我们的感知速度来说实在是太快了，所以我们感觉像是同时运行一样。但是当我们启动足够多的程序时，依然可以感觉到运行速度下降的。</p></li></ul><blockquote><p>程序的一次运行。操作系统会给这个进程分配资源（内存）。</p></blockquote><blockquote><p>进程是操作系统分配资源的最小单位。</p></blockquote><blockquote><p>进程与进程之间的内存是独立，无法直接共享。</p></blockquote><blockquote><p>最早的DOS操作系统是单任务的，同一时间只能运行一个进程。后来现在的操作系统都是支持多任务的，可以同时运行多个进程。进程之间来回切换。成本比较高。</p></blockquote><p>3、线程（Thread）</p><p>多线程则扩展了多进程的概念，使得通一个进程可以同时并发处理多个任务。线程（Thread）也被称为轻量级进程。就像进程在操作系统中地位一样，线程在进程中也是独立的、并发的执行流。当进程被初始化后，主线程就被创建了，对于Java程序来说，main线程就是主线程，但我们可以在该进程内创建多条顺序执行路径，这些独立的顺序执行路径就是线程。</p><p>进程中的每一个线程可以完成一定的任务，并且是独立的，线程可以拥有自己独立的堆栈、自己的程序计数器和自己的局部变量，但不再拥有系统资源，它与父进程的其他线程共享该进程所拥有的全部资源。由于线程间的通信是在同一个地址空间上进行的，所以不需要额外的通信机制，这就使得通信更简便而且信息传递的速度也更快，因此可以通过简单编程实现多线程相互协同来完成进程所要完成的任务。但是也存在安全问题，因为其中一个线程对共享的系统资源的操作都会给其他线程带来影响，由此可知，多线程中的同步是非常重要的问题。</p><p>线程的执行也是抢占式的，也就是说，当前运行的线程在任何时候都可能被挂起，以便另一个线程可以运行。我们说CPU在不同的进程之间轮换，进程又在不同的线程之间轮换，因此线程是CPU执行和调度的最小单元。</p><p>总之，一个程序运行后至少有一个进程，一个进程里可以包含多个线程，但至少要包含一个线程。当操作系统创建一个进程时，必须为该进程分配独立的内存空间，并分配大量的相关资源；但创建一个线程简单的多，而且多个线程共享同一个进程的虚拟空间，所以，使用多线程来实现并发比使用多进程实现并发的性能要高的多。</p><p>在实际应用中，多线程是非常有用的，一个Web服务器必须能同时响应多个客户端的请求；一个浏览器必须能同时下载多个图片；一个在线播放器必须能一边下载一边播放……</p><p><strong>注意：</strong></p><p>并发性（concurrency）和并行性（parallel）是两个概念，并行是指在同一时刻，有多条指令在多个处理器上同时执行；并发是指在同一个时刻只能有一条指令执行，但多个进程的指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。</p><blockquote><p>线程是进程中的其中一条执行路径。一个进程中至少有一个线程，也可以有多个线程。有的时候也把线程称为轻量级的进程。</p></blockquote><blockquote><p>同一个进程的多个线程之间有些内存是可以共享的（方法区、堆），也有些内存是独立的（栈（包括虚拟机栈和本地方法栈）、程序计数器）。</p></blockquote><blockquote><p>线程之间的切换相对进程来说成本比较低。</p></blockquote><p>4、并行： 多个处理器同时可以执行多条执行路径。</p><p>5、并发：多个任务同时执行，但是可能存在先后关系。</p><h2 id="两种实现多线程的方式"><a href="#两种实现多线程的方式" class="headerlink" title="两种实现多线程的方式"></a>两种实现多线程的方式</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p> 步骤：</p><p>（1）编写线程类，去继承Thread类</p><p>（2）重写public void run(){}</p><p>（3）创建线程对象</p><p>（4）调用start()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Overrid</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyThread my = <span class="keyword">new</span> MyThread();</span><br><span class="line">        my.start();<span class="comment">//有名字的线程对象启动</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> MyThread().start();<span class="comment">//匿名线程对象启动</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名内部类的匿名对象启动</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名内部类，但是通过父类的变量多态引用，启动线程</span></span><br><span class="line">        Thread t =  <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>Thread.currentThread()方法总是返回当前在执行的线程对象；</li><li>getName()方法是Thread的实例方法，该方法返回当前线程对象的名字，可以通过setName(String name)方法设置线程名称，否则依次为Thread-0，Thread-1……等</li></ul><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>步骤：</p><p>（1）编写线程类，实现Runnable接口</p><p>（2）重写public void run(){}</p><p>（3）创建线程对象</p><p>（4）借助Thread类的对象启动线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//两个匿名对象</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名内部类的匿名对象作为实参直接传给Thread的构造器</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>一个完整的生命周期中通常要经历如下的五种状态：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、死亡（Dead）。CPU需要在多条线程之间切换，于是线程状态会多次在运行、阻塞、就绪之间切换。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/thread.png" alt="thread"></p><ul><li><p>新建</p><p>当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状。此时它和其他Java对象一样，仅仅由JVM为其分配了内存，并初始化了实例变量的值。此时的线程对象并没有任何线程的动态特征，程序也不会执行它的线程体run()。</p></li><li><p>就绪</p><p>但是当线程对象调用了start()方法之后，就不一样了，线程就从新建状态转为就绪状态。JVM会为其创建方法调用栈和程序计数器，当然，处于这个状态中的线程并没有开始运行，只是表示已具备了运行的条件，随时可以被调度。至于什么时候被调度，取决于JVM里线程调度器的调度。</p></li><li><p>运行</p><p>如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程体代码，则该线程处于运行状态。如果计算机只有一个CPU，在任何时刻只有一个线程处于运行状态，如果计算机有多个处理器，将会有多个线程并行（Parallel）执行。</p><p>当然，美好的时光总是短暂的，而且CPU讲究雨露均沾。对于抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务，当该时间用完，系统会剥夺该线程所占用的资源，让其回到就绪状态等待下一次被调度。此时其他线程将获得执行机会，而在选择下一个线程时，系统会适当考虑线程的优先级。</p></li><li><p>阻塞</p><p>当在运行过程中的线程遇到如下情况时，线程会进入阻塞状态：</p><ul><li>线程调用了sleep()方法，主动放弃所占用的CPU资源；</li><li>线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞；</li><li>线程试图获取一个同步监视器，但该同步监视器正被其他线程持有；</li><li>线程执行过程中，同步监视器调用了wait()，让它等待某个通知（notify）；</li><li>线程执行过程中，遇到了其他线程对象的加塞（join）；</li><li>线程被调用suspend方法被挂起（已过时，因为容易发生死锁）；</li></ul><p>当前正在执行的线程被阻塞后，其他线程就有机会执行了。针对如上情况，当发生如下情况时会解除阻塞，让该线程重新进入就绪状态，等待线程调度器再次调度它：</p><ul><li>线程的sleep()时间到；</li><li>线程调用的阻塞式IO方法已经返回；</li><li>线程成功获得了同步监视器；</li><li>线程等到了通知(notify)；</li><li>加塞的线程结束了；</li><li>被挂起的线程又被调用了resume恢复方法（已过时，因为容易发生死锁）；</li></ul></li><li><p>死亡</p><p>线程会以以下三种方式之一结束，结束后的线程就处于死亡状态：</p><ul><li><p>run()方法执行完成，线程正常结束</p></li><li><p>线程执行过程中抛出了一个未捕获的异常（Exception）或错误（Error）</p></li><li><p>直接调用该线程的stop()来结束该线程（已过时，因为容易发生死锁）</p><p>可以调用线程的isAlive()方法判断该线程是否死亡，当线程处于就绪、运行、阻塞三种状态时，该方法返回true，当线程处于新建、死亡两种状态时，该方法将返回false。 </p></li></ul></li></ul><p><strong>注意：</strong></p><p>程序只能对新建状态的线程调用start()，并且只能调用一次，如果对非新建状态的线程，如已启动的线程或已死亡的线程调用start()都会报错IllegalThreadStateException异常。</p><h2 id="Thread的相关API"><a href="#Thread的相关API" class="headerlink" title="Thread的相关API"></a>Thread的相关API</h2><p>1、构造器</p><ul><li>Thread()</li><li>Thread(String name)</li><li>Thread(Runnable target)</li><li>Thread(Runnable target, String name)</li></ul><p>2、其他方法</p><p>（1）public void run()：子类必须重写，它的方法体也称为线程体，即线程的任务代码</p><p>（2）public void start()：启动线程</p><p>（3）Thread.currentThread()：获取当前线程对象</p><p>（4）getName()：获取当前线程的名称</p><p>（5）set/getPriority()：设置或获取线程的优先级</p><p>​        优先级的范围：[1,10]，Thread类中有三个常量：MAX_PRIORITY(10)，MIN_PRIORITY(1)，NORM_PRIORITY(默认优先级5)</p><p>​        优先级只是影响概率。 </p><p>（6）线程休眠：Thread.sleep(毫秒)</p><p>（7）打断线程：interrupt()</p><p>（8）暂停当前线程：Thread.yield()</p><p>（9）线程要加塞：join()</p><blockquote><p>xx.join()这句代码写在哪个线程体中，哪个线程被加塞，和其他线程无关。</p></blockquote><p>（10）判断线程是否已启动但未终止：isAlive()</p><h2 id="关键字：volatile"><a href="#关键字：volatile" class="headerlink" title="关键字：volatile"></a>关键字：volatile</h2><p>volatile：易变，不稳定，不一定什么时候会变</p><p>修饰：成员变量</p><p>作用：当多个线程同时去访问的某个成员变量时，而且是频繁的访问，再多次访问时，发现它的值没有修改，Java执行引擎就会对这个成员变量的值进行缓存。一旦缓存之后，这个时候如果有一个线程把这个成员变量的值修改了，Jav执行引擎还是从缓存中读取，导致这个值不是最新的。如果不希望Java执行引擎把这个成员变的值缓存起来，那么就可以在成员变量的前面加volatile，每次用到这个成员变量时，都是从主存中读取。</p><h2 id="关键字：synchronized（同步）"><a href="#关键字：synchronized（同步）" class="headerlink" title="关键字：synchronized（同步）"></a>关键字：synchronized（同步）</h2><p>1、什么情况下会发生线程安全问题？</p><p>（1）多个线程</p><p>（2）共享数据</p><p>（3）多个线程的线程体中，多条语句再操作这个共享数据时</p><p>2、如何解决线程安全问题？同步锁</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/synchronized.png" alt="synchronized"></p><p>形式一：同步代码块</p><p>形式二：同步方法</p><p>3、同步代码块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">    <span class="comment">//一次任务代码，这其中的代码，在执行过程中，不希望其他线程插一脚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁对象：</p><p>​    锁对象又称为监视器对象，同一时刻，某一段代码，只允许一个线程运行，这个锁就记录当前线程，其他线程进不来，直到当前线程执行完毕代码，然后才释放锁对象</p><p>（1）任意类型的对象</p><p>（2）确保使用共享数据的这几个线程，使用同一个锁对象</p><p>4、同步方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> 【修饰符】 返回值类型  方法名(【形参列表】)<span class="keyword">throws</span> 异常列表&#123;</span><br><span class="line">    <span class="comment">//同一时间，只能有一个线程能进来运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】<span class="keyword">synchronized</span> 返回值类型  方法名(【形参列表】)<span class="keyword">throws</span> 异常列表&#123;</span><br><span class="line">    <span class="comment">//同一时间，只能有一个线程能进来运行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其实就是方法加上synchronized关键字</span></span><br></pre></td></tr></table></figure><p>锁对象：</p><p>​    同步方法的锁对象，程序员是无法选择的</p><p>（1）非静态方法：锁对象是this（谨慎）</p><p>（2）静态方法：锁对象是当前类的Class对象</p><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>生产者与消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。</p><p>该问题描述了两个（多个）共享固定大小缓冲区的线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p><p>生产者与消费者问题中其实隐含了两个问题：</p><ul><li><p>线程安全问题：</p><p>因为生产者与消费者共享数据缓冲区，不过这个问题可以使用同步解决。</p></li><li><p>线程的协调工作问题：</p><p>要解决该问题，就必须让生产者线程在缓冲区满时等待(wait)，暂停进入阻塞状态，等到下次消费者消耗了缓冲区中的数据的时候，通知(notify)正在等待的线程恢复到就绪状态，重新开始往缓冲区添加数据。同样，也可以让消费者线程在缓冲区空时进入等待(wait)，暂停进入阻塞状态，等到生产者往缓冲区添加数据之后，再通知(notify)正在等待的线程恢复到就绪状态。通过这样的通信机制来解决此类问题。</p></li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/thread2.png" alt="thread"></p><p>Object类中提供了wait()、notify()、notifyAll()方法，这三个方法并不属于Thread类，那是因为这三个方法必须有同步监视器对象来调用，而同步监视器对象可以是任意类型的对象，因此它们只能声明在Object类中。</p><p>1、为了解决“生产者与消费者问题”。</p><p>当一些线程负责往“数据缓冲区”放数据，另一个线程负责从“数据缓冲区”取数据。</p><p>问题1：生产者线程与消费者线程使用同一个数据缓冲区，就是共享数据，那么要考虑同步</p><p>问题2：当数据缓冲区满的时候，生产者线程需要wait()， 当消费者消费了数据后，需要notify或notifyAll</p><p>​        当数据缓冲区空的时候，消费者线程需要wait()， 当生产者生产了数据后，需要notify或notifyAll</p><p>2、java.lang.Object类中声明了：</p><p>（1）wait()：必须由“同步锁”对象调用</p><p>（2）notfiy()和notifyAll()：必须由“同步锁”对象调用</p><p>3、面试题：sleep()和wait的区别</p><p>（1）sleep()不释放锁，wait()释放锁</p><p>（2）sleep()在Thread类中声明的，wait()在Object类中声明</p><p>（3）sleep()是静态方法，是Thread.sleep()</p><p>​        wait()是非静态方法，必须由“同步锁”对象调用</p><p>（4）sleep()方法导致当前线程进入阻塞状态后，当时间到或interrupt()醒来</p><p>​     wait()方法导致当前线程进入阻塞状态后，由notify或notifyAll()</p><p>4、哪些操作会释放锁？</p><p>（1）同步代码块或同步方法正常执行完一次自动释放锁</p><p>（2）同步代码块或同步方法遇到return等提前结束</p><p>（3）wait()</p><p>5、不释放锁</p><p>（1）sleep()</p><p>（2）yield()</p><p>（3）suspend()</p>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举与注解</title>
      <link href="/2020/06/12/java-exception/"/>
      <url>/2020/06/12/java-exception/</url>
      
        <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常的类型的体系结构"><a href="#异常的类型的体系结构" class="headerlink" title="异常的类型的体系结构"></a>异常的类型的体系结构</h2><p>1、异常系列的超父类：java.lang.Throwable</p><p>（1）只有它或它子类的对象，才能被JVM或throw语句“抛”出</p><p>（2）也只有它或它子类的对象，才能被catch“捕获”</p><p>2、Throwable分为两大派别</p><p>（1）Error：严重的错误，需要停下来重新设计、升级解决这个问题</p><p>（2）Exception： 一般的异常，可以通过判断、检验进行避免，或者使用try…catch进行处理</p><p>3、Exception又分为两大类</p><p>（1）运行时异常：</p><p>​    它是RuntimeException或它子类的对象。</p><p>​    这种类型的异常，编译器不会提醒你，要进行throws或try…catch进行处理，但是运行时可能导致崩溃。</p><p>（2）编译时异常：</p><p>​    异常除了运行时异常以外的都是编译时异常。</p><p>​    这种类型的异常，编译器是强制要求你，throws或try…catch进行处理，否则编译不通过。</p><p>4、列出常见的异常类型</p><p>（1）运行时异常</p><p>RuntimeException、NullPointerException（空指针异常），ClassCastException（类型转换异常），ArithmeticException（算术异常），NubmerFormatException（数字格式化异常），IndexOutOfBoundsException（下标越界异常）（ArrayIndexOutOfBoundsException（数组下标越界异常）、StringIndexOutOfBoundsException（字符串下标越界异常））、InputMisMatchException（输入类型不匹配异常）。。。。</p><p>（2）编译时异常</p><p>FileNotFoundException（文件找不到异常）、IOException（输入输出异常）、SQLException（数据库sql语句执行异常）。。。</p><h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><p>1、在当前方法中处理：try…catch…finally</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形式一：try...catch</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;。。。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//形式二：try...finally</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的代码</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    无论<span class="keyword">try</span>中是否有异常，也不管是不是有<span class="keyword">return</span>，都要执行的部分</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形式三：try..catch..finally</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;。。。</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    无论<span class="keyword">try</span>中是否有异常，也不管<span class="keyword">catch</span>是否可以捕获异常，也不管<span class="keyword">try</span>和<span class="keyword">catch</span>中是不是有<span class="keyword">return</span>，都要执行的部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行特点：</p><p>（1）如果try中的代码没有异常，那么try中的代码会正常执行，catch部分就不执行，finally中会执行</p><p>（2）如果try中的代码有异常，那么try中发生异常的代码的后面就不执行了，找对应的匹配的catch分支执行，finally中会执行</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/exception.png" alt="exception"></p><p>2、finally与return混合使用时</p><p>（1）如果finally中有return，一定从finally中的return返回。</p><p>此时try和catch中的return语句，执行了一半，执行了第一个动作。所以，finally中的return语句会覆盖刚刚的返回值</p><p>return 返回值; 语句有两个动作：（1）把返回值放到“操作数栈”中，等当前方法结束后，这个“操作数栈”中的值会返回给调用处（2）结束当前方法的执行</p><p>（2）如果finally中没有return，finally中的语句会执行，但是不影响最终的返回值</p><p>即try和catch中的return语句两步拆开来走，先把（1）把返回值放到“操作数栈”中，（2）然后走finally中的语句（3）再执行return后半个动作，结束当前方法</p><p>3、在当前方法中不处理异常，明确要抛给调用者处理，使用throws</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 返回值类型  方法名(【形参列表】) <span class="keyword">throws</span> 异常列表&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时调用者，就知道需要处理哪些异常。</p><p>方法的重写的要求：</p><p>（1）方法名：相同</p><p>（2）形参列表：相同</p><p>（3）返回值类型：</p><p>​    基本数据类型和void：相同</p><p>​    引用数据类型：&lt;=</p><p>（4）修饰符：</p><p>​    权限修饰符：&gt;=</p><p>​    其他修饰符：static，final，private不能被重写</p><p>（5）throws：&lt;=</p><p>方法的重载：</p><p>（1）方法名：相同</p><p>（2）形参列表：必须不同</p><p>（3）返回值类型：无关</p><p>（4）修饰符：无关</p><p>（5）throws：无关</p><h2 id="手动抛出异常：throw"><a href="#手动抛出异常：throw" class="headerlink" title="手动抛出异常：throw"></a>手动抛出异常：throw</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> 异常对象;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AccountException(<span class="string">"xxx"</span>);</span><br></pre></td></tr></table></figure><p>throw抛出来的异常对象，和JVM抛出来的异常对象一样，也要用try..catch处理或者throws。</p><p>如果是运行时异常，编译器不会强制要求你处理，如果是编译时异常，那么编译器会强制要求你处理。</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>1、必须继承Throwable或它的子类</p><p>我们见到比较多的是继承RuntimeException和Exception.</p><p>如果你继承RuntimeException或它的子类，那么你自定义的这个异常就是运行时异常。编译器就不会提醒你处理。</p><p>如果你继承Exception，那么它属于编译时异常，编译器会强制你处理。</p><p>2、建议大家保留两个构造器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">public</span> 自定义异常名()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line"><span class="keyword">public</span> 自定义异常名(String message)&#123;</span><br><span class="line">    <span class="keyword">super</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、自定义异常对象，必须手动抛出，用throw抛出</p><h2 id="关于异常的几个方法"><a href="#关于异常的几个方法" class="headerlink" title="关于异常的几个方法"></a>关于异常的几个方法</h2><p>（1）e.printStackTrace()：打印异常对象的详细信息，包括异常类型，message，堆栈跟踪信息。这个对于调试，或者日志跟踪是非常有用的</p><p>（2）e.getMessage()：只是获取异常的message信息</p><p>关于异常信息的打印：</p><p>用System.err打印和用e.printStackTrace()都是会标记红色的突出。</p><p>用System.out打印，当成普通信息打印。</p><p>这两个打印是两个独立的线程，顺序是不能精确控制的。</p>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 异常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举与注解</title>
      <link href="/2020/06/11/java-enum/"/>
      <url>/2020/06/11/java-enum/</url>
      
        <content type="html"><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>1、枚举（JDK1.5引入的）</p><p>​    枚举类型的对象是有限、固定的几个常量对象。</p><p>​    某些类的对象只有确定的有限个时，可以把这样的类声明为枚举类。</p><p>​    例如：</p><p>​        星期：Monday(星期一)……Sunday(星期天)</p><p>​        性别：Man(男)、Woman(女)</p><p>​        月份：January(1月)……December(12月)</p><p>​        季节：Spring(春节)……Winter(冬天)</p><p>​        七彩标准色：Red(红)……Purple(紫)</p><p>​        支付方式：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡)</p><p>​        就职状态：Busy、Free、Vocation、Dimission</p><p>​        订单状态：Nonpayment（未付款）、Paid（已付款）、Fulfilled（已配货）、Delivered（已发货）、Return（退货）、Checked（已确认）</p><p>2、语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形式一：枚举类型中只有常量对象列表</span></span><br><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类型名&#123;</span><br><span class="line">    常量对象列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形式二：枚举类型中只有常量对象列表</span></span><br><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类型名&#123;</span><br><span class="line">    常量对象列表;</span><br><span class="line">    </span><br><span class="line">    其他成员列表；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：常量对象列表必须在枚举类型的首行</p><ul><li><p>使用 enum 定义的枚举类，默认继承了 java.lang.Enum类。因此不能再继承其他类。</p></li><li><p>枚举类的所有构造器只能使用 private 访问控制符</p></li><li><p>枚举类的所有实例必须在枚举类的首行显式列出(, 分隔   ; 结尾)，它们实际上都是public static final修饰的常量对象。</p></li><li><p>JDK 1.5 之后可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEnumType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Season s = Season.SPRING;</span><br><span class="line"><span class="keyword">switch</span>(s)&#123;</span><br><span class="line">      <span class="keyword">case</span> SPRING:</span><br><span class="line">        System.out.println(<span class="string">"春暖花开"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> SUMMER:</span><br><span class="line">        System.out.println(<span class="string">"夏日炎炎"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AUTUMN:</span><br><span class="line">        System.out.println(<span class="string">"秋高气爽"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> WINTER:</span><br><span class="line">        System.out.println(<span class="string">"白雪皑皑"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Season&#123;</span><br><span class="line">SPRING,SUMMER,AUTUMN,WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回忆：首行</p><p>（1）super()或super(实参列表)：必须在子类构造器的首行</p><p>（2）this()或this(实参列表)：必须在本类构造器的首行</p><p>（3）package 包; 声明包的语句必须在源文件.java的代码首行</p><p>（4）枚举常量对象列表必须在枚举类型的首行</p><p>3、在其他类中如何获取枚举的常量对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取一个常量对象</span></span><br><span class="line">枚举类型名.常量对象名</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个常量对象</span></span><br><span class="line">枚举类型名.valueOf(<span class="string">"常量对象名"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取所有常量对象</span></span><br><span class="line">枚举类型名[] all = 枚举类型名.values();</span><br></pre></td></tr></table></figure><p>4、枚举类型的特点</p><p>（1）枚举类型有一个公共的基本的父类，是java.lang.Enum类型，所以不能再继承别的类型</p><p>（2）枚举类型的构造器必须是私有的</p><p>（3）枚举类型可以实现接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyRunnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Gender implements MyRunnable&#123;</span><br><span class="line">    NAN,NV;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">enum</span> Gender implements MyRunnable&#123;</span><br><span class="line">    NAN&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;,NV&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、父类java.lang.Enum类型</p><p>（1）构造器</p><p>​        protected Enum(String name, int ordinal)：由编译器自动调用</p><p>（2）String name()：常量对象名</p><p>（3）int ordinal()：返回常量对象的序号，第一个的序号是0</p><p>（4）String toString()：返回常量对象名，如果子类想重写，需要手动写</p><p>（5）int compareTo(Object obj)：按照常量对象的顺序比较</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>1、注解</p><p>​    它是代码级别的注释</p><p>2、标记符号：@</p><p>3、系统预定义的三个最基本的注解：</p><p>（1）@Override：表示某个方法是重写的方法</p><p>​        它只能用在方法上面，会让编译器对这个方法进行格式检查，是否满足重写的要求</p><p>（2）@SuppressWarnings(xx)：抑制警告</p><p>（3）@Deprecated：表示xx已过时</p><p>4、和文档注释相关的注解</p><p>（1）文档注释</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">文档注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>（2）常见的文档注释</p><p>@author：作者</p><p>@since：从xx版本加入的</p><p>@see：另请参考</p><p>@param：形参</p><p>@return：返回值</p><p>@throws或@exception：异常</p><p>5、JUnit相关的几个注解</p><p>（1）@Test：表示它是一个单元测试方法</p><p>这个方法需要是：public void xxx(){}</p><p>（2）@Before：表示在每一个单元测试方法之前执行</p><p>这个方法需要是：public void xxx(){}</p><p>（3）@After：表示在每一个单元测试方法之后执行</p><p>这个方法需要是：public void xxx(){}</p><p>（4）@BeforeClass：表示在类初始化阶段执行，而且只执行一次</p><p>这个方法需要是：public static void xxx(){}</p><p>（3）@AfterClass：表示在类的“卸载”阶段执行，而且只执行一次</p><p>这个方法需要是：public static void xxx(){}</p><p>6、元注解</p><p>（1）@Target(xx)：用它标记的注解能够用在xx位置</p><p>(xx)：由ElementType枚举类型的10个常量对象指定，例如：TYPE，METHOD，FIELD等</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;TYPE,METHOD,FIELD&#125;)</span><br></pre></td></tr></table></figure><p>（2）@Retention（xx）：用它标记的注解可以滞留到xx阶段</p><p>(xx)：由RetentionPolicy枚举类型的3个常量对象指定，分别是：SOURCE，CLASS，RUNTIME</p><p>唯有RUNTIME阶段的注解才能被反射读取到</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br></pre></td></tr></table></figure><p>（3）@Documentd：用它标记的注解可以读取到API中</p><p>（4）@Inherited：用它标记的注解可以被子类继承</p><p>7、自定义注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@元注解</span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@元注解</span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    配置参数列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置参数的语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型  配置参数名();</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">数据类型  配置参数名() <span class="keyword">default</span> 默认值;</span><br></pre></td></tr></table></figure><p>关于配置参数：</p><p>（1）配置参数的类型有要求：</p><p>八种基本数据类型、String、枚举、Class类型、注解、它们的数组。</p><p>（2）如果自定义注解声明了配置参数，那么在使用这个注解时必须为配置参数赋值，除非它有默认值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@自定义注解名(配置参数名<span class="number">1</span>=值，配置参数名<span class="number">2</span>=值。。。)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果配置参数类型是数组，那么赋值时，可以用&#123;&#125;表示数组</span></span><br><span class="line">@自定义注解名(配置参数名<span class="number">1</span>=&#123;值&#125;，配置参数名<span class="number">2</span>=值。。。)</span><br></pre></td></tr></table></figure><p>（3）如果配置参数只有一个，并且名称是value，那么赋值时可以省略value=</p><p>（4）如果读取这个注解时，要获取配置参数的值的话，可以当成方法一样来访问</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">自定义注解对象.配置参数();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 枚举与注解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 枚举与注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象的高级特征</title>
      <link href="/2020/06/03/java-oop3/"/>
      <url>/2020/06/03/java-oop3/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象的高级特性"><a href="#面向对象的高级特性" class="headerlink" title="面向对象的高级特性"></a>面向对象的高级特性</h1><h2 id="关键字：final"><a href="#关键字：final" class="headerlink" title="关键字：final"></a>关键字：final</h2><p>final：最终的</p><p>用法：</p><p>（1）修饰类（包括外部类、内部类类）</p><p>​        表示这个类不能被继承，没有子类</p><p>（2）修饰方法</p><p>​        表示这个方法不能被重写,但是任然被继承</p><p>（3）修饰变量（成员变量（类变量、实例变量），局部变量）</p><p>​        表示这个变量的值不能被修改</p><p>注意：如果某个成员变量用final修饰后，也得手动赋值，而且这个值一旦赋完，就不能修改了，即没有set方法</p><h2 id="关键字：native"><a href="#关键字：native" class="headerlink" title="关键字：native"></a>关键字：native</h2><p>native：本地的，原生的<br>用法：</p><p>​    只能修饰方法，而且看不见方法体</p><p>​    表示这个方法的方法体代码不是用Java语言实现的，而是调用了底层C/C++的代码，这些代码被编译为.dll文件，让Java来执行的</p><p>​    但是对于Java程序员来说，可以当做Java的方法一样去正常调用它，或者子类重写它。</p><p>JVM内存的管理：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jvm.png" alt="jvm"></p><p>方法区：类的信息、常量、静态变量、动态编译生成的字节码信息</p><p>虚拟机栈：Java语言实现的方法的局部变量</p><p>本地方法栈：非Java语言实现的方法的局部变量，即native方法执行时的内存区域</p><p>堆：new出来的对象</p><p>程序计数器：记录每一个线程目前执行到哪一句指令</p><h2 id="关键字：static"><a href="#关键字：static" class="headerlink" title="关键字：static"></a>关键字：static</h2><p>static：静态的</p><p>用法：</p><p>1、成员方法：我们一般称为静态方法或类方法</p><p>（1）不能被重写</p><p>（2）被使用</p><p>​        本类中：其他方法中可以直接使用它</p><p>​        其他类中：可以使用“类名.方法”进行调用，也可以使用”对象名.方法”，推荐使用“类名.方法”</p><p>（3）在静态方法中，我们不能出现：this，super，非静态的成员</p><p>2、成员变量：我们一般称为静态变量或类变量</p><p>（1）静态变量的值是该类所有对象共享的</p><p>（2）静态变量存储在方法区</p><p>（3）静态变量对应的get/set也是静态的</p><p>（4）静态变量与局部变量同名时，就可以使用“类名.静态变量”进行区分</p><p>3、内部类：后面讲</p><p>4、代码块：静态代码块</p><p>5、静态导入（JDK1.5引入）</p><p>没有静态导入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">1000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.unclehe.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(Utils.MAX_VALUE);</span><br><span class="line">        Utils.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用静态导入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">1000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.unclehe.utils.Utils.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(MAX_VALUE);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>1、语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        静态代码块;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、作用：</p><p>协助完成类初始化，可以为类变量赋值。</p><p>3、类初始化<clinit>()</p><p>类的初始化有：</p><p>①静态变量的显式赋值代码</p><p>②静态代码块中代码</p><p>其中①和②按顺序执行</p><p>注意：类初始化方法，一个类只有一个</p><p>4、类的初始化的执行特点：</p><p>（1）每一个类的<clinit>()只执行一次</p><p>（2）如果一个子类在初始化时，发现父类也没有初始化，会先初始化父类</p><p>（3）如果既要类初始化又要实例化初始化，那么一定是先完成类初始化的</p><h2 id="变量的分类与区别"><a href="#变量的分类与区别" class="headerlink" title="变量的分类与区别"></a>变量的分类与区别</h2><p>1、变量按照数据类型分：</p><p>（1）基本数据类型的变量，里面存储数据值</p><p>（2）引用数据类型的变量，里面存储对象的地址值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//a中存储的是数据值</span></span><br><span class="line"></span><br><span class="line">Student stu = <span class="keyword">new</span> Student();<span class="comment">//stu存储的是对象的地址值</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];<span class="comment">//arr存储的是数组对象的地址值</span></span><br><span class="line">String str = <span class="string">"hello"</span>;<span class="comment">//str存储的是"hello"对象的地址值</span></span><br></pre></td></tr></table></figure><p>2、变量按照声明的位置不同：</p><p>（1）成员变量</p><p>（2）局部变量</p><p>3、成员变量与局部变量的区别</p><p>（1）声明的位置不同</p><p>成员变量：类中方法外</p><p>局部变量：（1）方法的()中，即形参（2）方法体的{}的局部变量（3）代码块{}中</p><p>（2）存储的位置不同</p><p>成员变量：</p><p>​    如果是静态变量（类变量），在方法区中</p><p>​    如果是非静态的变量（实例变量），在堆中</p><p> 局部变量：栈</p><p>（3）修饰符不同</p><p>成员变量：4种权限修饰符、static、final…</p><p>局部变量：只有final</p><p>（4）生命周期</p><p>成员变量：</p><p>​    如果是静态变量（类变量），和类相同</p><p>​    如果是非静态的变量（实例变量），和所属的对象相同，每一个对象是独立</p><p>局部变量：每次执行都是新的</p><p>（5）作用域</p><p>成员变量：</p><p>​    如果是静态变量（类变量），在本类中随便用，在其他类中使用“类名.静态变量”</p><p>​    如果是非静态的变量（实例变量），在本类中只能在非静态成员中使用，在其他类中使用“对象名.非静态的变量”</p><p>局部变量：有作用域</p><h2 id="根父类"><a href="#根父类" class="headerlink" title="根父类"></a>根父类</h2><p>1、java.lang.Object类是类层次结构的根父类。包括数组对象。</p><p>（1）Object类中声明的所有的方法都会被继承到子类中，那么即所有的对象，都拥有Object类中的方法</p><p>（2）每一个对象的创建，最终都会调用到Object实例初始化方法<init>()</p><p>（3）Object类型变量、形参、数组，可以存储任意类型的对象</p><p>2、Object类的常用方法</p><p>（1）public String toString()：</p><p>​        ①默认情况下，返回的是“对象的运行时类型 @ 对象的hashCode值的十六进制形式”</p><p>​        ②通常是建议重写，如果在eclipse中，可以用Alt +Shift + S–&gt;Generate toString()</p><p>​        ③如果我们直接System.out.println(对象)，默认会自动调用这个对象的toString()</p><p>（2）public final Class&lt;?&gt; getClass()：获取对象的运行时类型</p><p>（3）protected void finalize()：当对象被GC确定为要被回收的垃圾，在回收之前由GC帮你调用这个方法。而且这个方法只会被调用一次。子类可以选择重写。</p><p>（4）public int hashCode()：返回每个对象的hash值。</p><p>​        <strong>规定：</strong></p><p>​                ①如果两个对象的hash值是不同的，那么这两个对象一定不相等；</p><p>​                ②如果两个对象的hash值是相同的，那么这两个对象不一定相等。</p><p>​        主要用于后面当对象存储到哈希表等容中时，为了提高性能用的。</p><p>（5）public boolean equals(Object obj)：用于判断当前对象this与指定对象obj是否“相等”</p><p>​        ①默认情况下，equals方法的实现等价于<code>==</code>，比较的是对象的地址值</p><p>​        ②我们可以选择重写，重写有些要求：</p><p>​            A：如果重写equals，那么一定要一起重写hashCode()方法，因为规定：</p><p>​                a：如果两个对象调用equals返回true，那么要求这两个对象的hashCode值一定是相等的；</p><p>​                b：如果两个对象的hashCode值不同的，那么要求这个两个对象调用equals方法一定是false；</p><p>​                c：如果两个对象的hashCode值相同的，那么这个两个对象调用equals可能是true，也可能是false</p><p>​            B：如果重写equals，那么一定要遵循如下几个原则：</p><p>​                a：自反性：x.equals(x)返回true</p><p>​                b：传递性：x.equals(y)为true, y.equals(z)为true，然后x.equals(z)也应该为true</p><p>​                c：一致性：只要参与equals比较的属性值没有修改，那么无论何时调用结果应该一致</p><p>​                d：对称性：x.equals(y)与y.equals(x)结果应该一样</p><p>​                e：非空对象与null的equals一定是false</p><h2 id="关键字：abstract"><a href="#关键字：abstract" class="headerlink" title="关键字：abstract"></a>关键字：abstract</h2><p>类用于描述现实生活中一类事物。类中有属性、有方法等成员。</p><p>某种情况下，父类只能知道子类应该具备一个怎样的方法，但是不能够明确知道如何实现该方法。</p><p>只能在子类中才能确定如何去实现方法体。</p><p>例如：定义一个几何图形。所有几何图形都应该具备一个计算面积的方法。但是不同的几何图形计算面积的方式完全不同。</p><p>Java中为上述问题提供了相应的解决办法：</p><p>Java允许父类中只是提供一个方法的声明（方法的签名），但是不提供具体的实现。</p><p>具体的实现由子类来完成，该方法被称为“抽象方法”。</p><p>拥有一个或者多个抽象方法的类，被称为“抽象类”。</p><p>1、什么时候会用到抽象方法和抽象类？</p><p>当声明父类的时候，在父类中某些方法的方法体的实现不能确定，只能由子类决定。但是父类中又要体现子类的共同的特征，即它要包含这个方法，为了统一管理各种子类的对象，即为了多态的应用。</p><p>那么此时，就可以选择把这样的方法声明为抽象方法。如果一个类包含了抽象方法，那么这个类就必须是个抽象类。</p><p>2、抽象类的语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【权限修饰符】 <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">【权限修饰符】 <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、抽象方法的语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【其他修饰符】 <span class="keyword">abstract</span> 返回值类型  方法名(【形参列表】);</span><br></pre></td></tr></table></figure><p>抽象方法没有方法体</p><p>4、抽象类的特点</p><p>（1）抽象类不能直接实例化，即不能直接new对象</p><p>（2）抽象类就是用来被继承的，那么子类继承了抽象类后，必须重写所有的抽象方法，否则这个子类也得是抽象类</p><p>（3）抽象类也有构造器，这个构造的作用不是创建抽象类自己的对象用的，给子类在实例化过程中调用；</p><p>（4）抽象类也可以没有抽象方法，那么目的是不让你创建对象，让你创建它子类的对象</p><p>（5）抽象类的变量与它子类的对象也构成多态引用</p><p>5、不能和abstract一起使用的修饰符？</p><p>（1）final：和final不能一起修饰方法和类</p><p>（2）static：和static不能一起修饰方法</p><p>（3）native：和native不能一起修饰方法</p><p>（4）private：和private不能一起修饰方法</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>1、接口的概念</p><p>接口是一种标准。注意关注行为标准（即方法）。</p><p>面向对象的开发原则中有一条：面向接口编程。</p><p>2、接口的声明格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">interface</span> 接口名</span>&#123;</span><br><span class="line">    接口的成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、类实现接口的格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 实现类  <span class="keyword">implements</span> 父接口们</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 实现类 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 父接口们</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、接口继承接口的格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">interface</span> 接口名 <span class="keyword">extends</span> 父接口们</span>&#123;</span><br><span class="line">    接口的成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、接口的特点</p><p>（1）接口不能直接实例化，即不能直接new对象</p><p>（2）只能创建接口的实现类对象，那么接口与它的实现类对象之间可以构成多态引用。</p><p>（3）实现类在实现接口时，必须重写所有抽象的方法，否则这个实现类也得是抽象类。</p><p>（4）Java规定类与类之间，只能是单继承，但是Java的类与接口之间是多实现的关系，即一个类可以同时实现多个接口</p><p>（5）Java还支持接口与接口之间的多继承。</p><p>6、接口的成员</p><p>JDK1.8之前：</p><p>（1）全局的静态的常量：public static final，这些修饰符可以省略</p><p>（2）公共的抽象方法：public abstract，这些修饰符也可以省略</p><p>JDK1.8之后：</p><p>（3）公共的静态的方法：public static ,这个就不能省略了</p><p>（4）公共的默认的方法：public default，这个就不能省略了</p><p>7、默认方法冲突问题</p><p>（1） 当一个实现类同时实现了两个或多个接口，这个多个接口的默认方法的签名相同。</p><p>解决方案：</p><p>方案一：选择保留其中一个</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口名.<span class="keyword">super</span>.方法名(【实参列表】);</span><br></pre></td></tr></table></figure><p>方案二：完全重写</p><p>（2）当一个实现类同时继承父类，又实现接口，父类中有一个方法与接口的默认方法签名相同</p><p>解决方案：</p><p>方案一：默认方案，保留父类的</p><p>方案二：选择保留接口的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口名.<span class="keyword">super</span>.方法名(【实参列表】);</span><br></pre></td></tr></table></figure><p>方案三：完全重写</p><p>8、示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> MAX_SPEED = <span class="number">7900000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9、常用的接口</p><p>（1）java.lang.Comparable接口：自然排序</p><p>​    抽象方法：int compareTo(Object obj)</p><p>（2）java.util.Comparator接口：定制排序</p><p>​    抽象方法：int compare(Object obj1 ,Object obj2)</p><p>（3）示例代码</p><p>如果员工类型，默认顺序，自然顺序是按照编号升序排列，那么就实现Comparable接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略了构造器，get/set,toString</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id - ((Employee)obj).id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在后面又发现有新的需求，想要按照薪资排序，那么只能选择用定制排序，实现Comparator接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalaryComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span></span>&#123;</span><br><span class="line">        Employee e1 = (Employee)o1;</span><br><span class="line">        Employee e2 = (Employee)o2;</span><br><span class="line">        <span class="keyword">if</span>(e1.getSalary() &gt; e2.getSalary())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e1.getSalary() &lt; e2.getSalary())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>1、内部类的概念</p><p>​    声明在另外一个类里面的类就是内部类。</p><p>2、内部类的4种形式</p><p>（1）静态内部类</p><p>（2）非静态成员内部类</p><p>（3）有名字的局部内部类</p><p>（4）匿名内部类</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>1、语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在匿名子类中调用父类的无参构造</span></span><br><span class="line"><span class="keyword">new</span> 父类()&#123;</span><br><span class="line">    内部类的成员列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在匿名子类中调用父类的有参构造</span></span><br><span class="line"><span class="keyword">new</span> 父类(实参列表)&#123;</span><br><span class="line">    内部类的成员列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口没有构造器，那么这里表示匿名子类调用自己的无参构造，调用默认父类Object的无参构造</span></span><br><span class="line"><span class="keyword">new</span> 父接口名()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、匿名内部类、匿名对象的区别？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> Student(<span class="string">"张三"</span>));<span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">Student stu = <span class="keyword">new</span> Student(<span class="string">"张三"</span>);<span class="comment">//这个对象有名字，stu</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//既有匿名内部类，又是一个匿名的对象</span></span><br><span class="line"><span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.test();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个匿名内部类的对象，使用obj这个名字引用它，既对象有名字，但是这个Object的子类没有名字</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3、使用的形式</p><p>（1）示例代码：继承式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//用父类与匿名内部类的对象构成多态引用</span></span><br><span class="line">        Father f = <span class="keyword">new</span> Father()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"用匿名内部类继承了Father这个抽象类，重写了test抽象方法"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        f.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）示例代码：实现式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//用父接口与匿名内部类的对象构成了多态引用</span></span><br><span class="line">        Flyable f = <span class="keyword">new</span> Flyable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"用匿名内部类实现了Flyable这个接口，重写了抽象方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        f.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）示例代码：用匿名内部类的匿名对象直接调用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用匿名内部类的匿名对象直接调用方法"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.test();</span><br></pre></td></tr></table></figure><p>（4）示例代码：用匿名内部类的匿名对象直接作为实参</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student[] all = <span class="keyword">new</span> Student[<span class="number">3</span>];</span><br><span class="line">all[<span class="number">0</span>] = <span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="number">23</span>);</span><br><span class="line">all[<span class="number">1</span>] = <span class="keyword">new</span> Student(<span class="string">"李四"</span>,<span class="number">22</span>);</span><br><span class="line">all[<span class="number">2</span>] = <span class="keyword">new</span> Student(<span class="string">"王五"</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用匿名内部类的匿名对象直接作为实参</span></span><br><span class="line"><span class="comment">//这个匿名内部类实现了Comparator接口</span></span><br><span class="line"><span class="comment">//这个匿名内部类的对象，是定制比较器的对象</span></span><br><span class="line">Arrays.sort(all, <span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Obeject o1, Object o2)</span></span>&#123;</span><br><span class="line">        Student s1 = (Student)o1;</span><br><span class="line">        Student s2 = (Student)o2;</span><br><span class="line">        <span class="keyword">return</span> s1.getAge() - s2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 外部类名  【<span class="keyword">extends</span> 外部类的父类】 【<span class="keyword">implements</span> 外部类的父接口们】</span>&#123;</span><br><span class="line">【其他修饰符】 <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  静态内部类 【<span class="keyword">extends</span> 静态内部类自己的父类】 【<span class="keyword">implements</span> 静态内部类的父接口们】</span>&#123;</span><br><span class="line">        静态内部类的成员列表;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">外部类的其他成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 使用注意事项</p><p>（1）包含成员是否有要求：</p><p>​        可以包含类的所有成员</p><p>（2）修饰符要求：</p><ul><li>​        权限修饰符：4种</li><li>​        其他修饰符：abstract、final</li></ul><p>（3）使用外部类的成员上是否有要求</p><ul><li>​        只能使用外部类的静态成员</li></ul><p>（4）在外部类中使用静态内部类是否有要求</p><ul><li>​        正常使用</li></ul><p>（5）在外部类的外面使用静态内部类是否有要求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）如果使用的是静态内部类的静态成员</span><br><span class="line">外部类名.静态内部类名.静态成员</span><br><span class="line">（<span class="number">2</span>）如果使用的是静态内部类的非静态成员</span><br><span class="line">①先创建静态内部类的对象</span><br><span class="line">外部类名.静态内部类名 对象名 = <span class="keyword">new</span> 外部类名.静态内部类名(【实参列表】);</span><br><span class="line">②通过对象调用非静态成员</span><br><span class="line">对象名.xxx</span><br></pre></td></tr></table></figure><p>（6）字节码文件形式：外部类名$静态内部类名.class</p><p>3、示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer.Inner.test();</span><br><span class="line">        </span><br><span class="line">        Outer.Inner in = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h3><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 外部类名  【<span class="keyword">extends</span> 外部类的父类】 【<span class="keyword">implements</span> 外部类的父接口们】</span>&#123;</span><br><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span>  非静态内部类 【<span class="keyword">extends</span> 非静态内部类自己的父类】 【<span class="keyword">implements</span> 非静态内部类的父接口们】</span>&#123;</span><br><span class="line">        非静态内部类的成员列表;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">外部类的其他成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 使用注意事项</p><p>（1）包含成员是否有要求：</p><p>​    不允许出现静态的成员</p><p>（2）修饰符要求</p><p>​    权限修饰符：4种</p><p>​    其他修饰符：abstract，final</p><p>（3）使用外部类的成员上是否有要求</p><p>​    都可以使用</p><p>（4）在外部类中使用非静态内部类是否有要求</p><p>​    在外部类的静态成员中不能使用非静态内部类</p><p>（5）在外部类的外面使用非静态内部类是否有要求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用非静态内部类的非静态成员</span></span><br><span class="line"><span class="comment">//(1)创建外部类的对象</span></span><br><span class="line">外部类名  对象名<span class="number">1</span> = <span class="keyword">new</span>  外部类名(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)通过外部类的对象去创建或获取非静态内部类的对象</span></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line">外部类名.非静态内部类名  对象名<span class="number">2</span> = 对象名<span class="number">1</span>.<span class="keyword">new</span> 非静态内部类名(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line">外部类名.非静态内部类名  对象名<span class="number">2</span> = 对象名<span class="number">1</span>.get非静态内部类对象的方法(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）通过非静态内部类调用它的非静态成员</span></span><br><span class="line">对象名<span class="number">2</span>.xxx</span><br></pre></td></tr></table></figure><p>（6）字节码文件形式：外部类名$非静态内部类名.class</p><p>3、示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">            System.out.println(j);<span class="comment">//可以</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">// Inner in = new Inner();//不可以</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        </span><br><span class="line">        Outer.Inner in1 = out.<span class="keyword">new</span> Inner();     <span class="comment">//创建   </span></span><br><span class="line">        in1.method();</span><br><span class="line">        </span><br><span class="line">        Outer.Inner in2 = out.getInner();<span class="comment">//获取</span></span><br><span class="line">        in2.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 外部类名  【<span class="keyword">extends</span> 外部类的父类】 【<span class="keyword">implements</span> 外部类的父接口们】</span>&#123;</span><br><span class="line">【修饰符】 返回值类型  方法名(【形参列表】)&#123;</span><br><span class="line">        【修饰符】 <span class="class"><span class="keyword">class</span>  局部内部类 【<span class="keyword">extends</span> 局部内部类自己的父类】 【<span class="keyword">implements</span> 局部内部类的父接口们】</span>&#123;</span><br><span class="line">        局部内部类的成员列表;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">外部类的其他成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 使用注意事项</p><p>（1）包含成员是否有要求</p><p>​    不允许出现静态的成员</p><p>（2）修饰符要求</p><p>​    权限修饰符：不能</p><p>​    其他修饰符：abstract、final</p><p>（3）使用外部类的成员等上是否有要求</p><p>​    ①使用外部类的静态成员：随便用</p><p>​    ②使用外部类的非静态成员：能不能用要看所在的方法是否是静态的</p><p>​    ③使用所在方法的局部变量：必须 final修饰的</p><p>（4）在外部类中使用局部内部类是否有要求</p><p>​    有作用域</p><p>（5）在外部类的外面使用局部内部类是否有要求</p><p>​    没法使用</p><p>（6）字节码文件形式：外部类名$编号局部内部类名.class</p><p>3、示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">                System.out.println(j);<span class="comment">//可以</span></span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> k = <span class="number">30</span>;</span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">                System.out.println(j);<span class="comment">//不可以</span></span><br><span class="line">                System.out.println(k);<span class="comment">//可以</span></span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象的基本特征</title>
      <link href="/2020/06/02/java-oop2/"/>
      <url>/2020/06/02/java-oop2/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象的基本特征"><a href="#面向对象的基本特征" class="headerlink" title="面向对象的基本特征"></a>面向对象的基本特征</h1><p>面向对象的基本特征：</p><p>1、封装</p><p>2、继承</p><p>3、多态</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><blockquote><p>封装是面向对象编程的核心思想。将对象的属性和行为封装起来，其载体就是类。类通常对客户隐藏其实现细节，这就是封装的思想。</p></blockquote><p>1、好处：</p><p>（1）隐藏实现细节，方便使用者使用</p><p>（2）安全，可以控制可见范围</p><p>2、如何实现封装？</p><p>通过权限修饰符</p><blockquote><p>面试题：请按照可见范围从小到大（从大到小）列出权限修饰符？</p></blockquote><table><thead><tr><th>修饰符</th><th>本类</th><th>本包</th><th>其他包的子类</th><th>任意位置</th></tr></thead><tbody><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>缺省(什么都不写)</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>权限修饰符可以修饰什么？</p><p>类（类、接口等）、属性、方法、构造器、内部类</p><p>类（外部类）：常用<code>public</code>和<code>缺省</code>修饰</p><p>属性：4种都可以</p><p>方法：4种都可以</p><p>构造器：4种都可以</p><p>内部类：4种都可以</p><p>3、通常属性的封装是什么样的？</p><p>当属性的权限修饰符可以是private、缺省、protected、public。但是我们大多数时候，见到的都是private，然后给它们配上get/set方法。</p><p>示例代码：标准Javabean的写法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性私有化</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> marry;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公共的get/set</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">        name = n;<span class="comment">//这里因为还没有学习this等，可能还会优化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMarry</span><span class="params">(<span class="keyword">boolean</span> m)</span></span>&#123;</span><br><span class="line">        marry = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMarry</span><span class="params">()</span></span>&#123;<span class="comment">//boolean类型的属性的get方法，习惯使用把get换成is</span></span><br><span class="line">        <span class="keyword">return</span> marry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>1、构造器的作用：<br>（1）和new一起使用创建对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用无参构造创建对象</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参构造创建对象</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名(实参列表);</span><br></pre></td></tr></table></figure><p>（2）可以在创建对象的同时为属性赋值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">        radius = r;<span class="comment">//为radius赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、声明构造器的语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 类名()&#123;<span class="comment">//无参构造</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    【修饰符】 类名(形参列表)&#123;<span class="comment">//有参构造</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、构造器的特点：</p><p>（1）所有的类都有构造器</p><p>（2）如果一个类没有显式/明确的声明一个构造器，那么编译器将会自动添加一个默认的无参构造</p><p>（3）如果一个类显式/明确的声明了构造器，那么编译器将不再自动添加默认的无参构造，如果需要，那么就需要手动添加</p><p>（4）构造器的名称必须与类名相同</p><p>（5）构造器没有返回值类型</p><p>（6）构造器可以重载</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">        radius = r;<span class="comment">//为radius赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键字this"><a href="#关键字this" class="headerlink" title="关键字this"></a>关键字this</h2><p>1、this关键字：</p><p>意思：当前对象</p><p>（1）如果出现在构造器中：表示正在创建的对象</p><p>（2）如果出现在成员方法中：表示正在调用这个方法的对象</p><p>2、this的用法：</p><p>（1）this.属性</p><p>​    当局部变量与成员变量同名时，那么可以在成员变量的而前面加“this.”用于区别</p><p>（2）this.方法</p><p>​    调用当前对象的成员方法，完全可以省略“this.”</p><p>（3）this()或this(实参列表)</p><p>​    this()表示调用本类的无参构造</p><p>​    this(实参列表)表示调用本类的有参构造</p><blockquote><p>this()或this(实参列表)要么没有，要么必须出现在构造器的首行</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、成员变量与局部变量的区别？</p><p>这里只讨论实例变量（关于类变量见static部分）</p><p>（1）声明的位置不同</p><p>成员变量：类中方法外</p><p>局部变量：方法中或代码中</p><p>​    ①方法的形参列表</p><p>​    ②方法体中局部变量</p><p>​    ③代码块中的局部变量</p><p>（2）运行时在内存中的存储位置不同</p><p>成员变量：堆</p><p>局部变量：栈</p><blockquote><p>基本数据类型的变量在栈中，引用数据类型的变量在堆中：不准确</p></blockquote><p>（3）修饰符</p><p>成员变量：有很多修饰符，例如：权限修饰符</p><p>局部变量：不能加权限修饰符，唯一的能加的是final</p><p>（4）初始化</p><p>成员变量：有默认值</p><p>局部变量：没有默认值，必须手动初始化</p><p>（5）生命周期</p><p>成员变量：随着对象的创建而创建，随着对象被回收而消亡，即与对象同生共死。每一个对象都是独立的。</p><p>局部变量：方法调用时才分配，方法运行结束就没有了。每一次方法调用，都是独立的</p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>1、包的作用：</p><p>（1）可以避免类重名</p><p>​    有了包之后，类的全名称就变为：包.类名</p><p>（2）分类组织管理众多的类</p><p>​    例如：java.lang包，java.util包，java.io包…..</p><p>（3）可以控制某些类型或成员的可见范围</p><p>​    如果某个类型或者成员的权限修饰缺省的话，那么就仅限于本包使用</p><p>2、声明包的语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>(1)必须在源文件的代码首行</p><p>(2)一个源文件只能有一个</p></blockquote><p>3、包的命名规范和习惯：<br>（1）所有单词都小写，每一个单词之间使用.分割<br>（2）习惯用公司的域名倒置</p><p>例如：com.alibaba.xxx;</p><blockquote><p>建议大家取包名时不要使用“java.xx”包，可能与java的核心包重复</p></blockquote><p>4、使用其他包的类：</p><p>​    前提：被使用的类或成员的权限修饰符是 &gt; 缺省的</p><p>（1）使用类型的全名称</p><p>​    例如：java.util.Scanner input = new java.util.Scanner(System.in);</p><p>（2）使用import 语句之后，代码中使用简名称</p><p>5、import语句</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 包.类名;</span><br><span class="line"><span class="keyword">import</span> 包.*;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>当使用两个不同包的同名类时，例如：java.util.Date和java.sql.Date。一个使用全名称，一个使用简名称</p><p>Java.lang包中的类可以不使用import语句，直接使用简名称</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.project.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>1、为什么要继承</p><ul><li>当多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。提高了代码的复用性。</li><li>继承的出现让类与类之间产生了关系，可以创建更为特殊的类型。</li><li>利于可维护性。<br>此处的多个类称为<strong>子类</strong>（派生类SubClass），单独的这个类称为<strong>父类</strong>（基类或超类SuperClass）。</li></ul><p><strong>继承的好处</strong></p><p>（1）代码的复用</p><p>（2）代码的扩展</p><p>2、如何实现继承？</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 子类  <span class="keyword">extends</span> 父类</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、继承的特点</p><p>（1）子类会继承父类的所有特征（属性、方法）</p><p>​    但是，私有的在子类中是不能直接使用的(可通过get/set间接使用)</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/inherit.png" alt="inherit"></p><p>（2）子类不会继承父类的构造器</p><p>​    因为，父类的构造器是用于创建父类的对象的</p><p>（3）子类的构造器中又必须去调用父类的构造器</p><p>​    在创建子类对象的同时，为从父类继承的属性进行初始化用，可以借助父类的构造器中的代码为属性赋值。</p><p>（4）Java只支持单继承：一个子类只能有一个“直接”父类</p><p>（5）Java又支持多层继承：父类还可以有父类，特征会代代相传</p><p>（6）一个父类可以同时拥有很多个子类</p><h2 id="关键字super"><a href="#关键字super" class="headerlink" title="关键字super"></a>关键字super</h2><p>super关键字：引用父类的xx，找父类的xx</p><p>用法：</p><p>（1）super.属性</p><p>​    当子类声明了和父类同名的成员变量时，那么如果要表示某个成员变量是父类的，那么可以加“super.”</p><p>（2）super.方法</p><p>​    当子类重写了父类的方法，又需要在子类中调用父类被重写的方法，可以使用”super.”</p><p>（3）super()或super(实参列表)</p><p>​    super()：表示调用父类的无参构造</p><p>​    super(实参列表)：表示调用父类的有参构造</p><blockquote><p>注意：</p><p>（1）如果要写super()或super(实参列表)，必须写在子类构造器的首行</p><p>（2）如果子类的构造器中没有写：super()或super(实参列表)，那么默认会有 super()</p><p>（3）如果父类没有无参构造，那么在子类的构造器的首行“必须”写super(实参列表)</p><p>（4）如果子类构造器中写了super(实参列表)，那么super()就不会存在</p></blockquote><h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p>1、方法的重写（Override）</p><p>当子类继承了父类的方法时，又觉得父类的方法体的实现不适合于子类，那么子类可以选择进行重写。</p><p>2、方法的重写的要求</p><p>（1）方法名：必须相同</p><p>（2）形参列表：必须相同</p><p>（3）修饰符</p><p>​    权限修饰符：子类方法的权限修饰符的可见性范围 &gt;= 父类被重写方法的权限修饰符的可见性范围</p><p>​        例如：</p><p>​                子类方法的权限修饰符是public，父类被重写的权限修饰符public</p><p>​                子类方法的权限修饰符是public，父类被重写的权限修饰符protected</p><p>（4）返回值类型</p><p>​    如果是基本数据类型和void：必须相同</p><p>​    如果是引用数据类型：要求子类重写的方法返回值类型 &lt;= 父类被重写的方法的返回值类型</p><p>​        例如：</p><p>​                子类方法的返回值类型是Student，父类被重写的返回值类型是Student</p><p>​                子类方法的返回值类型是Student，父类被重写的返回值类型是Person</p><p>​    在Java中我们认为，在概念范围上：子类 &lt; 父类</p><p>3、重载（Overload）与重写（Override）的区别</p><p>​    重载（Overload）：在同一个类中，方法名相同，形参列表不同，和返回值类型无关的两个或多个方法。</p><p>​    重写（Override）：在父子类之间。对方法签名的要求见上面。</p><p>特殊的重载：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOverload</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="comment">//b对象可以调用几个a方法</span></span><br><span class="line">b.a();</span><br><span class="line">b.a(<span class="string">""</span>);<span class="comment">//从b对象同时拥有两个方法名相同，形参不同的角度来说，算是重载</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非静态代码块"><a href="#非静态代码块" class="headerlink" title="非静态代码块"></a>非静态代码块</h2><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        非静态代码块</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、作用</p><p>目的：在创建的过程中，为对象属性赋值，协助完成实例初始化的过程</p><p>3、什么时候执行？</p><p>（1）每次创建对象时都会执行</p><p>（2）优先于构造器执行</p><h2 id="实例初始化过程"><a href="#实例初始化过程" class="headerlink" title="实例初始化过程"></a>实例初始化过程</h2><p>1、概念描述</p><ul><li><p>实例初始化过程：实例对象创建的过程</p></li><li><p>实例初始化方法：实例对象创建时要执行的方法</p></li><li><p>实例初始化方法的由来：它是有编译器编译生成的</p></li><li><p>实例初始化方法的形式：<init>()或<init>(形参列表)</p></li><li><p>实例初始化方法的构成：</p><p>①属性的显式赋值代码</p><p>②非静态代码块的代码</p><p>③构造器的代码</p><blockquote><p>其中</p><p>①和②按顺序执行，从上往下</p><p>③在①和②的后面</p></blockquote></li></ul><p>因此一个类有几个构造器，就有几个实例初始化方法。</p><p>2、单个类实例初始化方法</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"非静态代码块1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String str = assign();<span class="comment">//调用方法，来为str进行显式赋值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.str = str;</span><br><span class="line">System.out.println(<span class="string">"有参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"非静态代码块2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">assign</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"assign方法"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/initialization.png" alt="initialization"></p><p>3、父子类的实例初始化</p><p>注意：</p><p>（1）原先super()和super(实参列表)说是调用父类的构造器，现在就要纠正为调用父类的实例初始化方法了</p><p>（2）原先super()和super(实参列表)说是必须在子类构造器的首行，现在要纠正为必须在子类实例初始化方法的首行</p><p>结论：</p><p>（1）执行顺序是先父类实例初始化方法，再子类实例初始化方法</p><p>（2）如果子类重写了方法，通过子类对象调用，一定是执行重写过的方法</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ba</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String str = assign();</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"(1)父类的非静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Ba</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"(2)父类的无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">assign</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"(3)父类的assign()"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"ba"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Er</span> <span class="keyword">extends</span> <span class="title">Ba</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String str = assign();</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"(4)子类的非静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Er</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//super()  ==&gt;调用父类的实例初始化方法，而且它在子类实例初始化方法的首行</span></span><br><span class="line">System.out.println(<span class="string">"(5)子类的无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">assign</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"(6)子类的assign()"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"er"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Er();<span class="comment">//612645</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/initialization2.png" alt="initialization"></p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>1、多态：</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类 引用/变量 = 子类的对象;</span><br></pre></td></tr></table></figure><p>2、前提：</p><p>（1）继承</p><p>（2）方法的重写</p><p>（3）多态引用</p><p>3、现象：</p><p>​    编译时看左边/“父类”，运行时看右边/“子类”。</p><p>​    编译时，因为按父类编译，那么只能父类有的方法，子类扩展的方法是无法调用的；    </p><p>​    执行时一定是运行子类重写的过的方法体。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"走路"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"细嚼慢咽的吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"婀娜多姿走路"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shop</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"买买买..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"狼吞虎咽的吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"大摇大摆的走路"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"吞云吐雾"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Woman();<span class="comment">//多态引用</span></span><br><span class="line">        p.eat();<span class="comment">//执行子类重写</span></span><br><span class="line">        p.walk();<span class="comment">//执行子类重写</span></span><br><span class="line">        <span class="comment">//p.shop();//无法调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、应用：</p><p>（1）多态参数：形参是父类类型，实参是子类对象</p><p>（2）多态数组：数组元素类型是父类，元素存储的是子类对象</p><p>示例代码：多态参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> Woman());<span class="comment">//实参是子类对象</span></span><br><span class="line">        test(<span class="keyword">new</span> Man());<span class="comment">//实参是子类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Person p)</span></span>&#123;<span class="comment">//形参是父类类型</span></span><br><span class="line">      <span class="comment">// 相当于 Person p = new Woman() 或者 new Man() 形成多态</span></span><br><span class="line">        p.eat();</span><br><span class="line">        p.walk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：多态数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person[] arr = <span class="keyword">new</span> Person[<span class="number">2</span>];<span class="comment">//多态数组</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> Woman(); <span class="comment">// arr[0] 的类型为Person 形成多态</span></span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> Man();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            all[i].eat();</span><br><span class="line">            all[i].walk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、向上转型与向下转型：父子类之间的转换</p><p>（1）向上转型：自动类型转换</p><p>​    当把子类的对象赋值给父类的变量时（即多态引用时），在编译时，这个对象就向上转型为父类。此时就看不见子类“特有、扩展”的方法。</p><p>（2）向下转型：强制转换。有风险，可能会报ClassCastException异常。</p><p>​    当需要把父类的变量赋值给一个子类的变量时，就需要向下转型。</p><p>​    <strong>要想转型成功，必须保证该变量中保存的对象的运行时类型是 &lt;= 强转的类型</strong></p><p><strong>为什么要向上转型？</strong></p><p>​    因为多态数组、多态参数的应用场景，使得有的时候，不得不向上转型，这是为了方便统一管理各种子类的对象。</p><p><strong>为什么要向下转型?</strong></p><p>​    向下转型的目的是为了调用子类特有的方法等    </p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChineseWoman</span> <span class="keyword">extends</span> <span class="title">Woman</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//向上转型</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Woman();</span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line">Woman m = (Woman)p1; </span><br><span class="line"><span class="comment">//p1变量中实际存储的对象就是Woman类型，和强转的Woman类型一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向上转型</span></span><br><span class="line">Person p2 = <span class="keyword">new</span> ChineseWoman();</span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line">Woman w2 = (Woman) p2; </span><br><span class="line"><span class="comment">//p2变量中实际存储的对象是ChineseWoman类型，强制的类型是Woman，ChineseWoman&lt;Woman类型     </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、instanceof</p><p>表达式语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象/变量  <span class="keyword">instanceof</span>  类型</span><br></pre></td></tr></table></figure><p>运算结果：true 或 false</p><p>作用：</p><p>用来判断这个对象是否属于这个类型，或者说，是否是这个类型的对象或这个类型子类的对象</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChineseWoman</span> <span class="keyword">extends</span> <span class="title">Woman</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Woman w = <span class="keyword">new</span> Woman();</span><br><span class="line">        ChineseWoman c = <span class="keyword">new</span> ChineseWoman();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p <span class="keyword">instanceof</span> Woman)&#123;<span class="comment">//false</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(w <span class="keyword">instanceof</span> Woman)&#123;<span class="comment">//true</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c <span class="keyword">instanceof</span> Woman)&#123;<span class="comment">//true</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象基础</title>
      <link href="/2020/05/31/java-oop1/"/>
      <url>/2020/05/31/java-oop1/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象编程思想"><a href="#面向对象编程思想" class="headerlink" title="面向对象编程思想"></a>面向对象编程思想</h1><p>常见的编程思想有：</p><p><strong>面向过程（POP）编程思想</strong></p><p>面向过程POP（Process-Oriented Programming）强调的是系统的数据被加工处理的过程，数据仅仅作为输入和输出存在，在程序设计中主要以函数或者过程为程序的基本组织方式。</p><p>比如说，C语言中，数据与处理这些数据的函数是分离的，程序的最小单元是函数。</p><p><strong>面向对象（OOP）编程思想</strong></p><p>前辈们说，这样不好，应该把数据和与这些数据相关的行为放在一起，用一个叫做类的东西装起来。于是，在Java中，程序的最小单元变成了类。——这种思想叫做面向对象编程。</p><p>面向对象（Object Oriented Programming）是以<strong>对象</strong>为中心，将对象的内部组织与外部环境区别开来，将表征对象的内部属性数据与外部隔离开来，其行为与属性构成了一个整体，而系统功能则表现为一系列对象之间的相互作用的序列，能更加形象的模拟或表达现实世界。</p><p>当然，会使用Java语言并不代表已经领会了面向对象的思想。面向对象有三大特性：封装、继承、多态。封装有什么作用？封装时要注意什么？继承有什么优点和缺点？什么时候使用继承？多态有什么好处？什么时候使用多态？……这些问题的解答有一些指导原则，比如单一职责原则、里氏替换原则、开闭原则、接口隔离原则、依赖倒置原则等等。这些原则就是编程思想。</p><p>举个例子来说，你写了一个程序，现在用的是SQLServer的数据库，但客户说，将来也可能换成MySQL、Oracle数据库。那你可能就会考虑了：如何在现有的基础上，做最少的改动，就能从SQLServer换到MySQL、Oracle。于是，你就会开始想这些问题：如何能达到更少的变动？是否需要创建接口？在什么地方创建接口？接口中定义哪些方法？如何让调用者更方便地获取接口的实现类的对象？……这个，就是你的编程思想。就是那些原则在你的实践中的应用。</p><p>面向过程：POP: Process-Oriented Programming</p><p>​    以函数（方法）为最小单位</p><p>​    以过程，步骤为主，考虑怎么做</p><p>​    </p><p>面向对象：OOP: Object Oriented Programming</p><p>​    以类/对象为最小单位，类包括：数据+方法</p><p>​    以对象（谁）为主，考虑谁来做，谁能做</p><p>面向对象仍然包含面向过程，只不过关注点变了，关注谁来做</p><p>​    </p><p>程序员的角色：</p><p>面向过程：程序员是具体执行者</p><p>面向对象：程序员是指挥者</p><p>面向对象的开发过程：其实就是不断创造对象，使用对象，指挥对象做事情</p><p>面向对象的设计过程：就是管理和维护对象之间的关系</p><h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><p>类与对象是面向对象的核心概念：</p><p>类(class)：对现实生活中一类事物的描述，抽象的，也可以说类是对象的设计模板。</p><p>对象(object)：是实际存在的该类事物的每个个体，因而也称实例(instance)，是一个实实在在的个体，具体的</p><p>比如：</p><p>​    宝马、奥迪、奔驰、特斯拉、比亚迪…这些就可以抽取一个<code>车</code>的类。</p><p>​    颜色、轴长、价格…这些就是<code>车</code>类的属性。</p><p>​    驾驶、拉人、撩妹…这些就是<code>车</code>类的行为(方法)。</p><h2 id="如何声明类"><a href="#如何声明类" class="headerlink" title="如何声明类"></a>如何声明类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    成员列表：属性、方法、构造器、代码块、内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名();  <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名(); <span class="comment">//有名对象</span></span><br></pre></td></tr></table></figure><h1 id="类的成员之一：属性"><a href="#类的成员之一：属性" class="headerlink" title="类的成员之一：属性"></a>类的成员之一：属性</h1><h2 id="如何声明属性"><a href="#如何声明属性" class="headerlink" title="如何声明属性"></a>如何声明属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 数据类型  属性名;    <span class="comment">//属性有默认值</span></span><br><span class="line">    【修饰符】 数据类型  属性名 = 值; <span class="comment">//属性有初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">car</span> </span>&#123;</span><br><span class="line">String color;</span><br><span class="line">  <span class="keyword">double</span> price;</span><br><span class="line">  <span class="keyword">double</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：属性的类型可以是Java的任意类型，包括基本数据类型、引用数据类型（类、接口、数组等）</p></blockquote><p><strong>总结：</strong></p><p>Java的数据类型</p><p>（1）基本数据类型</p><p>​        byte,short,int,long,float,double,char,boolean</p><p>（2）引用数据类型</p><p>​        ①类：</p><p>​            例如：String、Student、Circle、System、Scanner、Math…</p><p>​        ②接口：</p><p>​        ③数组：</p><p>​            例如：int[]，String[]，char[]，int[][]</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">这里把<span class="keyword">int</span>[]看成数组类型，是一种引用数据类型，右边赋值的是一个数组的对象</span><br><span class="line"></span><br><span class="line">元素的数据类型：<span class="keyword">int</span></span><br><span class="line">数组的数据类型：<span class="keyword">int</span>[]</span><br></pre></td></tr></table></figure><h2 id="如何为属性赋值"><a href="#如何为属性赋值" class="headerlink" title="如何为属性赋值"></a>如何为属性赋值</h2><ul><li>在声明属性时显式赋值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 数据类型  属性名 = 值; <span class="comment">//属性有初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">char</span> gender = <span class="string">'男'</span>;<span class="comment">//显式赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStudent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s1.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s1.gender);<span class="comment">//男</span></span><br><span class="line">        </span><br><span class="line">        s1.name = <span class="string">"小薇"</span>;<span class="comment">//修改属性的默认值</span></span><br><span class="line">        s1.gender = <span class="string">'女'</span>;<span class="comment">//修改属性的初始值</span></span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s1.name);<span class="comment">//小薇</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s1.gender);<span class="comment">//女</span></span><br><span class="line">        </span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s2.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s2.gender);<span class="comment">//男</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建对象之后赋值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 数据类型  属性名; <span class="comment">//属性有默认值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span>  类名();</span><br><span class="line"></span><br><span class="line"><span class="comment">//为对象的属性赋值</span></span><br><span class="line">对象名.属性名 = 值;</span><br></pre></td></tr></table></figure><p><strong>如何访问属性的值</strong></p><ul><li>在本类的方法中访问</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;<span class="comment">//直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在其他类的方法中访问</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCircle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Circle c1 = <span class="keyword">new</span> Circle();</span><br><span class="line">        <span class="keyword">double</span> area = <span class="number">3.14</span> * c1.radius * c1.radius;<span class="comment">//对象名.属性名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性的特点"><a href="#属性的特点" class="headerlink" title="属性的特点"></a>属性的特点</h2><ul><li><p>属性有默认值</p><p>基本数据类型：</p><p>​    byte,short,int,long：0</p><p>​    float，double：0.0</p><p>​    char：\u0000</p><p>​    boolean：false</p><p>引用数据类型：</p><p>​    null</p></li><li><p>每一个对象的属性是独立，互不干扰</p></li></ul><h2 id="对象属性的内存图"><a href="#对象属性的内存图" class="headerlink" title="对象属性的内存图"></a>对象属性的内存图</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">char</span> gender = <span class="string">'男'</span>;<span class="comment">//显式赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStudent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s1.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s1.gender);<span class="comment">//男</span></span><br><span class="line">        </span><br><span class="line">        s1.name = <span class="string">"小薇"</span>;</span><br><span class="line">        s1.gender = <span class="string">'女'</span>;</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s1.name);<span class="comment">//小薇</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s1.gender);<span class="comment">//女</span></span><br><span class="line">        </span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s2.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s2.gender);<span class="comment">//男</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/object.png" alt="object"></p><h1 id="类的成员之二：方法"><a href="#类的成员之二：方法" class="headerlink" title="类的成员之二：方法"></a>类的成员之二：方法</h1><h2 id="方法的概念"><a href="#方法的概念" class="headerlink" title="方法的概念"></a>方法的概念</h2><p>方法也叫函数，是一个独立功能的定义，是一个类中最基本的功能单元。</p><p>把一个功能封装为方法的目的是，可以实现代码重用，从而简化代码。</p><p>方法的使用原则：</p><p>（1）必须先声明后使用</p><p>​        类，变量，方法都要先声明后使用</p><p>（2）不调用不执行，调用一次执行一次。</p><h2 id="方法的语法"><a href="#方法的语法" class="headerlink" title="方法的语法"></a>方法的语法</h2><p><strong>方法的声明格式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 返回值类型  方法名(【形参列表】)&#123;</span><br><span class="line">        方法体：实现功能的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>（1）【修饰符】：</p><p>（2）返回值类型：</p><p>​        ①void：表示无返回值</p><p>​        ②非void：所有的Java数据类型都可以</p><p>（3）方法名：能很好的体现方法的功能</p><p>​        命名的规范：①见名知意②从第二个单词开始首字母大写</p><p>（4）【形参列表】：</p><p>​        在完成这个方法的功能时，需要一些数据，这些数据要由“调用者”来决定，那我们就可以设计形参。</p><p>​        语法格式：</p><p>​            ()：无参，空参</p><p>​            (数据类型  形参名)：一个形参</p><p>​            (数据类型1  形参名1,  ……,   数据类型n  形参名n)：n个形参</p><p>（5）方法体：实现方法的功能，最好一个方法就完成一个独立的功能。</p><p><strong>方法的调用格式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本类同级别方法调用：直接调用</span></span><br><span class="line">方法名(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在其他类的方法中调用</span></span><br><span class="line">对象名.方法名(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">如果方法有返回值，需要用变量接收</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>（1）是否传实参</p><p>​        看被调用的方法是否有形参</p><p>（2）是否接收返回值</p><p>​        看被调用的方法是否是void，如果是void，就不需要也不能接收，如果不是void，就可以接收。</p><p><strong>方法的声明与调用的代码示例</strong></p><ul><li>无参无返回值方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"半径："</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printInfo();<span class="comment">//本类中调用无参无返回值方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"半径："</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCircle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Circle c1 = <span class="keyword">new</span> Circle();</span><br><span class="line">        c1.printInfo(); <span class="comment">//其他类中调用无参无返回值方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无参有返回值方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//  System.out.println("半径：" + radius + "，面积：" + getArea());//本类中调用无参有返回值</span></span><br><span class="line">       <span class="keyword">double</span> area = getArea();<span class="comment">//本类中调用无参有返回值</span></span><br><span class="line">        System.out.println(<span class="string">"半径："</span> + radius + <span class="string">"，面积："</span> + area);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCircle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Circle c1 = <span class="keyword">new</span> Circle();</span><br><span class="line">        <span class="keyword">double</span> area = c1.getArea();</span><br><span class="line">        System.out.println(<span class="string">"面积："</span> + area);</span><br><span class="line">        <span class="comment">//或</span></span><br><span class="line">        System.out.println(<span class="string">"面积："</span> + c1.getArea());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有参无返回值方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicTools</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printRectange</span><span class="params">(<span class="keyword">int</span> line, <span class="keyword">int</span> column, <span class="keyword">char</span> sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=line; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=column; j++)&#123;</span><br><span class="line">                Sytem.out.print(sign);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printRectange(<span class="number">5</span>,<span class="number">10</span>,<span class="string">'%'</span>);<span class="comment">//本类中调用有参无返回值方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicTools</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printRectange</span><span class="params">(<span class="keyword">int</span> line, <span class="keyword">int</span> column, <span class="keyword">char</span> sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=line; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=column; j++)&#123;</span><br><span class="line">                Sytem.out.print(sign);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GraphicTools tools = <span class="keyword">new</span> GraphicTools();</span><br><span class="line">        tools.printRectange(<span class="number">5</span>,<span class="number">10</span>,<span class="string">'%'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有参有返回值方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">7</span>;</span><br><span class="line">        System.out.println(x + <span class="string">"+"</span> + y + <span class="string">"="</span> + sum(x,y));<span class="comment">//本类中调用有参有返回值的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyMath my = <span class="keyword">new</span> MyMath();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(x + <span class="string">"+"</span> + y + <span class="string">"="</span> + my.sum(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法声明与调用的原则</strong></p><p>（1）方法必须先声明后调用</p><blockquote><p>如果调用方法时，如果方法名写错或调用一个不存在的方法，编译会报错</p></blockquote><p>（2）方法声明的位置必须在类中方法外</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        方法<span class="number">2</span>()&#123;  <span class="comment">//错误</span></span><br><span class="line">        </span><br><span class="line">   &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    方法<span class="number">2</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）方法的调用的位置有要求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    调用方法  <span class="comment">//错误位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        调用方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）方法的调用格式要与方法的声明格式对应</p><p>​        ①是否要加“对象.”：看是否在本类中，还是其他类中</p><p>​        ②是否要接收返回值：看被调用方法是否是void</p><p>​        ③是否要传实参：看被调用方法是有形参列表</p><h2 id="方法的重载Overload"><a href="#方法的重载Overload" class="headerlink" title="方法的重载Overload"></a>方法的重载Overload</h2><blockquote><p>在同一个类中，出现了两个或多个的方法，它们的方法名称相同，形参列表不同，这样的形式称为方法的重载。和返回值类型无关。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求两个整数的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求三个整数的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(max(a,b),c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求两个小数的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法的参数传递机制"><a href="#方法的参数传递机制" class="headerlink" title="方法的参数传递机制"></a>方法的参数传递机制</h2><p>Java中方法的参数传递机制：值传递</p><p>（1）形参是基本数据类型时，实参给形参传递数据值，是copy的形式，形参对值的修改不影响实参。<br>（2）形参是引用数据类型时，实参给形参传递地址值，形参对对象的属性的修改，会影响实参对象的属性值，因为此时形参和实参就是指向同一个对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[] args)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">        swap(x,y);<span class="comment">//调用完之后，x与y的值不变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(MyData my)</span></span>&#123;</span><br><span class="line">        my.num *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyData m = <span class="keyword">new</span> MyData();</span><br><span class="line">        m.num = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        change(m);<span class="comment">//调用完之后，m对象的num属性值就变为2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p><strong>可变参数</strong></p><p>形参列表中出现了<code>数据类型... 形参名</code>形式的形参，就是可变参数</p><p><strong>包含可变参数的方法的调用原则</strong></p><p>可变参数的形参部分，可以传入0～n个对应类型的实参，也可以传入对应类型的数组对象</p><p><strong>可变参数的声明原则</strong></p><ul><li>一个方法只能包含一个可变参数</li><li>可变参数必须是形参列表的最后一个</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数传入个数0～n个</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VarParam</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 调用方式一创建数组传入</span></span><br><span class="line">    <span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    System.out.println(<span class="string">"0个元素的累加和："</span> + sum(arr1));<span class="comment">//0</span></span><br><span class="line">    <span class="keyword">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">"5个元素的累加和："</span> + sum(arr2));<span class="comment">//15</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用方式二传入不同个数的参数</span></span><br><span class="line">    System.out.println(<span class="string">"0个元素的累加和："</span> + sum());<span class="comment">//0</span></span><br><span class="line">    System.out.println(<span class="string">"1个元素的累加和："</span> + sum(<span class="number">3</span>));<span class="comment">//3</span></span><br><span class="line">    System.out.println(<span class="string">"0个元素的累加和："</span> + sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));<span class="comment">//15</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 可变参数nums当成数组用</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">      sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非可变参数"><a href="#非可变参数" class="headerlink" title="非可变参数"></a>非可变参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数传入个数1～n个</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VarParam</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"1个元素的累加和："</span> + max(<span class="number">5</span>));<span class="comment">//5</span></span><br><span class="line">    System.out.println(<span class="string">"5个元素的累加和："</span> + max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>));<span class="comment">//8</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//求1～n个整数参数的最大值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span>... nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">// sum1就是非可变参数，至少传入一个参数</span></span><br><span class="line">    <span class="keyword">int</span> max = num1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(max &gt; num[i])&#123;</span><br><span class="line">        max = num[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h1><blockquote><p>元素类型是引用数据类型的数组称为对象数组。因为元素中存储的是对象。</p></blockquote><p>一维数组：</p><p>1、元素是基本数据类型</p><p>2、元素是引用数据类型，也称为对象数组，即数组的元素是对象</p><blockquote><p>注意：对象数组，首先要创建数组对象本身，即确定数组的长度，然后再创建每一个元素对象，如果不创建，数组的元素的默认值就是null，所以很容易出现空指针异常NullPointerException。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> year;</span><br><span class="line"><span class="keyword">int</span> month;</span><br><span class="line"><span class="keyword">int</span> day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyDate[] arr = <span class="keyword">new</span> MyDate[<span class="number">3</span>];<span class="comment">//创建数组对象本身，指定数组的长度</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> MyDate();<span class="comment">//每一个元素要创建对象</span></span><br><span class="line">            arr[i].year = <span class="number">1990</span> + i;</span><br><span class="line">            arr[i].month = <span class="number">1</span> + i;</span><br><span class="line">            arr[i].day = <span class="number">1</span> + i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象数组的内存图"><a href="#对象数组的内存图" class="headerlink" title="对象数组的内存图"></a>对象数组的内存图</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.delivr.net/gh/uncle-he/blog-resource/img/object-array.png" alt="objectArray"></p>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2020/05/31/java-array/"/>
      <url>/2020/05/31/java-array/</url>
      
        <content type="html"><![CDATA[<h1 id="数组的相关概念"><a href="#数组的相关概念" class="headerlink" title="数组的相关概念"></a>数组的相关概念</h1><h2 id="数组的相关概念-1"><a href="#数组的相关概念-1" class="headerlink" title="数组的相关概念"></a>数组的相关概念</h2><blockquote><p> 所谓<code>数组(Array)</code>，就是相同数据类型的元素按一定顺序排列的集合，就是把有限个类型相同的变量用一个名字命名，以便统一管理他们，然后用编号区分他们，这个名字称为<code>数组名</code>，编号称为<code>下标或索引(index)</code>。组成数组的各个变量称为数组的<code>元素(element)</code>。数组中元素的个数称为<code>数组的长度(length)</code>。</p></blockquote><p>例如：</p><p>​    int s1_score = 80; </p><p>​    int s2_score = 90; </p><p>​    int s3_score = 87; </p><p>​    …..</p><p>​    int[] scores = {80, 90, 87, 68, 99, 100, 79, 96};  </p><p>​    元素1：scores[0]=80; </p><p>​    数组的长度为8</p><h2 id="数组的特点"><a href="#数组的特点" class="headerlink" title="数组的特点"></a>数组的特点</h2><ul><li><p>数组的长度一旦确定就不能修改</p></li><li><p>创建数组对象会在内存中开辟一整块连续的空间。而数组名中引用的是这块连续空间的首地址。</p></li><li><p>遍历数组和获取某个元素的速度快，因为可以通过数组名+下标，直接定位到任意一个元素。</p></li></ul><h2 id="数组类型与数组元素的类型"><a href="#数组类型与数组元素的类型" class="headerlink" title="数组类型与数组元素的类型"></a>数组类型与数组元素的类型</h2><p>数组中的元素可以是任何数据类型，包括基本类型和引用类型</p><p>数组属引用类型，把数组看成对象(object)，数组中的每个元素相当于该对象的成员变量。</p><p>例如：</p><p>（1）基本数据类型元素的数组</p><p>​        int[] scores = {80, 90, 87, 68, 99, 100, 79, 96};</p><p>​        scores数组的类型是：int[]，元素的类型是int</p><p>​        scores是一个对象，scores[0],scores[1]等元素是scores对象的成员变量</p><p>（2）引用数据类型元素的数组</p><p>​        String[] strings = {“hello”,”java”,”world”,”array”};</p><p>​        strings数组的类型是：String[]，元素的类型是String</p><p>​        strings是一个对象，strings[0]，strings[1]等元素是strings对象的成员变量</p><h2 id="数组的分类"><a href="#数组的分类" class="headerlink" title="数组的分类"></a>数组的分类</h2><p>数组按照维度分为：一维数组、二维数组、多维数组</p><p>数组按照元素的数据类型分：基本数据类型元素的数据，引用数据类型元素的数组（也称为对象数组）</p><h1 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h1><h2 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h2><p>元素数据类型[] 数组名 = new 元素数据类型[]{元素1的值，元素2的值，….};</p><p>说明：</p><p>（1）静态初始化时数组的长度由{}中罗列的元素的个数决定</p><p>（2）静态初始化时[]中不可以再写长度</p><p>（3）如果声明与初始化一起，可以简写：</p><p>元素数据类型[] 数组名 = {元素1的值，元素2的值，….};</p><p>例如：</p><p>​    int[] arr = {1, 2, 3, 4, 5, 6};</p><p>​    String[] arr = {“hello”, ”java”, ”world”};</p><h2 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h2><p>元素数据类型 数组名 = new 元素数据类型[数组的长度];</p><p>说明：</p><p>（1）动态初始化时数组的长度在[]中指定，而且必须指定</p><p>（2）动态初始化时每一个元素有默认值</p><p>注意：</p><p>（1）无论是静态初始化还是动态初始化必须确定数组长度。</p><p>动态初始化在创建数组对象时，显式指明长度，静态初始化，由列出的元素个数确定数组的长度</p><p>（2）数组的长度一旦确定，不可改变</p><p>（3）只指定数组长度，没有为元素手动赋值，那么元素有默认值</p><ul><li><p>基本数据类型</p><p>byte,short,int,long：0</p><p>float,double：0.0</p><p>char：\u0000</p><p>boolean：false</p></li><li><p>引用数据类型</p><p>统统都是null</p></li></ul><p>（4）元素的数据类型是引用数据类型，在刚刚动态初始化后，元素的值是null，并没有创建元素的对象，元素的对象需要单独创建。</p><p>例如：</p><p>Student[] arr = new Student[3];</p><p>此时arr[i]为null，arr[i]并没有指向任何学生对象，此时arr[i].属性或arr[i].方法都会报空指针异常</p><p>String[] arr = new String[3];</p><p>此时arr[i]也为null，arr[i]中并没有存储任何字符串对象</p><h2 id="元素的访问与赋值"><a href="#元素的访问与赋值" class="headerlink" title="元素的访问与赋值"></a>元素的访问与赋值</h2><p>数组的元素表示方式：数组名[下标]</p><p>下标的范围是：[0,数组的长度)  或[0,数组的长度-1]</p><p>数组元素的赋值：数组名[下标] = 值;</p><p>例如：</p><p>nums[0] = 15;</p><p>students[1] = new Student(“大美女”);</p><h2 id="数组的长度"><a href="#数组的长度" class="headerlink" title="数组的长度"></a>数组的长度</h2><p>数组名.length</p><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><h3 id="普通for循环遍历"><a href="#普通for循环遍历" class="headerlink" title="普通for循环遍历"></a>普通for循环遍历</h3><p>for(int i = 0;  i&lt;数组名.length; i++) {</p><p>​    System.out.println(数组名[i]);</p><p>}</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增强for循环遍历"><a href="#增强for循环遍历" class="headerlink" title="增强for循环遍历"></a>增强for循环遍历</h3><p>for(元素的数据类型  变量名 : 被遍历的数组名) {</p><p>​    System.out.println(变量名);  //每循环一次，变量名代表一个元素</p><p>}</p><p>区别：</p><ul><li><p>普通for可以修改数组元素的值，增强for不行；</p></li><li><p>普通for可以获取下标信息，增强for没有下标信息；</p></li><li><p>仅遍历时增强for效率高</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">"孙悟空"</span>, <span class="string">"唐僧"</span> , <span class="string">"猪八戒"</span>, <span class="string">"沙悟净"</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String name : names) &#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的内存分析"><a href="#数组的内存分析" class="headerlink" title="数组的内存分析"></a>数组的内存分析</h2><p>数组对象是在堆中创建的，元素相当于数组对象的成员变量。创建数组对象会在堆中开辟连续的空间</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/array1.png" alt="array"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/array2.png" alt="array"></p><h1 id="数组的相关算法"><a href="#数组的相关算法" class="headerlink" title="数组的相关算法"></a>数组的相关算法</h1><h2 id="数组中找最值"><a href="#数组中找最值" class="headerlink" title="数组中找最值"></a>数组中找最值</h2><h3 id="数组中找最大-小值"><a href="#数组中找最大-小值" class="headerlink" title="数组中找最大/小值"></a>数组中找最大/小值</h3><p>思路：</p><p>（1）先假设第一个元素最大/最小</p><p>（2）然后用max/min与后面的元素一一比较</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//找最大值</span></span><br><span class="line"><span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">        max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组中找最值及其下表"><a href="#数组中找最值及其下表" class="headerlink" title="数组中找最值及其下表"></a>数组中找最值及其下表</h3><p>思路：</p><p>（1）先假设第一个元素最大/最小</p><p>（2）然后用max/min与后面的元素一一比较</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//找最大值</span></span><br><span class="line"><span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">        max = arr[i];</span><br><span class="line">        index = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//找最大值</span></span><br><span class="line"><span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; arr[maxIndex])&#123;</span><br><span class="line">        maxIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"最大值："</span> + arr[maxIndex]);</span><br></pre></td></tr></table></figure><h2 id="数组统计：求总和、均值、统计偶数个数等"><a href="#数组统计：求总和、均值、统计偶数个数等" class="headerlink" title="数组统计：求总和、均值、统计偶数个数等"></a>数组统计：求总和、均值、统计偶数个数等</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//求总和、均值</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//因为0加上任何数都不影响结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    sum += arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> avg = (<span class="keyword">double</span>)sum/arr.length;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求总乘积</span></span><br><span class="line"><span class="keyword">long</span> result = <span class="number">1</span>;<span class="comment">//因为1乘以任何数都不影响结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    result *= arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//统计偶数个数</span></span><br><span class="line"><span class="keyword">int</span> even = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        even++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h2><ul><li>借助一个新数组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)先创建一个新数组</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)复制元素</span></span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newArr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[len -<span class="number">1</span> - i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)舍弃旧的，让arr指向新数组</span></span><br><span class="line">arr = newArr;<span class="comment">//这里把新数组的首地址赋值给了arr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首尾对应位置交换</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)计算要交换的次数：  次数 = arr.length/2</span></span><br><span class="line"><span class="comment">//(2)首尾交换</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length/<span class="number">2</span>; i++)&#123;<span class="comment">//循环的次数就是交换的次数</span></span><br><span class="line">    <span class="comment">//首  与  尾交换</span></span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[arr.length-<span class="number">1</span>-i];</span><br><span class="line">arr[arr.length-<span class="number">1</span>-i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p><strong>应用场景：</strong></p><ul><li>扩容</li><li>备份</li><li>截取</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要把arr数组扩容，增加1个位置</span></span><br><span class="line"><span class="comment">//(1)先创建一个新数组，它的长度 = 旧数组的长度+1</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)复制元素</span></span><br><span class="line"><span class="comment">//注意：i&lt;arr.length   因位arr比newArr短，避免下标越界</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)把新元素添加到newArr的最后</span></span><br><span class="line">newArr[newArr.length-<span class="number">1</span>] = 新值;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)如果下面继续使用arr，可以让arr指向新数组</span></span><br><span class="line">arr = newArr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 备份</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建一个长度和原来的数组一样的新数组</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、复制元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 截取</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> end = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建一个新数组，新数组的长度 = end-start + 1;</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[end-start+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、赋值元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newArr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[start + i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newArr.length; i++)&#123;</span><br><span class="line">    System.out.println(newArr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul><li>顺序查找</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] == value)&#123;</span><br><span class="line">        index = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(value + <span class="string">"不存在"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(value + <span class="string">"的下标是"</span> + index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>二分查找</p><p>对数组有要求，元素必须有大小顺序</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用二分查找法在数组中查找 int value = 2;是否存在，如果存在显示下标，不存在显示不存在。</span></span><br><span class="line"><span class="comment">已知数组：int[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam2</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;<span class="comment">//数组是有序的</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="comment">//找到结束</span></span><br><span class="line">            <span class="keyword">if</span>(value == arr[mid])&#123;</span><br><span class="line">                index = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//没找到</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; arr[mid])&#123;<span class="comment">//往右继续查找</span></span><br><span class="line">                <span class="comment">//移动左边界，使得mid往右移动</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value &lt; arr[mid])&#123;<span class="comment">//往左边继续查找</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(value + <span class="string">"不存在"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(value + <span class="string">"的下标是"</span> + index);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li>冒泡排序</li><li>简单的直接排序</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;<span class="comment">//外循环的次数 = 轮数 = 数组的长度-1</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第1轮，i=1,从左到右两两比较，arr[0]与arr[1]。。。。。arr[3]与arr[4]</span></span><br><span class="line"><span class="comment">    第2轮，i=2,从左到右两两比较，arr[0]与arr[1]。。。。。arr[2]与arr[3]</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    arr[j]与arr[j+1]比较</span></span><br><span class="line"><span class="comment">    找两个关键点：（1）j的起始值：0（2）找j的终止值，依次是3,2,1,0，得出j&lt;arr.length-i</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arr.length-i; j++)&#123;</span><br><span class="line">        <span class="comment">//两两比较</span></span><br><span class="line">        <span class="comment">//从小到大，说明前面的比后面的大，就交换</span></span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单的直接排序</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;<span class="comment">//外循环的次数 = 轮数 = 数组的长度-1</span></span><br><span class="line">    <span class="comment">//（1）找出本轮未排序元素中的最值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    未排序元素：</span></span><br><span class="line"><span class="comment">    第1轮：i=1,未排序，[0,4]</span></span><br><span class="line"><span class="comment">    第2轮：i=2,未排序，[1,4]</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    每一轮未排序元素的起始下标：0,1,2,3，正好是i-1的</span></span><br><span class="line"><span class="comment">    未排序的后面的元素依次：</span></span><br><span class="line"><span class="comment">    第1轮：[1,4]  j=1,2,3,4</span></span><br><span class="line"><span class="comment">    第2轮：[2,4]  j=2,3,4</span></span><br><span class="line"><span class="comment">    第3轮：[3,4]  j=3,4</span></span><br><span class="line"><span class="comment">    第4轮：[4,4]  j=4</span></span><br><span class="line"><span class="comment">    j的起点是i，终点都是4</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> max = arr[i-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> index = i-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;arr.length; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; max)&#123;</span><br><span class="line">            max = arr[j];</span><br><span class="line">            index = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（2）如果这个最值没有在它应该在的位置，就与这个位置的元素交换</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第1轮，最大值应该在[0]</span></span><br><span class="line"><span class="comment">    第2轮，最大值应该在[1]</span></span><br><span class="line"><span class="comment">    第3轮，最大值应该在[2]</span></span><br><span class="line"><span class="comment">    第4轮，最大值应该在[3]</span></span><br><span class="line"><span class="comment">    正好是i-1的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(index != i-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//交换arr[i-1]与arr[index]</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i-<span class="number">1</span>];</span><br><span class="line">        arr[i-<span class="number">1</span>] = arr[index];</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">System.out.print(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><p>二维数组的标记：[][]</p><h2 id="相关的表示方式"><a href="#相关的表示方式" class="headerlink" title="相关的表示方式"></a>相关的表示方式</h2><p>（1）二维数组的长度/行数： </p><p>​    二维数组名.length</p><p>（2）二维数组的其中一行：</p><p>​    二维数组名[行下标]</p><p>​    行下标的范围：[0, 二维数组名.length-1]</p><p>（3）每一行的列数：</p><p>​    二维数组名[行下标].length</p><p>​       因为二维数组的每一行是一个一维数组</p><p>（4）每一个元素</p><p>​    二维数组名[行下标][列下标]</p><h2 id="二维数组的声明和初始化"><a href="#二维数组的声明和初始化" class="headerlink" title="二维数组的声明和初始化"></a>二维数组的声明和初始化</h2><p>二维数组的声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐</span></span><br><span class="line">元素的数据类型[][] 二维数组的名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐</span></span><br><span class="line">元素的数据类型  二维数组名[][];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//不推荐</span></span><br><span class="line">元素的数据类型[]  二维数组名[];</span><br></pre></td></tr></table></figure><p>面试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] x, y[];</span><br><span class="line"><span class="comment">//x是一维数组，y是二维数组</span></span><br></pre></td></tr></table></figure><p>二维数组的初始化</p><p>（1）静态初始化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">二维数组名 = <span class="keyword">new</span> 元素的数据类型[][]&#123;</span><br><span class="line">&#123;第一行的值列表&#125;, </span><br><span class="line">&#123;第二行的值列表&#125;,</span><br><span class="line">...</span><br><span class="line">&#123;第n行的值列表&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] arr;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果声明与静态初始化一起完成</span></span><br><span class="line">元素的数据类型[][] 二维数组的名称 = &#123;</span><br><span class="line">&#123;第一行的值列表&#125;, </span><br><span class="line">&#123;第二行的值列表&#125;,</span><br><span class="line">...</span><br><span class="line">&#123;第n行的值列表&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>（2）动态初始化（不规则：每一行的列数可能不一样）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//（1）先确定总行数</span></span><br><span class="line">二维数组名 = <span class="keyword">new</span> 元素的数据类型[总行数][];</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）再确定每一行的列数</span></span><br><span class="line">二维数组名[行下标] = <span class="keyword">new</span> 元素的数据类型[该行的总列数];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)再为元素赋值</span></span><br><span class="line">二维数组名[行下标][列下标] = 值;</span><br></pre></td></tr></table></figure><p>（3）动态初始化（规则：每一行的列数是相同的）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//（1）确定行数和列数</span></span><br><span class="line">二维数组名 = <span class="keyword">new</span> 元素的数据类型[总行数][每一行的列数];</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）再为元素赋值</span></span><br><span class="line">二维数组名[行下标][列下标] = 值;</span><br></pre></td></tr></table></figure><h2 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;二维数组名.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;二维数组名[i].length; j++)&#123;</span><br><span class="line">        System.out.print(二维数组名[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">    System.out.print(arr[i][j]);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维数组的内存分析"><a href="#二维数组的内存分析" class="headerlink" title="二维数组的内存分析"></a>二维数组的内存分析</h2><p>（1）int[][] arr;</p><p>（2）arr = new int[5];</p><p>（3）arr[0] = new int[4];</p><p>（4）arr[0][1]= 12;</p><p>（5）int[][] arr = new int[4][5];</p><p>（6）Student[][]  arr = new Student[6][];</p><p>（7）arr[0] = new Student[8];</p><p>（8）arr[0][1] = new Student(“张三”,”10086”);</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/2array1.png" alt="array"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/2array2.png" alt="array"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/2array3.png" alt="array"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/2array4.png" alt="array"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/2array5.png" alt="array"></p>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
