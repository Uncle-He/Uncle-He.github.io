<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IO流</title>
      <link href="/2020/06/21/java-io/"/>
      <url>/2020/06/21/java-io/</url>
      
        <content type="html"><![CDATA[<h1 id="IO流概念"><a href="#IO流概念" class="headerlink" title="IO流概念"></a>IO流概念</h1><p>I/O是输入/输出(Input/Output) 的缩写， I/O技术是非常实用的技术，如读/写文件，网络通讯等等。Java的IO支持通过java.io包下的类和接口来支持。</p><ul><li><p>I(Input输入)，从别的地方（文件、键盘、网络、内存等）读取数据到当前程序中</p></li><li><p>O(Output输出)，从程序把数据写/输出到文件、屏幕（控制台）、网络、内存等中</p></li></ul><h1 id="java-io-File类"><a href="#java-io-File类" class="headerlink" title="java.io.File类"></a>java.io.File类</h1><p>File类是java.io包下代表与平台无关的文件和目录，也就是说如果希望在程序中操作文件和目录都可以通过File类来完成，File类能新建、删除、重命名文件和目录。</p><p>在API中File的解释是文件和目录路径名的抽象表示形式，即File类是文件或目录的路径，而不是文件本身，因此File类不能直接访问文件内容本身，如果需要访问文件内容本身，则需要使用输入/输出流。</p><h2 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h2><p>File类可以使用文件路径字符串来创建File实例，该文件路径字符串既可以是绝对路径，也可以是相对路径，默认情况下，系统总是依据用户的工作路径来解释相对路径，这个路径由系统属性“user.dir”指定，通常也就是运行Java虚拟机时所作的路径。</p><ul><li>String getName()：返回此File对象的所表示的文件名（返回最后一级）</li><li>String getPath()：返回此File对象所对应的路径名。</li><li>String getAbsolutePath()：返回此File对象所对应的绝对路径名。</li><li>File getAbsoluteFile()：返回此File对象所对应的绝对路径名所对应的File对象</li><li>String getCanonicalPath()：返回此File对象所对应的规范路径名。所谓规范路径名，即对路径中的“..”等进行解析后的路径名。</li><li>File getCanonicalFile()：返回此File对象所对应的规范路径名所对应的File对象</li><li>String getParent()：返回此File对象的父目录名</li><li>File getParentFile()：返回此File对象的父目录名所对应的File对象</li></ul><h2 id="获取常规信息等方法"><a href="#获取常规信息等方法" class="headerlink" title="获取常规信息等方法"></a>获取常规信息等方法</h2><p><strong>文件和目录检测方法：</strong></p><ul><li><p>boolean exists()：判断File对象对应的文件或目录是否存在</p></li><li><p>canRead()：判断File对象对应的文件或目录是否可读</p></li><li><p>canWrite()：判断File对象对应的文件或目录是否可写</p></li><li><p>isHidden()：判断File对象对应的文件或目录是否是否隐藏</p></li><li><p>isFile()：判断File对象对应的是否是文件</p></li><li><p>isDirectory()：判断File对象对应的是否是目录</p></li><li><p>isAbsolute()：判断File对象对应的文件或目录是否是绝对路径</p></li></ul><p><strong>获取常规信息：</strong></p><ul><li><p>long lastModified()：返回File对象对应的文件或目录的最后修改时间（毫秒值）</p></li><li><p>long length()：返回File对象对应的文件的内容的长度（字节数），<strong>如果File对象对应的是目录，则结果是不确定的</strong></p></li></ul><p>以上都是对应于File对象的属性信息，如果File对象对应的文件或目录不存在，返回的都是对应属性的默认值，例如：length()返回为0，isFile()和isDirectory()返回为false等。</p><h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><ol><li><p>创建文件：boolean createNewFile() throws IOException</p><p>如果指定的文件不存在并成功地创建，则返回 true；如果指定的文件已经存在，则返回 false。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">  File file = <span class="keyword">new</span> File(<span class="string">"d:/unclehe/javase/HelloIO.java"</span>);</span><br><span class="line">  file.createNewFile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建临时文件，通常会结合deleteOnExit()使用</li></ol><ul><li><p>public static File createTempFile(String prefix,String suffix) throws IOException在默认临时文件目录中创建一个空文件，使用给定前缀和后缀生成其名称。调用此方法等同于调用 createTempFile(prefix, suffix, null)。</p><ul><li>n prefix - 用于生成文件名的前缀字符串；必须至少三个字符。</li><li>suffix - 用于生成文件名的后缀字符串；如果为 null，默认为 “.tmp”</li></ul></li><li><p>public static File createTempFile(String prefix,String suffix,File directory)throws IOException在指定目录中创建一个新的空文件，使用给定的前缀和后缀字符串生成其名称。</p><ul><li>prefix - 用于生成文件名的前缀字符串；必须至少三个字符。</li><li>suffix - 用于生成文件名的后缀字符串；如果为 null，默认为 “.tmp”</li><li>directory - 将创建的文件所在的目录；如果使用默认临时文件目录，则该参数为 null </li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">  File tempFile = File.createTempFile(<span class="string">"Hello"</span>, <span class="string">".tmp"</span>);</span><br><span class="line">  System.out.println(tempFile.getAbsolutePath());</span><br><span class="line">  <span class="comment">//C:\Users\Irene\AppData\Local\Temp\Hello2541030191749214481.tmp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><ul><li><p>boolean delete() 当且仅当成功删除文件时，返回 true；否则返回 false。</p></li><li><p>public void deleteOnExit()：当退出JVM时，删除文件，一般用于删除临时文件</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteOnExit</span><span class="params">()</span>：当退出JVM时，删除文件，一般用于删除临时文件</span></span><br><span class="line"><span class="function">  @Test</span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  File file = <span class="keyword">new</span> File(<span class="string">"d:/unclehe/javase/HelloIO.java"</span>);</span><br><span class="line">  file.delete();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">  File tempFile = File.createTempFile(<span class="string">"Hello"</span>, <span class="string">".tmp"</span>);</span><br><span class="line">  <span class="comment">//....省略代码</span></span><br><span class="line">  tempFile.deleteOnExit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><ul><li>boolean renameTo(File dest)：此方法行为的许多方面都是与平台有关的：重命名操作无法将一个文件从一个文件系统移动到另一个文件系统，该操作不是不可分的，如果已经存在具有目标抽象路径名的文件，那么该操作可能无法获得成功。应该始终检查返回值，以确保重命名操作成功。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span>&#123;</span><br><span class="line">  File src = <span class="keyword">new</span> File(<span class="string">"d:/unclehe/javase/HelloIO.java"</span>);</span><br><span class="line">  File dest = <span class="keyword">new</span> File(<span class="string">"d:/unclehe/javase/HelloFile.java"</span>);</span><br><span class="line">  src.renameTo(dest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  File src = <span class="keyword">new</span> File(<span class="string">"d:/unclehe/javase/HelloIO.java"</span>);</span><br><span class="line">  File dest = <span class="keyword">new</span> File(<span class="string">"e:/HelloFile.java"</span>);</span><br><span class="line">  <span class="comment">//D盘和E盘相同的文件系统可以成功，例如都是NTFS。</span></span><br><span class="line">  src.renameTo(dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作目录"><a href="#操作目录" class="headerlink" title="操作目录"></a>操作目录</h2><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><ul><li><p>boolean mkdir() ：必须确保父目录存在，否则创建失败</p></li><li><p>boolean mkdirs()：如果父目录链不存在，会一同创建父目录链</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  File dir = <span class="keyword">new</span> File(<span class="string">"d:/unclehe/javase/io"</span>);</span><br><span class="line">  dir.mkdir();</span><br><span class="line">  <span class="comment">//如果d:/atguigu/javase不存在不会报错，只是没创建成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  File dir = <span class="keyword">new</span> File(<span class="string">"d:/unclehe/javase/io"</span>);</span><br><span class="line">  dir.mkdirs();</span><br><span class="line">  <span class="comment">//如果d:/atguigu/javase不存在，会一并创建</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="列出目录内容"><a href="#列出目录内容" class="headerlink" title="列出目录内容"></a>列出目录内容</h3><ul><li><p>public String[] list()列出当前目录的下级目录或文件的名称</p></li><li><p>public File[] listFiles() 列出当前目录的下级的目录或文件对应的File对象  </p><p>配合递归可以列出下级的下级….</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  File dir = <span class="keyword">new</span> File(<span class="string">"d:/unclehe"</span>);</span><br><span class="line">  listSubFiles(dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listSubFiles</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dir != <span class="keyword">null</span> &amp;&amp; dir.isDirectory()) &#123;</span><br><span class="line">    File[] listFiles = dir.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (listFiles != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (File sub : listFiles) &#123;</span><br><span class="line">        listSubFiles(sub);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>public File[ ] listFiles (FileFilter filter) 返回所有满足指定过滤器的文件和目录。如果给定 filter 为 null，则接受所有路径名。否则，当且仅当在路径名上调用过滤器的 FileFilter.accept(java.io.File) 方法返回 true 时，该路径名才满足过滤器。如果当前File对象不表示一个目录，或者发生 I/O 错误，则返回 null。</li><li>public File[ ] listFiles (FilenameFilter filter) 返回所有满足指定过滤器的文件和目录。如果给定 filter 为 null，则接受所有路径名。否则，当且仅当在路径名上调用过滤器的 FilenameFilter.accept(java.io.File, java.lang.String) 方法返回 true 时，该路径名才满足过滤器。如果当前File对象不表示一个目录，或者发生 I/O 错误，则返回 null。</li><li>public static File[ ] listRoots() 列出可用的文件系统根。</li></ul><h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><ul><li>boolean delete()：只能删除空目录。否则需要先将目录下的所有内容删除才能将该目录删除。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  File dir = <span class="keyword">new</span> File(<span class="string">"D:/unclehe/javase"</span>);</span><br><span class="line">  forceDeleteDir(dir);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceDeleteDir</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (dir != <span class="keyword">null</span> &amp;&amp; dir.isDirectory()) &#123;</span><br><span class="line">    File[] listFiles = dir.listFiles();</span><br><span class="line">    <span class="keyword">if</span>(listFiles!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span> (File sub : listFiles) &#123;</span><br><span class="line">        forceDeleteDir(sub);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dir.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重命名目录"><a href="#重命名目录" class="headerlink" title="重命名目录"></a>重命名目录</h3><ul><li>boolean renameTo(File dest)：如果是windows目录，只能在同一个盘下，不能从D盘移动到E盘。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  File dir = <span class="keyword">new</span> File(<span class="string">"D:/unclehe/javase"</span>);</span><br><span class="line">  File dest = <span class="keyword">new</span> File(<span class="string">"D:/unclehe/java代码"</span>);</span><br><span class="line">  dir.renameTo(dest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  File dir = <span class="keyword">new</span> File(<span class="string">"D:/unclehe/javase"</span>);</span><br><span class="line">  File dest = <span class="keyword">new</span> File(<span class="string">"D:/temp"</span>);</span><br><span class="line">  dir.renameTo(dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="IO流的分类与设计"><a href="#IO流的分类与设计" class="headerlink" title="IO流的分类与设计"></a>IO流的分类与设计</h1><h2 id="java-io包中的IO流"><a href="#java-io包中的IO流" class="headerlink" title="java.io包中的IO流"></a>java.io包中的IO流</h2><p>java.io包中类太多了，简直是……“琳琅满目”“眼花缭乱”。你第一次（第二次，第三次，。。。）看到这些API时，“哦”愁眉苦脸时，放心，你不是唯一受到惊吓和困扰的人。但是，如果你好好梳理他们的关系，并掌握几个经典代表的使用方式，其他的也就等于掌握了。</p><p><strong>第一：</strong>其实不管有多少种IO流，最基本的只有四个。</p><p><strong>IO的四个超级父类，抽象基类</strong></p><ul><li><p>字节输入流：InputStream</p></li><li><p>字节输出流：OutputStream</p></li><li><p>字符输入流：Reader</p></li><li><p>字符输出流：Writer</p></li></ul><p><strong>第二：</strong>IO流类的设计选用了“装饰者”设计模式，即IO流分为两大类，“被装饰”的组件和“装饰”的组件。</p><p>例如：以InputStream为例</p><p>其中FileInputStream、ByteArrayInputStream等是“被装饰”的组件，依次用来连接和读取“文件”、“内存中的字节数组”的等。</p><p>而BufferedInputStream、DataInputStream、ObjectInputStream等是用来“装饰”的组件，依次是给其他InputStream的IO流提供装饰的辅助功能的，依次可以增加“提高效率的缓冲功能”、“按照Java数据类型读取数据的能力”、“读取并恢复Java对象的能力”等</p><p>你会发现OutputStream、Reader、Writer系列的流设计方式也是一样的。</p><p><strong>第三：</strong>IO流的选取可以通过以下几个分类来简化选取过程。</p><p><strong>按照IO流的方向：</strong></p><ul><li><p>输入流和输出流</p></li><li><p>I：代表Input</p></li><li><p>O：代表Output</p></li></ul><p>Java的IO流是单向的，只能从输入流（Input、Reader）中读取（read）数据，也只能往输出流（Output、Writer）中写（write、print）出数据。</p><p><strong>按照IO流的处理数据的基本单位分：</strong></p><ul><li><p>字节流（XxxStream）：直接处理二进制，一个字节一个字节处理，它适用于一切数据，包括纯文本、doc、xls、图片、音频、视频等等</p></li><li><p>字符流（XxxReader和XxxWriter）：一个字符一个字符处理，只能纯文本类的数据。</p></li></ul><p><strong>按照角色分：</strong></p><ul><li>节点流：连接源头、目的地，即被装饰者IO流</li><li>处理流：增强功能，提高性能，即装饰者IO流</li></ul><p>节点流处于IO操作的第一线，所有操作必须通过他们进行；处理流是通过包装节点流来完成功能的，处理流可以增加很多层。处理流必须依赖和包装节点流，而不能单独存在。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/io1.png" alt="io"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/io2.png" alt="io"></p><p>提示：装饰模式（Decorator Pattern）也称为包装模式（Wrapper Pattern），其使用一种对客户端透明的方式来动态地扩展对象的功能，它是通过继承扩展功能的替代方案之一。在现实生活中你也有很多装饰者的例子，例如：人需要各种各样的衣着，不管你穿着怎样，但是，对于你个人本质来说是不变的，充其量只是在外面加上了一些装饰，有，“遮羞的”、“保暖的”、“好看的”、“防雨的”….</p><h2 id="常见IO流"><a href="#常见IO流" class="headerlink" title="常见IO流"></a>常见IO流</h2><p><strong>文件IO流</strong></p><ul><li>从文件读取<ul><li>FileInputStream</li><li>FileReader</li></ul></li><li>写入到文件<ul><li>FileOutputStream</li><li>FileWriter</li></ul></li></ul><p><strong>缓冲IO流</strong></p><ul><li>从其他输入流中读取<ul><li>BufferedInputStream</li><li>BufferedReader</li></ul></li><li>写入到其他输出流中<ul><li>BufferedOutputStream</li><li>BufferedWriter</li></ul></li></ul><p><strong>转换流</strong></p><ul><li>从其他输入流读取，并解码<ul><li>InputStreamReader</li></ul></li><li>写入到其他输出流中，并编码<ul><li>OutputStreamWriter</li></ul></li></ul><p><strong>数据流</strong></p><ul><li>以与机器无关方式从底层输入流中读取基本 Java 数据类型<ul><li>DataInputStream</li></ul></li><li>以适当方式将基本 Java 数据类型写入输出流中<ul><li>DataOutputStream</li></ul></li></ul><p><strong>对象流</strong></p><ul><li>序列化<ul><li>ObjectOutputStream</li></ul></li><li>反序列化<ul><li>ObjectInputStream</li></ul></li></ul><p><strong>打印流</strong></p><ul><li>PrintStream</li><li>PrintWriter</li></ul><p><strong>其它流</strong></p><p>​    ……</p><h2 id="抽象基类的常用方法"><a href="#抽象基类的常用方法" class="headerlink" title="抽象基类的常用方法"></a>抽象基类的常用方法</h2><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><ul><li><p>int read()</p><p>从输入流中读取数据的下一个字节。返回 0 到 255 范围内的 int 字节值。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。</p></li><li><p>int read(byte[] b)</p><p>从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。否则以整数形式返回实际读取的字节数。</p></li><li><p>int read(byte[] b, int off,int len)</p><p>将输入流中最多 len 个数据字节读入 byte 数组。尝试读取 len 个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值 -1.</p></li><li><p>public void close() throws IOException</p><p>关闭此输入流并释放与该流关联的所有系统资源。 </p></li></ul><h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><ul><li><p>void write(int b)</p><p>将指定的字节写入此输出流。write 的常规协定是：向输出流写入一个字节。要写入的字节是参数 b 的八个低位。b 的 24 个高位将被忽略。 即写入0~255范围的</p></li><li><p>void write(byte[] b)</p><p>将 b.length 个字节从指定的 byte 数组写入此输出流。write(b) 的常规协定是：应该与调用 write(b, 0, b.length) 的效果完全相同。</p></li><li><p>void write(byte[] b,int off,int len)</p><p>将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。</p></li><li><p>public void flush()throws IOException </p><p>刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。</p></li><li><p>public void close() throws IOException</p><p>关闭此输出流并释放与该流关联的所有系统资源。</p></li></ul><h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><ul><li><p>int read()</p><p>读取单个字符。作为整数读取的字符，范围在 0 到 65535 之间 (0x00-0xffff)（2个字节的Unicode码），如果已到达流的末尾，则返回 -1 </p></li><li><p>int read(char[] cbuf)</p><p>将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。</p></li><li><p>int read(char[] cbuf,int off,int len)</p><p>将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。</p></li><li><p>public void close() throws IOException</p><p>关闭此输入流并释放与该流关联的所有系统资源。 </p></li></ul><h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3><ul><li><p>void write(int c)、Writer append(char c)</p><p>写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即写入0 到 65535 之间的Unicode码。</p></li><li><p>void write(char[] cbuf)、Writer append(CharSequence csq)</p><p>写入字符数组。 </p></li><li><p>void write(char[] cbuf,int off,int len)、Writer append(CharSequence csq, int start, int end)</p><p>写入字符数组的某一部分。从off开始，写入len个字符</p></li><li><p>void write(String str)</p><p>写入字符串。 </p></li><li><p>void write(String str,int off,int len)</p><p>写入字符串的某一部分。</p></li><li><p>void flush()</p><p>刷新该流的缓冲，则立即将它们写入预期目标。</p></li><li><p>public void close() throws IOException</p><p>关闭此输出流并释放与该流关联的所有系统资源。 </p></li></ul><h3 id="IO流使用步骤"><a href="#IO流使用步骤" class="headerlink" title="IO流使用步骤"></a>IO流使用步骤</h3><h4 id="读取-接收数据的步骤"><a href="#读取-接收数据的步骤" class="headerlink" title="读取/接收数据的步骤"></a>读取/接收数据的步骤</h4><p>第一步：选择IO流</p><ol><li><p>选择节点流</p><p>明确你要从哪里读取数据，即数据源是什么？</p><p>如果从文件中，就选择FileInputStream、FileReader；</p><p>如果从内存的数组中，就选择ByteArrayInputStream、CharArrayReader；</p><p>如果从网络中，就选择InputStream；</p></li><li><p>选择字节流还是字符流</p><p>如果可选，那么看数据是否是纯文本，如果是纯文本并且文本的编码方式与当前平台的编码方式一致，那么选择字符流的效率更高，否则选择字节流。</p></li><li><p>是否需要增加额外的辅助功能</p><ul><li><p>缓冲功能：BufferedReader、BufferedInputStream</p></li><li><p>是否需要按行读：BufferedReader、Scanner</p></li><li><p>是否需要以与机器无关方式从底层输入流中读取基本 Java 数据类型：DataInputStream</p></li><li><p>是否需要对象的反序列化：ObjectInputStream</p></li><li><p>是否需要对流中的数据进行解码的转换：InputStreamReader</p></li></ul></li></ol><p>第二步：循环读取数据</p><ul><li>read()</li><li>readLine()</li><li>readXxx()，例如：readInt()，readObject()，readUTF()等</li></ul><p>第三步：关闭close()</p><h4 id="写-发送数据的步骤"><a href="#写-发送数据的步骤" class="headerlink" title="写/发送数据的步骤"></a>写/发送数据的步骤</h4><p>第一步：选择IO流</p><ol><li><p>选择节点流</p><p>明确你要把数据写到哪里去，即数据的目的地是哪里？</p><p>如果写到文件中，就选择FileOutputStream、FileWriter；</p><p>如果写到内存某数组中，就选择ByteArrayOutputStream、CharArrayWriter；</p><p>如果发送到网络中，就选择OutputStream；</p></li><li><p>选择字节流还是字符流</p><p>如果可选，那么看数据是否是纯文本，如果是纯文本并且文本的编码方式与当前平台的编码方式一致，那么选择字符流的效率更高，否则选择字节流。</p></li><li><p>是否需要增加额外的辅助功能</p><p>缓冲功能：BufferedOutputStream、BufferedWriter</p><p>是否需要按行写：PrintStream、PrintWriter</p><p>是否需要以以适当方式将基本 Java 数据类型写入输出流：DataOutputStream</p><p>是否需要将对象的序列化：ObjectOutputStream</p><p>是否需要对流中的数据进行编码的转换：OutputStreamWriter</p></li></ol><p>第二步：循环写数据</p><ul><li><p>write(xx)</p></li><li><p>print(xx)和println(xx)</p></li><li><p>writeXxx：例如：writeInt(xx)、writeDouble(xx)、writeObject(xx)等</p></li></ul><p>第三步：关闭IO流</p><ul><li>close()</li></ul><h1 id="文件IO流"><a href="#文件IO流" class="headerlink" title="文件IO流"></a>文件IO流</h1><p>1、类型</p><p>FileInputStream：文件字节输入流，可以读取任意类型的文件</p><p>FileOutputStream：文件字节输出流，可以把字节数据输出到任意类型的文件</p><p>FileReader：文件字符输入流，只能读取纯文本的文件。按照平台默认的字符编码进行解码。</p><p>FileWriter：文件字符输出流，只能把字符数据输出到纯文本文件。按照平台默认的字符编码进行编码。</p><p>2、读写文件的代码</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(File src, File dest)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="comment">//选择IO流</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(dest);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读写</span></span><br><span class="line">    <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = fis.read(data);</span><br><span class="line">        <span class="keyword">if</span>(len==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fos.write(data,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">     fis.close();</span><br><span class="line">    fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="缓冲IO流"><a href="#缓冲IO流" class="headerlink" title="缓冲IO流"></a>缓冲IO流</h1><p>1、分为</p><p>BufferedInputStream：字节输入缓冲流，给InputStream系列IO流增加缓冲效果<br>BufferedOutputStream：字节输出缓冲流，给OutputStream系列IO流增加缓冲效果<br>BufferedReader：字符输入缓冲流，给Reader系列IO流增加缓冲效果</p><blockquote><p>String readLine()：按行读取</p></blockquote><p>BufferedWriter：字符输出缓冲流，给Writer系列IO流增加缓冲效果</p><blockquote><p>void newLine()：输出换行符</p></blockquote><p>2、默认的缓冲区的大小是8192 = 1024 * 8（字节/字符）</p><p>3、可以给读写的过程提高效率</p><blockquote><p>不仅仅是可以给文件IO流增加缓冲效果，可以给任意符合对应类型的IO流增加缓冲效果。</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyBuffer</span><span class="params">(File src, File dest)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="comment">//选择IO流</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(dest);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//BufferedInputStream只能给FileInputStream增加缓冲效果，读的过程加快了</span></span><br><span class="line">    BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);<span class="comment">//fis在里面，bis在外面，fis比喻成内衣，bis比喻成外套</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//BufferedOutputStream只能FileOutputStream增加缓冲效果，写的过程加快了</span></span><br><span class="line">    BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//数据流向：src--&gt;fis--&gt;bis（从fis先缓冲到bis）--&gt;data--&gt;bos（从data缓冲到bos中）--&gt;fos--&gt;dest</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读写</span></span><br><span class="line">    <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> len = bis.read(data);</span><br><span class="line">        <span class="keyword">if</span>(len==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bos.write(data,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    <span class="comment">//关闭比喻成脱衣服</span></span><br><span class="line">    bos.close();</span><br><span class="line">       fos.close();</span><br><span class="line">       </span><br><span class="line">    bis.close();<span class="comment">//先脱外套，再脱内衣</span></span><br><span class="line">    fis.close();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编码与解码的IO流（转换流）"><a href="#编码与解码的IO流（转换流）" class="headerlink" title="编码与解码的IO流（转换流）"></a>编码与解码的IO流（转换流）</h1><p>1、编码：OutputStreamWriter</p><p>​    可以把字符流转为字节流输出，并且在转换的过程中，可以指定字符编码。</p><p>2、解码：InputStreamReader</p><p>​    可以把字节输入流转为字符输入流，并且在转换的过程中，可以指定字符编码。</p><p>3、示例代码：解码（文件是GBK，当前平台是UTF-8）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"><span class="comment">//因为这里想要用在程序中按照“指定”的编码方式进行解码，而不是按照平台“默认的”编码方式进行解码</span></span><br><span class="line"><span class="comment">//所以，我这里仍然用FileInputStream字节流，把文件编码后的数据，原样读取</span></span><br><span class="line"><span class="comment">//从文件到FileInputStream fis内存的过程中，先不解码</span></span><br><span class="line"><span class="comment">//因为如果选择FileReader，从文件到FileReader的过程中，就已经按照平台“默认的”编码方式解码好了，我们无法控制</span></span><br><span class="line"></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"d:/File类概述.txt"</span>);</span><br><span class="line"><span class="comment">//我要使用InputStreamReader，把FileInputStream转为字符流</span></span><br><span class="line"><span class="comment">//InputStreamReader isr = new InputStreamReader(fis);//如果没有指定，还是按照默认的编码方式</span></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">"GBK"</span>);<span class="comment">//如果指定，就按照指定的编码方式解码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件--&gt;fis（字节流）--&gt;解码--&gt;isr（字符流）--&gt;br -&gt;读取的是字符</span></span><br><span class="line"><span class="comment">//字符流，要么按照char[]读取，要么可以用BufferedReader包装按行读取</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line = br.readLine()) !=<span class="keyword">null</span>)&#123;</span><br><span class="line">System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">br.close();</span><br><span class="line">isr.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、示例代码：编码（文件是GBK，当前平台是UTF-8）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">String hua = <span class="string">"File类可以使用文件路径字符串来创建File实例"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为想要用在程序中进行编码，所以这里选用FileOutputStream</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:/File类概述.txt"</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里xx，想要直接操作字符串，那么必须是字符流，而fos是字节流，无法直接操作字符串</span></span><br><span class="line"><span class="comment">//xx.write("\r\n");</span></span><br><span class="line"><span class="comment">//xx.write(hua);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据流向：内存 --&gt; osw （字符流）--&gt;在写入fos过程中进行编码--&gt;fos（字节流）--&gt;文件</span></span><br><span class="line"></span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos,<span class="string">"GBK"</span>);</span><br><span class="line">osw.write(<span class="string">"\r\n"</span>);</span><br><span class="line">osw.write(hua);</span><br><span class="line"></span><br><span class="line">osw.close();</span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据IO流"><a href="#数据IO流" class="headerlink" title="数据IO流"></a>数据IO流</h1><p>1、类型</p><p>DataInputStream：允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型。<br>DataOutputStream：允许应用程序以适当方式将基本 Java 数据类型写入输出流中。</p><blockquote><p>它俩必须配对使用</p><p>读的顺序要与写的顺序一致</p></blockquote><p>2、API</p><table><thead><tr><th>DataOutputStream</th><th>DataInputStream</th></tr></thead><tbody><tr><td>writeInt(xx)：输出int类型整数</td><td>int readInt()</td></tr><tr><td>writeDouble(xx)：输出double类型</td><td>double readDouble()</td></tr><tr><td>writeBoolean(xx)</td><td>boolean readBoolean()</td></tr><tr><td>writeLong(xx)</td><td>long readLong()</td></tr><tr><td>writeChar(xx)</td><td>char readChar()</td></tr><tr><td>writeByte(xx)</td><td>byte readByte()</td></tr><tr><td>writeShort(xx)</td><td>short readShort()</td></tr><tr><td>writeFloat(xx)</td><td>float readFloat()</td></tr><tr><td>writeUTF(String str)：输出字符串的</td><td>String readUTF()</td></tr></tbody></table><h1 id="对象IO流"><a href="#对象IO流" class="headerlink" title="对象IO流"></a>对象IO流</h1><p>1、类型</p><p>ObjectOutputStream：对象序列化，输出对象，把对象转为字节序列输出</p><p>ObjectInputStream：对象反序列化，读取对象，把字节序列重构成Java对象</p><p>2、API</p><p>ObjectOutputStream：writeObject(对象)</p><p>ObjectInputStream：Object  readObject()</p><p>3、序列化需要注意哪些内容？</p><p>（1）所有要序列化的对象的类型都必须实现java.io.Serializable接口</p><blockquote><p>如果对象的属性类型也是引用数据类型，那么也要实现java.io.Serializable接口</p></blockquote><p>（2）希望类的修改对象反序列化不产生影响，那么我们最后能够增加一个序列化版本ID</p><blockquote><p>private static final long serialVersionUID = 1L;</p></blockquote><p>（3）如果有些属性不想要序列化，可以加transient</p><p>（4）如果某个属性前面有static修饰，也不参与序列化</p><p>4、除了Serializable接口之外，还可以实现java.io.Externalizable接口，但是要求重写：</p><p>void readExternal(ObjectInput in)<br>void writeExternal(ObjectOutput out)</p><p>  关于哪些属性序列化和反序列化，由程序员自己定。</p><h1 id="其他的IO流相关内容"><a href="#其他的IO流相关内容" class="headerlink" title="其他的IO流相关内容"></a>其他的IO流相关内容</h1><p>1、如果要实现按行读取，可选择什么类型？</p><p>BufferedReader：String readLine()</p><p>Scanner：String nextLine()</p><p>2、如果要按行输出，可以选择什么类型？</p><p>（1）自己处理\r\n</p><p>（2）BufferedWriter：newLine()</p><p>（3）PrintStream和PrintWriter：println()</p><h1 id="JDK1-7新特性：try…with…resources"><a href="#JDK1-7新特性：try…with…resources" class="headerlink" title="JDK1.7新特性：try…with…resources"></a>JDK1.7新特性：try…with…resources</h1><p>语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(需要关闭的资源对象的声明)&#123;</span><br><span class="line">    业务逻辑代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">    处理异常代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">    处理异常代码</span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>它没有finally，也不需要程序员去关闭资源对象，无论是否发生异常，都会关闭资源对象</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//从d:/1.txt(GBK)文件中，读取内容，写到项目根目录下1.txt(UTF-8)文件中</span></span><br><span class="line">  <span class="keyword">try</span>(</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"d:/1.txt"</span>);</span><br><span class="line">    InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">"GBK"</span>);</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"1.txt"</span>);</span><br><span class="line">    OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos,<span class="string">"UTF-8"</span>);</span><br><span class="line">    BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(osw);</span><br><span class="line">  )&#123;</span><br><span class="line">    String str;</span><br><span class="line">    <span class="keyword">while</span>((str = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">      bw.write(str);</span><br><span class="line">      bw.newLine();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>早期的java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。</p><p>NIO. 2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。Path可以看成是File类的升级版本，实际引用的资源也可以不存在。</p><p>在以前IO操作都是这样写的:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"index.html"</span>);</span><br></pre></td></tr></table></figure><p>但在Java7 中，我们可以这样写：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Path; </span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths; </span><br><span class="line">Path path = Paths.get(<span class="string">"index.html"</span>);</span><br></pre></td></tr></table></figure><p>同时，NIO.2还提供了Files、Paths工具类，Files包含了大量静态的工具方法来操作文件；Paths则包含了两个返回Path的静态工厂方法。</p><ul><li>static Path get(String first, String … more) : 用于将多个字符串串连成路径</li><li>static Path get(URI uri): 返回指定uri对应的Path路径</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"io"</span>, <span class="string">"java"</span>, <span class="string">"1.txt"</span>);</span><br><span class="line">System.out.println(path);</span><br></pre></td></tr></table></figure><h2 id="Path接口"><a href="#Path接口" class="headerlink" title="Path接口"></a>Path接口</h2><ul><li>String toString() ： 返回调用 Path 对象的字符串表示形式</li><li>boolean startsWith(String path) : 判断是否以 path 路径开始</li><li>boolean endsWith(String path) : 判断是否以 path 路径结束</li><li>boolean isAbsolute() : 判断是否是绝对路径</li><li>Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</li><li>Path getRoot() ：返回调用 Path 对象的根路径</li><li>Path getFileName() : 返回与调用 Path 对象关联的文件名</li><li>Path getName(int idx) : 返回指定索引位置 idx 的路径名称</li><li>int getNameCount() : 返回Path 根目录后面元素的数量</li><li>Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象</li><li>Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象</li><li>File toFile(): 将Path转化为File类的对象</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//Path path = Paths.get("1.txt");</span></span><br><span class="line">  <span class="comment">//Path path = Paths.get("io", "java");</span></span><br><span class="line">  <span class="comment">//Path path = Paths.get("d:","unclehe");</span></span><br><span class="line">  Path path = Paths.get(<span class="string">"io"</span>, <span class="string">"java"</span>, <span class="string">"1.txt"</span>);</span><br><span class="line">  System.out.println(<span class="string">"toString:"</span>+path);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"startsWith:"</span>+path.startsWith(<span class="string">"io"</span>));</span><br><span class="line">  System.out.println(<span class="string">"endsWith:"</span>+path.endsWith(<span class="string">"1.txt"</span>));</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"parent:"</span>+path.getParent());<span class="comment">//io/java</span></span><br><span class="line">  System.out.println(<span class="string">"root:"</span>+path.getRoot());<span class="comment">//null  只有绝对路径才有根</span></span><br><span class="line">  System.out.println(<span class="string">"fileName："</span>+path.getFileName());</span><br><span class="line">  System.out.println(<span class="string">"FileSystem.separator:"</span>+path.getFileSystem().getSeparator());</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"nameCount:"</span>+path.getNameCount());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.getNameCount(); i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">"name("</span>+(i+<span class="number">1</span>)+<span class="string">"):"</span>+path.getName(i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"isAbsolutePath:"</span>+path.isAbsolute());</span><br><span class="line">  System.out.println(<span class="string">"toAbsolutePath:"</span>+path.toAbsolutePath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Files工具类"><a href="#Files工具类" class="headerlink" title="Files工具类"></a>Files工具类</h2><p>用于操作文件或目录的工具类：</p><ul><li>Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) : 创建一个目录</li><li>Path createDirectories(Path dir, FileAttribute&lt;?&gt;… attrs)  创建一个目录，通过创建所有不存在的父目录。</li><li>Path createFile(Path path, FileAttribute&lt;?&gt; … arr) : 创建一个文件</li><li>Path createLink(Path link, Path existing) 创建一个新的链接（目录项）为现有的文件（可选操作）。 </li><li>void delete(Path path) : 删除一个文件，如果不存在，执行报错</li><li>void deleteIfExists(Path path) : Path对应的文件如果存在，执行删除，如果不存在，就什么也不干</li><li>Path copy(Path src, Path dest, CopyOption … how) : 文件的复制</li><li>Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置</li><li>long size(Path path) : 返回 path 指定文件的大小</li></ul><p>Files常用方法：用于判断</p><ul><li>boolean exists(Path path, LinkOption … opts) : 判断文件是否存在</li><li>boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在</li><li>boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录</li><li>boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件</li><li>boolean isHidden(Path path) : 判断是否是隐藏文件</li><li>boolean isReadable(Path path) : 判断文件是否可读</li><li>boolean isWritable(Path path) : 判断文件是否可写</li></ul><p>Files常用方法：用于操作内容</p><ul><li><p>InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象</p></li><li><p>OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象</p></li></ul><p>Files其他方法：</p><ul><li>public static List<String> readAllLines(Path path,Charset cs)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> IO流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2020/06/20/java-%3CT%3E/"/>
      <url>/2020/06/20/java-%3CT%3E/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型的概述"><a href="#泛型的概述" class="headerlink" title="泛型的概述"></a>泛型的概述</h1><p>当我们使用集合时，一旦把一个对象“丢进”Java集合中，集合就会忘记对象的类型，把所有的对象当成Object类型处理。当程序从集合中取出对象后，就需要进行强制类型转换，这种强制类型转换不仅代码臃肿，而且容易引起ClassCastException异常。Java集合之所以被设计成这样，是因为设计集合的程序员不会知道我们需要用它来装什么类型的对象，所以他们把集合设计成能保存任何类型的对象，只要求具有很好的通用性。但这样做也带来了两个问题：</p><ul><li><p>集合对元素类型没有任何限制，这样可能引发一些问题：只想存储字符串对象，却不小心把Integer对象轻易的放进去，因为编译期间没有类型检查。</p></li><li><p>由于把对象“丢进”集合时，在编译期间，集合就忘记了对象的实际类型，集合只知道它盛装的是Object，因此取出集合元素后，该对象的编译时类型就变成了Object类型（其实际的运行时类型没变），如果要使用还需要强制类型转换。这种强制类型转换既会增加编程的复杂度，也可能引发ClassCastException。</p></li></ul><p>于是就有泛型的概念，可以形象的理解为“贴标签”</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/%3CT%3E1.png" alt="泛型"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/%3CT%3E2.png" alt="泛型"></p><p>泛型：参数化类型</p><p>类型形参：<T>，<E>，<K>，<V>，<U>，<R>。。。。</p><p>类型实参：必须是引用数据类型，不能是基本数据类型</p><p>​    <String>，<Integer>，<Student>，&lt;ArrayList<String>&gt;。。。</p><h1 id="泛型类与泛型接口"><a href="#泛型类与泛型接口" class="headerlink" title="泛型类与泛型接口"></a>泛型类与泛型接口</h1><p>我们可以为任何类和接口增加泛型声明，并不是只有集合类才可以使用泛型声明。</p><p>泛型形参的命名一般使用单个的大写字母，如果有多个类型形参，那么使用逗号分隔，例如：Map&lt;K,V&gt;。</p><p>常见字母（见名知意）：</p><ul><li><p>T：Type</p></li><li><p>K，V：Key，Value</p></li><li><p>E：Element</p></li></ul><p>1、声明语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名/接口&lt;类型形参列表&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名/接口&lt;类型形参1 <span class="keyword">extends</span> 父类上限&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名/接口&lt;类型形参1 <span class="keyword">extends</span> 父类上限 &amp; 父接口上限&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在类名或接口名后面声明的泛型形参类型，可以在当前类或接口中使用，用作声明成员变量、方法的形参、方法的返回值。</p><p>但是不能用于<strong>静态成员</strong>上</p></blockquote><p>2、使用语法格式</p><p>在（1）创建泛型类、泛型接口的对象时，为泛型形参指定具体类型</p><p>​    （2）在继承泛型类或实现泛型接口时，为泛型形参指定具体类型</p><p>示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//JDK1.7之后可以省略</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStringArrayList</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee e)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Arrays.sort(数组,  <span class="keyword">new</span>  Comparator&lt;泛型实参&gt;()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(泛型实参类型  o1, 泛型实参类型  o2)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3、泛型如果没有指定，会被擦除，按照最左边的上限处理，如果没有指定上限，按照Object处理</p><h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><p>1、声明的语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 &lt;泛型形参列表&gt;  返回值类型  方法名(【数据形参列表】)【<span class="keyword">throws</span> 异常列表】&#123;&#125;</span><br><span class="line">【修饰符】 &lt;泛型形参 extends 父类上限 &amp; 父接口上限&gt;  返回值类型  方法名(【数据形参列表】)【<span class="keyword">throws</span> 异常列表】&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>（1）在方法返回值类型前面声明的泛型形参类型，只能在当前方法中使用，用于表示形参的类型或返回值类型，或方法局部变量的类型，和别的方法无关。</p><p>（2）泛型方法可以是静态方法，也可以是非静态方法</p></blockquote><p>2、 使用</p><p>当调用方法，会根据具体的数据的实参的类型，来确定泛型实参的类型。</p><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p>当我们声明一个方法时，某个形参的类型是一个泛型类或泛型接口类型，但是在声明方法时，又不确定该泛型实际类型，我们可以考虑使用类型通配符。</p><p>（1）?：代表任意引用数据类型</p><p>（2）?  extends 上限：代表上限本身或它的子类</p><p>（3）? super 下限：代表下限本身或它的父类</p><p>例如：</p><p>ArrayList&lt;?&gt;：表示可以接受任意类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br></pre></td></tr></table></figure><p>ArrayList&lt;? extends 上限&gt;：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;? extends Person&gt; list &#x3D; new ArrayList&lt;Person&gt;();</span><br><span class="line">ArrayList&lt;? extends Person&gt; list &#x3D; new ArrayList&lt;Animal&gt;();&#x2F;&#x2F;Animal不行，因为Animal是父类</span><br><span class="line">ArrayList&lt;? extends Person&gt; list &#x3D; new ArrayList&lt;Student&gt;();</span><br><span class="line">ArrayList&lt;? extends Person&gt; list &#x3D; new ArrayList&lt;Dog&gt;();&#x2F;&#x2F;Dog也不行</span><br></pre></td></tr></table></figure><p>ArrayList&lt;? super 下限&gt;：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;? <span class="keyword">super</span> Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">ArrayList&lt;? <span class="keyword">super</span> Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line">ArrayList&lt;? <span class="keyword">super</span> Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();<span class="comment">//Student，因为Student是子类</span></span><br><span class="line">ArrayList&lt;? <span class="keyword">super</span> Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();<span class="comment">//Dog也不行</span></span><br></pre></td></tr></table></figure><blockquote><p>ArrayList&lt;?&gt;：不能添加元素，除了null</p><p>ArrayList&lt;? extends 上限&gt;：不能添加元素，除了null</p><p>ArrayList&lt;? super 下限&gt;：可以添加下限或下限子类的对象</p></blockquote><h1 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h1><p>参考操作数组的工具类：Arrays。</p><p>Collections 是一个操作 Set、List 和 Map 等集合的工具类。Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法：</p><ul><li>public static <T> boolean addAll(Collection&lt;? super T&gt; c,T… elements)将所有指定元素添加到指定 collection 中。</li><li>public static <T> int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list,T key)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且必须是可比较大小的，即支持自然排序的。而且集合也事先必须是有序的，否则结果不确定。</li><li>public static <T> int binarySearch(List&lt;? extends T&gt; list,T key,Comparator&lt;? super T&gt; c)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且集合也事先必须是按照c比较器规则进行排序过的，否则结果不确定。</li><li>public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，而且支持自然排序</li><li>public static <T> T max(Collection&lt;? extends T&gt; coll,Comparator&lt;? super T&gt; comp)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，按照比较器comp找出最大者</li><li>public static void reverse(List&lt;?&gt; list)反转指定列表List中元素的顺序。</li><li>public static void shuffle(List&lt;?&gt; list) List 集合元素进行随机排序，类似洗牌</li><li>public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List<T> list)根据元素的自然顺序对指定 List 集合元素按升序排序</li><li>public static <T> void sort(List<T> list,Comparator&lt;? super T&gt; c)根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li><li>public static void swap(List&lt;?&gt; list,int i,int j)将指定 list 集合中的 i 处元素和 j 处元素进行交换</li><li>public static int frequency(Collection&lt;?&gt; c,Object o)返回指定集合中指定元素的出现次数</li><li>public static <T> void copy(List&lt;? super T&gt; dest,List&lt;? extends T&gt; src)将src中的内容复制到dest中</li><li>public static <T> boolean replaceAll(List<T> list，T oldVal，T newVal)：使用新值替换 List 对象的所有旧值</li><li>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</li><li>Collections类中提供了多个unmodifiableXxx()方法，该方法返回指定 Xxx的不可修改的视图。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 泛型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="/2020/06/19/java-collection/"/>
      <url>/2020/06/19/java-collection/</url>
      
        <content type="html"><![CDATA[<h1 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h1><p>不管是哪一种数据结构，其实本质上都是容器来着，就是用来装对象的。因此，我们就要搞清楚两点：（1）如何存储（2）存储特点</p><p>数据结构：存储数据的某种结构</p><p>（1）底层的物理结构</p><p>​        ①数组：开辟连续的存储空间，每一个元素使用[下标]进行区别</p><p>​        ②链式：不需要开辟连续的存储空间，但是需要“结点”来包装要存储的数据，结点包含两部分内容：</p><p>​            A、数据</p><p>​            B、记录其他结点的地址，例如：next，pre，left，right，parent等</p><p>（2）表现出来的逻辑结构：动态数组、单向链表、双向链表、队列、栈、二叉树、哈希表、图等</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>逻辑结构：线性的</p></li><li><p>物理结构：顺序的存储结构</p></li><li><p>申请内存：一次申请一大段连续的空间，一旦申请到了，内存就固定了。</p></li><li><p>存储特点：所有数据存储在这个连续的空间中，数组中的每一个元素都是一个具体的数据（或对象），所有数据都紧密排布，不能有间隔。</p></li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection1.png" alt="Collection"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection2.png" alt="Collection"></p><ul><li><p>操作</p><ul><li>查询：每一个元素都有一个数值下标，可以通过下标瞬间定位到某个元素</li><li>增加：<ul><li>先使用total变量辅助记录实际存储元素个数</li><li>从尾部增加：数组名[total++]=新元素</li><li>从其他位置插入：先把index位置开始所有元素后移，然后数组名[index]=新元素</li></ul></li><li>删除：先把index后面的元素前移，然后数组名[total–] = null</li><li>改：直接数组名[index]=新元素</li></ul></li><li><p>优缺点</p><ul><li>优点：按索引查询效率高</li><li>缺点：添加/删除效率低，因为都涉及到移动元素；无法直接获取有效元素的个数，需要total来辅助</li></ul></li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection3.png" alt="Collection"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection4.png" alt="Collection"></p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>为了可以满足用户数据更多种的逻辑关系，而设计的一系列的不同于数组的可变的聚合的抽象数据类型。这些接口和类在java.util包中，因为类型很丰富，因此我们通常称为集合框架集</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection5.png" alt="Collection"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection6.png" alt="Collection"></p><ul><li>Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何直接实现：它提供更具体的子接口（如 Set 和 List、Queue）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。<ul><li>List：有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。</li><li>Queue：队列通常（但并非一定）以 FIFO（先进先出）的方式排序各个元素。不过优先级队列和 LIFO 队列（或堆栈）例外，前者根据提供的比较器或元素的自然顺序对元素进行排序，后者按 LIFO（后进先出）的方式对元素进行排序。</li><li>Set：一个不包含重复元素的 collection。更确切地讲，set 不包含满足 e1.equals(e2) 的元素对 e1 和 e2，并且最多包含一个 null 元素。正如其名称所暗示的，此接口模仿了数学上的 set 抽象。<ul><li>SortedSet进一步提供关于元素的总体排序 的 Set。这些元素使用其自然顺序进行排序，或者根据通常在创建有序 set 时提供的 Comparator进行排序。该 set 的迭代器将按元素升序遍历 set。提供了一些附加的操作来利用这种排序。</li></ul></li></ul></li><li>Map：将键映射到值(key,value)的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。映射顺序 定义为迭代器在映射的 collection 视图上返回其元素的顺序。某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap 类。<ul><li>SortedMap进一步提供关于键的总体排序 的 Map。该映射是根据其键的自然顺序进行排序的，或者根据通常在创建有序映射时提供的 Comparator 进行排序。</li></ul></li></ul><h1 id="手动实现一些逻辑结构"><a href="#手动实现一些逻辑结构" class="headerlink" title="手动实现一些逻辑结构"></a>手动实现一些逻辑结构</h1><p>1、动态数组</p><p>包含：</p><p>（1）内部使用一个数组，用来存储数据</p><p>（2）内部使用一个total，记录实际存储的元素的个数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span> </span>&#123;</span><br><span class="line"><span class="comment">//为什么使用Object，因为只是说这个容器是用来装对象的，但是不知道用来装什么对象。</span></span><br><span class="line"><span class="keyword">private</span> Object[] data;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> total;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyArrayList</span><span class="params">()</span></span>&#123;</span><br><span class="line">data = <span class="keyword">new</span> Object[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="comment">//检查是否需要扩容</span></span><br><span class="line">checkCapacity();</span><br><span class="line">data[total++] = obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果data满了，就扩容为原来的2倍</span></span><br><span class="line"><span class="keyword">if</span>(total &gt;= data.length)&#123;</span><br><span class="line">data = Arrays.copyOf(data, data.length*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回实际元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回数组的实际容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> data.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取[index]位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="comment">//校验index的合理性范围</span></span><br><span class="line">checkIndex(index);</span><br><span class="line"><span class="keyword">return</span> data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=total)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(index+<span class="string">"对应位置的元素不存在"</span>);</span><br><span class="line"><span class="comment">//throw new IndexOutOfBoundsException(index+"越界");</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换[index]位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Object value)</span></span>&#123;</span><br><span class="line"><span class="comment">//校验index的合理性范围</span></span><br><span class="line">checkIndex(index);</span><br><span class="line"></span><br><span class="line">data[index] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在[index]位置插入一个元素value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, Object value)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)考虑下标的合理性</span></span><br><span class="line"><span class="comment"> * (2)总长度是否够</span></span><br><span class="line"><span class="comment"> * (3)[index]以及后面的元素往后移动，把[index]位置腾出来</span></span><br><span class="line"><span class="comment"> * (4)data[index]=value  放入新元素</span></span><br><span class="line"><span class="comment"> * (5)total++  有效元素的个数增加</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)考虑下标的合理性：校验index的合理性范围</span></span><br><span class="line">checkIndex(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)总长度是否够：检查是否需要扩容</span></span><br><span class="line">checkCapacity();</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)[index]以及后面的元素往后移动，把[index]位置腾出来</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 假设total = 5, data.length= 10, index= 1</span></span><br><span class="line"><span class="comment"> * 有效元素的下标[0,4]</span></span><br><span class="line"><span class="comment"> * 移动：[1]-&gt;[2],[2]-&gt;[3],[3]-&gt;[4],[4]-&gt;[5]</span></span><br><span class="line"><span class="comment"> * 移动元素的个数：total-index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.arraycopy(data, index, data, index+<span class="number">1</span>, total-index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)data[index]=value  放入新元素</span></span><br><span class="line">data[index] = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(5)total++  有效元素的个数增加</span></span><br><span class="line">total++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回所有实际存储的元素</span></span><br><span class="line"><span class="keyword">public</span> Object[] getAll()&#123;</span><br><span class="line"><span class="comment">//返回total个</span></span><br><span class="line"><span class="keyword">return</span> Arrays.copyOf(data, total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除[index]位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)校验index的合理性范围</span></span><br><span class="line"><span class="comment"> * (2)移动元素，把[index+1]以及后面的元素往前移动</span></span><br><span class="line"><span class="comment"> * (3)把data[total-1]=null  让垃圾回收器尽快回收</span></span><br><span class="line"><span class="comment"> * (4)总元素个数减少 total--</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)考虑下标的合理性：校验index的合理性范围</span></span><br><span class="line">checkIndex(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)移动元素，把[index+1]以及后面的元素往前移动</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 假设total=8, data.length=10, index = 3</span></span><br><span class="line"><span class="comment"> * 有效元素的范围[0,7]</span></span><br><span class="line"><span class="comment"> * 移动：[4]-&gt;[3],[5]-&gt;[4],[6]-&gt;[5],[7]-&gt;[6]</span></span><br><span class="line"><span class="comment"> * 移动了4个：total-index-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.arraycopy(data, index+<span class="number">1</span>, data, index, total-index-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)把data[total-1]=null  让垃圾回收器尽快回收</span></span><br><span class="line">data[total-<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)总元素个数减少 total--</span></span><br><span class="line">total--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询某个元素的下标</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(data[i] == <span class="keyword">null</span>)&#123;<span class="comment">//等价于 if(data[i] == obj)</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(obj.equals(data[i]))&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除数组中的某个元素</span></span><br><span class="line"><span class="comment">//如果有重复的，只删除第一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)先查询obj的[index]</span></span><br><span class="line"><span class="comment"> * (2)如果存在，就调用remove(index)删除就可以</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)先查询obj的[index]</span></span><br><span class="line"><span class="keyword">int</span> index = indexOf(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(index != -<span class="number">1</span>)&#123;</span><br><span class="line">remove(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不存在，可以什么也不做</span></span><br><span class="line"><span class="comment">//不存在，也可以抛异常</span></span><br><span class="line"><span class="comment">//throw new RuntimeException(obj + "不存在");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object old, Object value)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)查询old的[index]</span></span><br><span class="line"><span class="comment"> * (2)如果存在，就调用set(index, value)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)查询old的[index]</span></span><br><span class="line"><span class="keyword">int</span> index = indexOf(old);</span><br><span class="line"><span class="keyword">if</span>(index!=-<span class="number">1</span>)&#123;</span><br><span class="line">set(index, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不存在，可以什么也不做</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、单向链表</p><p>包含：</p><p>（1）包含一个Node类型的成员变量first：用来记录第一个结点的地址</p><p>​        如果这个链表是空的，还没有任何结点，那么first是null。</p><p>​        最后一个结点的特征：就是它的next是null</p><p>（2）内部使用一个total，记录实际存储的元素的个数</p><p>（3）使用了一个内部类Node</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里不需要数组，不需要其他的复杂的结构，我只要记录单向链表的“头”结点</span></span><br><span class="line"><span class="keyword">private</span> Node first;<span class="comment">//first中记录的是第一个结点的地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> total;<span class="comment">//这里我记录total是为了后面处理的方便，例如：当用户获取链表有效元素的个数时，不用现数，而是直接返回total等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 内部类，因为这种Node结点的类型，在别的地方没有用，只在单向链表中，用于存储和表示它的结点关系。</span></span><br><span class="line"><span class="comment"> * 因为我这里涉及为内部类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">Object data;<span class="comment">//因为数据可以是任意类型的对象，所以设计为Object</span></span><br><span class="line">Node next;<span class="comment">//因为next中记录的下一个结点的地址，因此类型是结点类型</span></span><br><span class="line"><span class="comment">//这里data,next没有私有化，是希望在外部类中可以不需要get/set，而是直接“结点对象.data","结点对象.next"使用</span></span><br><span class="line">Node(Object data, Node next)&#123;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)把obj的数据，包装成一个Node类型结点对象</span></span><br><span class="line"><span class="comment"> * (2)把新结点“链接”当前链表的最后</span></span><br><span class="line"><span class="comment"> * ①当前新结点是第一个结点</span></span><br><span class="line"><span class="comment"> * 如何判断是否是第一个   if(first==null)说明暂时还没有第一个</span></span><br><span class="line"><span class="comment"> * ②先找到目前的最后一个，把新结点链接到它的next中</span></span><br><span class="line"><span class="comment"> * 如何判断是否是最后一个   if(某个结点.next == null)说明这个结点是最后一个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//(1)把obj的数据，包装成一个Node类型结点对象</span></span><br><span class="line"><span class="comment">//这里新结点的next赋值为null，表示新结点是最后一个结点</span></span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//①当前新结点是第一个结点</span></span><br><span class="line"><span class="keyword">if</span>(first == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//说明newNode是第一个</span></span><br><span class="line">first = newNode;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//②先找到目前的最后一个，把新结点链接到它的next中</span></span><br><span class="line">Node node = first;</span><br><span class="line"><span class="keyword">while</span>(node.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出循环时node指向最后一个结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把新结点链接到它的next中</span></span><br><span class="line">node.next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">total++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object[] getAll()&#123;</span><br><span class="line"><span class="comment">//(1)创建一个数组，长度为total</span></span><br><span class="line">Object[] all = <span class="keyword">new</span> Object[total];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)把单向链表的每一个结点中的data，拿过来放到all数组中</span></span><br><span class="line">Node node = first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line"><span class="comment">//all[i] = 结点.data;</span></span><br><span class="line">all[i] = node.data;</span><br><span class="line"><span class="comment">//然后node指向下一个</span></span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)返回数组</span></span><br><span class="line"><span class="keyword">return</span> all;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//(1)先考虑是否是第一个</span></span><br><span class="line"><span class="keyword">if</span>(first!=<span class="keyword">null</span>)&#123;<span class="comment">//链表非空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要删除的结点正好是第一个结点</span></span><br><span class="line"><span class="keyword">if</span>(first.data == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//让第一个结点指向它的下一个</span></span><br><span class="line">first = first.next;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要删除的不是第一个结点</span></span><br><span class="line">Node node = first.next;<span class="comment">//第二个结点</span></span><br><span class="line">Node last = first;</span><br><span class="line"><span class="keyword">while</span>(node.next!=<span class="keyword">null</span>)&#123;<span class="comment">//这里不包括最后一个，因为node.next==null，不进入循环，而node.next==null是最后一个</span></span><br><span class="line"><span class="keyword">if</span>(node.data == <span class="keyword">null</span>)&#123;</span><br><span class="line">last.next = node.next;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">last = node;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单独判断最后一个是否是要删除的结点</span></span><br><span class="line"><span class="keyword">if</span>(node.data == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//要删除的是最后一个结点</span></span><br><span class="line">last.next = <span class="keyword">null</span>;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//(1)先考虑是否是第一个</span></span><br><span class="line"><span class="keyword">if</span>(first!=<span class="keyword">null</span>)&#123;<span class="comment">//链表非空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要删除的结点正好是第一个结点</span></span><br><span class="line"><span class="keyword">if</span>(obj.equals(first.data))&#123;</span><br><span class="line"><span class="comment">//让第一个结点指向它的下一个</span></span><br><span class="line">first = first.next;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要删除的不是第一个结点</span></span><br><span class="line">Node node = first.next;<span class="comment">//第二个结点</span></span><br><span class="line">Node last = first;</span><br><span class="line"><span class="keyword">while</span>(node.next!=<span class="keyword">null</span>)&#123;<span class="comment">//这里不包括最后一个，因为node.next==null，不进入循环，而node.next==null是最后一个</span></span><br><span class="line"><span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line">last.next = node.next;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">last = node;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单独判断最后一个是否是要删除的结点</span></span><br><span class="line"><span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line"><span class="comment">//要删除的是最后一个结点</span></span><br><span class="line">last.next = <span class="keyword">null</span>;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">Node node = first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(node.data == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Node node = first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><p>因为集合的类型很多，那么我们把它们称为集合框架。</p><p>集合框架分为两个家族：Collection（一组对象）和Map（一组映射关系、一组键值对）</p><p>Collection是代表一种对象的集合。它是Collection系列的根接口。</p><p>它们虽然：有些可能是有序的，有些可能是无序的，有些可能可以重复的，有些不能重复的，但是它们有共同的操作规范，因此这些操作的规范就抽象为了Collection接口。</p><p><strong>常用方法：</strong></p><ul><li><p>boolean add(Object obj)：添加一个</p></li><li><p>boolean addAll（Collection c）：添加多个</p></li><li><p>boolean remove(Object obj)：删除一个</p></li><li><p>boolean removeAll(Collection c )： 删除多个</p></li><li><p>boolean contains(Object c)：是否包含某个</p></li><li><p>boolean containsAll(Collection c)： 是否包含所有</p></li><li><p>boolean isEmpty()：是否为空</p></li><li><p>int size()：获取元素个数</p></li><li><p>void clear()：清空集合</p></li><li><p>Object[] toArray()：获取所有元素</p></li><li><p>Iterator iterator()： 获取遍历当前集合的迭代器对象</p></li><li><p>retainAll(Collection c)：求当前集合与c集合的交集</p></li></ul><h2 id="Collection系列的集合的遍历"><a href="#Collection系列的集合的遍历" class="headerlink" title="Collection系列的集合的遍历"></a>Collection系列的集合的遍历</h2><p>1、明确使用Iterator迭代器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection c = ....;</span><br><span class="line"></span><br><span class="line">Iterator iter = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hashNext())&#123;</span><br><span class="line">    Object obj = iter.next();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterator 接口的方法：</p><p>（1）boolean hasNext()</p><p>（2）Object next()</p><p>（3）void remove()</p><p>2、foreach</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Collection c &#x3D; ....;</span><br><span class="line"></span><br><span class="line">for(Object  obj :  c)&#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么样的集合（容器）能够使用foreach遍历？</p><p>（1）数组：</p><p>（2）实现了java.lang.Iterable接口</p><p>这个接口有一个抽象方法：Iterator iterator()</p><p>Iterator也是一个接口，它的实现类，通常在集合（容器）类中用内部类实现。并在iterator()的方法中创建它的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span> <span class="keyword">implements</span> <span class="title">Iterable</span></span>&#123;</span><br><span class="line"><span class="comment">//为什么使用Object，因为只是说这个容器是用来装对象的，但是不知道用来装什么对象。</span></span><br><span class="line"><span class="keyword">private</span> Object[] data;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> total;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他代码省略....</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyItr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyItr</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cursor;<span class="comment">//游标</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> cursor!=total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> data[cursor++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：如果遍历数组，什么情况下选用foreach，什么情况下选用for循环？</p><p>当如果你的操作中涉及到[下标]操作时，用for最好。</p><p>当你只是查看元素的内容，那么选foreach更简洁一些。</p><p>思考：如果遍历Collection系列集合，什么情况下选用foreach，是否能选用for循环？</p><p>首先考虑使用foreach，如果该集合也有索引信息的话，也可以通过for来操作，如果没有下标的信息，就不要用for。即，如果该集合的物理结构是数组的，那么可以用for，如果物理结构是链式，那么使用下标操作效率很低。</p><p>思考：如果遍历Collection系列集合，什么情况下选用foreach，什么情况下使用Iterator？</p><p>如果只是查看集合的元素，使用foreach，代码会更简洁。</p><p>但是如果要涉及到在遍历集合的同时根据某种条件要删除元素等操作，那么选用Iterator。</p><h2 id="Iterator迭代器遍历"><a href="#Iterator迭代器遍历" class="headerlink" title="Iterator迭代器遍历"></a>Iterator迭代器遍历</h2><p>因为Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，该对象可以用于迭代集合中的元素。</p><ul><li>Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建 Iterator 对象，则必须有一个被迭代的集合。</li><li>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素位置。</li></ul><p><strong>常用方法</strong></p><ul><li>boolean hasNext()：如果仍有元素可以迭代，则返回 true</li><li>Object next()：返回迭代的下一个元素。</li><li>void remove()：从迭代器指向的 collection 中移除迭代器返回的最后一个元素（可选操作）</li></ul><p><strong>注意</strong></p><ul><li>建议在调用it.next()方法之前调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。</li><li>如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException</li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection8.png" alt="Collection"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection9.png" alt="Collection"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection10.png" alt="Collection"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection11.png" alt="Collection"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  c.add(<span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">"张三"</span>));</span><br><span class="line">  c.add(<span class="keyword">new</span> Student(<span class="number">2</span>,<span class="string">"李四"</span>));</span><br><span class="line">  c.add(<span class="keyword">new</span> Student(<span class="number">3</span>,<span class="string">"王五"</span>));</span><br><span class="line">  c.add(<span class="keyword">new</span> Student(<span class="number">4</span>,<span class="string">"赵六"</span>));</span><br><span class="line">  c.add(<span class="keyword">new</span> Student(<span class="number">5</span>,<span class="string">"钱七"</span>));</span><br><span class="line"></span><br><span class="line">  Iterator iterator = c.iterator();</span><br><span class="line">  <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    Student next = (Student) iterator.next();</span><br><span class="line">    <span class="comment">//例如：要删除学号为1的学生对象</span></span><br><span class="line">    <span class="keyword">if</span>(next.getId()==<span class="number">1</span>)&#123;</span><br><span class="line">      iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h1><p>List集合类中元素有序、且可重复。这就像银行门口客服，给每一个来办理业务的客户分配序号：第一个来的是“张三”，客服给他分配的是0；第二个来的是“李四”，客服给他分配的1；以此类推，最后一个序号应该是“总人数-1”。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/list.png" alt="list"></p><p>List：是Collection的子接口。</p><p>List系列的集合：有序的、可重复的</p><p>List系列的常用集合：ArrayList、Vector、LinkedList、Stack</p><p><strong>注意</strong></p><p>在JavaSE中List名称的类型有两个，一个是java.util.List集合接口，一个是java.awt.List图形界面的组件，别导错包了。</p><p>List集合关心元素是否有序，而不关心是否重复，请大家记住这个原则。例如“张三”可以领取两个号。</p><h2 id="List接口常用方法"><a href="#List接口常用方法" class="headerlink" title="List接口常用方法"></a>List接口常用方法</h2><ul><li><p>boolean add(Object obj)：添加一个</p></li><li><p>boolean addAll（Collection c）：添加多个</p></li><li><p>void add(int index, Object obj)：添加一个，指定位置添加</p></li><li><p>void addAll(int index, Collection c）：添加多个</p></li><li><p>boolean remove(Object obj)：删除一个</p></li><li><p>Object remove(int index)：删除指定位置的元素，并返回刚刚删除的元素</p></li><li><p>boolean removeAll(Collection c )： 删除多个</p></li><li><p>boolean contains(Object c)：是否包含某个</p></li><li><p>boolean containsAll(Collection c)： 是否包含所有</p></li><li><p>boolean isEmpty()：是否为空</p></li><li><p>int size()：获取元素个数</p></li><li><p>void clear()：清空集合</p></li><li><p>Object[] toArray()：获取所有元素</p></li><li><p>Iterator iterator()： 获取遍历当前集合的迭代器对象</p></li><li><p>retainAll(Collection c)：求当前集合与c集合的交集</p></li><li><p>ListIterator listIterator()：获取遍历当前集合的迭代器对象，这个迭代器可以往前、往后遍历</p></li><li><p>ListIterator listIterator(int index)：从[index]位置开始，往前或往后遍历</p></li><li><p>Object get(int index)：返回index位置的元素</p></li><li><p>List  subList(int start, int end)：截取[start,end)部分的子列表</p></li></ul><h2 id="接口的实现类"><a href="#接口的实现类" class="headerlink" title="接口的实现类"></a>接口的实现类</h2><p>Vector 类：动态数组</p><p>ArrayList类：动态数组</p><p>Stack类：堆栈</p><p>LinkedList：双向链表，从JDK1.6之后又实现了双端队列</p><h3 id="ArrayList与Vector的区别？"><a href="#ArrayList与Vector的区别？" class="headerlink" title="ArrayList与Vector的区别？"></a>ArrayList与Vector的区别？</h3><p>它们的底层物理结构都是数组，我们称为动态数组。</p><ul><li>ArrayList是新版的动态数组，线程不安全，效率高，Vector是旧版的动态数组，线程安全，效率低。</li><li>动态数组的扩容机制不同，ArrayList扩容为原来的1.5倍，Vector扩容增加为原来的2倍。</li><li>数组的初始化容量，如果在构建ArrayList与Vector的集合对象时，没有显式指定初始化容量，那么Vector的内部数组的初始容量默认为10，而ArrayList在JDK1.6及之前的版本也是10，而JDK1.7之后的版本ArrayList初始化为长度为0的空数组，之后在添加第一个元素时，再创建长度为10的数组。</li><li>Vector因为版本古老，支持Enumeration 迭代器。但是该迭代器不支持快速失败。而Iterator和ListIterator迭代器支持快速失败。如果在迭代器创建后的任意时间从结构上修改了向量（通过迭代器自身的 remove 或 add 方法之外的任何其他方式），则迭代器将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就完全失败，而不是冒着在将来不确定的时间任意发生不确定行为的风险。</li></ul><p><strong>提示：</strong>在List列表集合实现中都有一个变量modCount，每次添加、删除都会使得modCount变量增加，因此用foreach和Iterator迭代时，如果再通过集合的add和remove等方法修改集合，会抛出 ConcurrentModificationException。</p><h3 id="Vector与Stack的区别与联系？"><a href="#Vector与Stack的区别与联系？" class="headerlink" title="Vector与Stack的区别与联系？"></a>Vector与Stack的区别与联系？</h3><p>Stack类是Vector的子类。</p><p>Stack类表示后进先出（LIFO）的对象堆栈。它通过五个操作对类 Vector 进行了扩展 ，允许将向量视为堆栈。它提供了通常的 push 和 pop 操作，以及取堆栈顶点的 peek 方法、测试堆栈是否为空的 empty 方法、在堆栈中查找项并确定到堆栈顶距离的 search 方法。</p><h3 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h3><p>除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。</p><p>代码示例一：作为List的普通列表形式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLinkedList</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Object object : list) &#123;</span><br><span class="line">System.out.println(object);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.6之后LinkedList实现了Deque接口。双端队列也可用作 LIFO（后进先出）堆栈。如果要使用堆栈结构的集合，可以考虑使用LinkedList，而不是Stack。</p><table><thead><tr><th>堆栈方法</th><th>等效Deque方法</th></tr></thead><tbody><tr><td>push(e)</td><td>addFirst(e)</td></tr><tr><td>pop()</td><td>removeFirst()</td></tr><tr><td>peek()</td><td>peekFirst()</td></tr></tbody></table><p>代码示例二：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList();</span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line">list.addFirst(<span class="number">1</span>);</span><br><span class="line">list.addFirst(<span class="number">2</span>);</span><br><span class="line">list.addFirst(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈： LIFO（后进先出）</span></span><br><span class="line">System.out.println(list.removeFirst());<span class="comment">//3</span></span><br><span class="line">System.out.println(list.removeFirst());<span class="comment">//2</span></span><br><span class="line">System.out.println(list.removeFirst());<span class="comment">//1</span></span><br><span class="line"><span class="comment">//栈空了，会报异常java.util.NoSuchElementException</span></span><br><span class="line">System.out.println(list.removeFirst());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用作队列时，将得到 FIFO（先进先出）行为。将元素添加到双端队列的末尾，从双端队列的开头移除元素。</p><table><thead><tr><th>Queue 方法</th><th>等效 Deque 方法</th></tr></thead><tbody><tr><td>add(e)</td><td>addLast(e)</td></tr><tr><td>offer(e)</td><td>offerLast(e)</td></tr><tr><td>remove()</td><td>removeFirst()</td></tr><tr><td>poll()</td><td>pollFirst()</td></tr><tr><td>element()</td><td>getFirst()</td></tr><tr><td>peek()</td><td>peekFirst()</td></tr></tbody></table><p>代码示例三：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList();</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line">list.addLast(<span class="number">1</span>);</span><br><span class="line">list.addLast(<span class="number">2</span>);</span><br><span class="line">list.addLast(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队， FIFO（先进先出）</span></span><br><span class="line">System.out.println(list.pollFirst());<span class="comment">//1</span></span><br><span class="line">System.out.println(list.pollFirst());<span class="comment">//2</span></span><br><span class="line">System.out.println(list.pollFirst());<span class="comment">//3</span></span><br><span class="line"><span class="comment">//队空了，返回null</span></span><br><span class="line">System.out.println(list.pollFirst());<span class="comment">//null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。</p><table><thead><tr><th></th><th>第一个元素（头部）</th><th></th><th>最后一个元素（尾部）</th><th></th></tr></thead><tbody><tr><td></td><td>抛出异常</td><td>特殊值</td><td>抛出异常</td><td>特殊值</td></tr><tr><td>插入</td><td>addFirst(e)</td><td>offerFirst(e)</td><td>addLast(e)</td><td>offerLast(e)</td></tr><tr><td>移除</td><td>removeFirst()</td><td>pollFirst()</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>检查</td><td>getFirst()</td><td>peekFirst()</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><h2 id="List集合的遍历"><a href="#List集合的遍历" class="headerlink" title="List集合的遍历"></a>List集合的遍历</h2><h3 id="普通for循环遍历"><a href="#普通for循环遍历" class="headerlink" title="普通for循环遍历"></a>普通for循环遍历</h3><p>对于ArrayList和Vector这样的动态数组，也可以使用普通for循环进行遍历。</p><h3 id="ListIterator迭代器"><a href="#ListIterator迭代器" class="headerlink" title="ListIterator迭代器"></a>ListIterator迭代器</h3><p>List 集合额外提供了一个 listIterator() 方法，该方法返回一个 ListIterator 对象， ListIterator 接口继承了 Iterator 接口，提供了专门操作 List 的方法：</p><ul><li>void add()：通过迭代器添加元素到对应集合</li><li>void set(Object obj)：通过迭代器替换正迭代的元素</li><li>void remove()：通过迭代器删除刚迭代的元素</li></ul><ul><li>boolean hasPrevious()：如果以逆向遍历列表，往前是否还有元素。</li><li>Object previous()：返回列表中的前一个元素。</li><li>int previousIndex()：返回列表中的前一个元素的索引</li></ul><ul><li>boolean hasNext()</li><li>Object next()</li><li>int nextIndex()</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="number">10</span>);<span class="comment">//指定初始容量initialCapacity为10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);<span class="comment">//指定capacityIncrement增量为0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement增量为<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  <span class="comment">//判断了形参初始容量initialCapacity的合法性</span></span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                       initialCapacity);</span><br><span class="line">  <span class="comment">//创建了一个Object[]类型的数组</span></span><br><span class="line">  <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];<span class="comment">//默认是10</span></span><br><span class="line">  <span class="comment">//增量，默认是0，如果是0，后面就按照2倍增加，如果不是0，后面就按照你指定的增量进行增量</span></span><br><span class="line">  <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//synchronized意味着线程安全的   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//看是否需要扩容</span></span><br><span class="line">  ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//把新的元素存入[elementCount]，存入后，elementCount元素的个数增1</span></span><br><span class="line">  elementData[elementCount++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="comment">//看是否超过了当前数组的容量</span></span><br><span class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    grow(minCapacity);<span class="comment">//扩容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//获取目前数组的长度</span></span><br><span class="line">  <span class="comment">//如果capacityIncrement增量是0，新容量 = oldCapacity的2倍</span></span><br><span class="line">  <span class="comment">//如果capacityIncrement增量是不是0，新容量 = oldCapacity + capacityIncrement增量;</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                   capacityIncrement : oldCapacity);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果按照上面计算的新容量还不够，就按照你指定的需要的最小容量来扩容minCapacity</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果新容量超过了最大数组限制，那么单独处理</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//把旧数组中的数据复制到新数组中，新数组的长度为newCapacity</span></span><br><span class="line">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> removeElement(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeElement</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//查找obj在当前Vector中的下标</span></span><br><span class="line">  <span class="keyword">int</span> i = indexOf(obj);</span><br><span class="line">  <span class="comment">//如果i&gt;=0，说明存在，删除[i]位置的元素</span></span><br><span class="line">  <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    removeElementAt(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> indexOf(o, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;<span class="comment">//要查找的元素是null值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">      <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)<span class="comment">//如果是null值，用==null判断</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//要查找的元素是非null值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">      <span class="keyword">if</span> (o.equals(elementData[i]))<span class="comment">//如果是非null值，用equals判断</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//判断下标的合法性</span></span><br><span class="line">  <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">                                             elementCount);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//j是要移动的元素的个数</span></span><br><span class="line">  <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//如果需要移动元素，就调用System.arraycopy进行移动</span></span><br><span class="line">  <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//把index+1位置以及后面的元素往前移动</span></span><br><span class="line">    <span class="comment">//index+1的位置的元素移动到index位置，依次类推</span></span><br><span class="line">    <span class="comment">//一共移动j个</span></span><br><span class="line">    System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//元素的总个数减少</span></span><br><span class="line">  elementCount--;</span><br><span class="line">  <span class="comment">//将elementData[elementCount]这个位置置空，用来添加新元素，位置的元素等着被GC回收</span></span><br><span class="line">  elementData[elementCount] = <span class="keyword">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h3><p>JDK1.6：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="number">10</span>);<span class="comment">//指定初始容量为10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  <span class="comment">//检查初始容量的合法性</span></span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> + initialCapacity);</span><br><span class="line">  <span class="comment">//数组初始化为长度为initialCapacity的数组</span></span><br><span class="line">  <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.7</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;<span class="comment">//默认初始容量10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>();</span><br><span class="line">  <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="comment">//数组初始化为一个空数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  elementData[size++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;<span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">    <span class="comment">//minCapacity按照 默认初始容量和minCapacity中的的最大值处理</span></span><br><span class="line">    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//看是否需要扩容处理</span></span><br><span class="line">  ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>JDK1.8</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<span class="comment">//初始化为空数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//存入新元素到[size]位置，然后size自增1</span></span><br><span class="line">  elementData[size++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">  <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    <span class="comment">//那么minCapacity取DEFAULT_CAPACITY与minCapacity的最大值</span></span><br><span class="line">    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//查看是否需要扩容</span></span><br><span class="line">  ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果需要的最小容量  比  当前数组的长度  大，即当前数组不够存，就扩容</span></span><br><span class="line">  <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// overflow-conscious code</span></span><br><span class="line">  <span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//当前数组容量</span></span><br><span class="line">  <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//新数组容量是旧数组容量的1.5倍</span></span><br><span class="line">  <span class="comment">//看旧数组的1.5倍是否够</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;</span><br><span class="line">  <span class="comment">//看旧数组的1.5倍是否超过最大数组限制</span></span><br><span class="line">  <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//复制一个新数组</span></span><br><span class="line">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//先找到o在当前ArrayList的数组中的下标</span></span><br><span class="line">  <span class="comment">//分o是否为空两种情况讨论</span></span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">      <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;<span class="comment">//null值用==比较</span></span><br><span class="line">        fastRemove(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">      <span class="keyword">if</span> (o.equals(elementData[index])) &#123;<span class="comment">//非null值用equals比较</span></span><br><span class="line">        fastRemove(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line">  <span class="comment">//需要移动的元素个数</span></span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                     numMoved);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">  modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被删除的元素，用于最后返回被删除的元素</span></span><br><span class="line">  E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//需要移动的元素个数</span></span><br><span class="line">  <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">  <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                     numMoved);</span><br><span class="line">  <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">  elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被替换的元素，用于最后返回被替换的元素</span></span><br><span class="line">  E oldValue = elementData(index);</span><br><span class="line">  <span class="comment">//用element替换[index]位置的元素</span></span><br><span class="line">  elementData[index] = element;</span><br><span class="line">  <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elementData(index);<span class="comment">//返回[index]位置的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//从前往后找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">      <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//从后往前找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedList源码分析"><a href="#LinkedList源码分析" class="headerlink" title="LinkedList源码分析"></a>LinkedList源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">Node&lt;E&gt; first;<span class="comment">//记录第一个结点的位置</span></span><br><span class="line">Node&lt;E&gt; last;<span class="comment">//记录最后一个结点的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  E item;<span class="comment">//元素数据</span></span><br><span class="line">  Node&lt;E&gt; next;<span class="comment">//下一个结点</span></span><br><span class="line">  Node&lt;E&gt; prev;<span class="comment">//前一个结点</span></span><br><span class="line"></span><br><span class="line">  Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.item = element;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">    <span class="keyword">this</span>.prev = prev;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  linkLast(e);<span class="comment">//默认把新元素链接到链表尾部</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; l = last;<span class="comment">//用l 记录原来的最后一个结点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建新结点</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">//现在的新结点是最后一个结点了</span></span><br><span class="line">  last = newNode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果l==null，说明原来的链表是空的</span></span><br><span class="line">  <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">//那么新结点同时也是第一个结点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">//否则把新结点链接到原来的最后一个结点的next中</span></span><br><span class="line">    l.next = newNode;</span><br><span class="line">  <span class="comment">//元素个数增加</span></span><br><span class="line">  size++;</span><br><span class="line">  <span class="comment">//修改次数增加</span></span><br><span class="line">  modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//分o是否为空两种情况</span></span><br><span class="line">  <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//找到o对应的结点x</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">        unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//找到o对应的结点x</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">        unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;<span class="comment">//x是要被删除的结点</span></span><br><span class="line">  <span class="comment">// assert x != null;</span></span><br><span class="line">  <span class="keyword">final</span> E element = x.item;<span class="comment">//被删除结点的数据</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; next = x.next;<span class="comment">//被删除结点的下一个结点</span></span><br><span class="line">  <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="comment">//被删除结点的上一个结点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果被删除结点的前面没有结点，说明被删除结点是第一个结点</span></span><br><span class="line">  <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//那么被删除结点的下一个结点变为第一个结点</span></span><br><span class="line">    first = next;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是第一个结点</span></span><br><span class="line">    <span class="comment">//被删除结点的上一个结点的next指向被删除结点的下一个结点</span></span><br><span class="line">    prev.next = next;</span><br><span class="line">    <span class="comment">//断开被删除结点与上一个结点的链接</span></span><br><span class="line">    x.prev = <span class="keyword">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果被删除结点的后面没有结点，说明被删除结点是最后一个结点</span></span><br><span class="line">  <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//那么被删除结点的上一个结点变为最后一个结点</span></span><br><span class="line">    last = prev;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是最后一个结点</span></span><br><span class="line">    <span class="comment">//被删除结点的下一个结点的prev执行被删除结点的上一个结点</span></span><br><span class="line">    next.prev = prev;</span><br><span class="line">    <span class="comment">//断开被删除结点与下一个结点的连接</span></span><br><span class="line">    x.next = <span class="keyword">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//把被删除结点的数据也置空，使得GC回收</span></span><br><span class="line">  x.item = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//元素个数减少</span></span><br><span class="line">  size--;</span><br><span class="line">  <span class="comment">//修改次数增加</span></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//返回被删除结点的数据</span></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h1><p>Set接口是Collection的子接口，set接口没有提供额外的方法。因此Set集合支持的遍历方式和Collection集合一样：foreach和Iterator。</p><p>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。</p><p>Set的常用实现类有：HashSet、TreeSet、LinkedHashSet。</p><blockquote><p>Set系列的集合：不可重复的<br>Set系列的集合，有有序的也有无序的。HashSet无序的，TreeSet按照元素的大小顺序遍历，LinkedHashSet按照元素的添加顺序遍历。</p></blockquote><h2 id="实现类的特点"><a href="#实现类的特点" class="headerlink" title="实现类的特点"></a>实现类的特点</h2><h3 id="HashSet和LinkedHashSet"><a href="#HashSet和LinkedHashSet" class="headerlink" title="HashSet和LinkedHashSet"></a>HashSet和LinkedHashSet</h3><p>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。</p><p>HashSet底层是HashMap实现。添加到HashSet的元素是作为HashMap的key，value是一个Object类型的常量对象PRESENT。依赖于元素的hashCode()和equals()保证元素的不可重复，存储位置和hashCode()值有关，根据hashCode()来算出它在底层table数组中的[index]</p><p>HashSet 和LinkedHashSet按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。HashSet 和LinkedHashSet集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。因此，存储到HashSet和LinkedHashSet的元素要重写hashCode和equals方法。</p><p>LinkedHashSet是HashSet的子类，它在HashSet的基础上，在结点中增加两个属性before和after维护了结点的前后添加顺序。LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。</p><p>底层是LinkedHashMap。添加到LinkedHashSet的元素是作为LinkedHashMap的key，value是一个Object类型的常量对象PRESENT。LinkedHashSet是HashSet的子类，比父类多维护了元素的添加顺序。当且仅当，你既想要元素不可重复，又要保证元素的添加顺序时，再使用它。</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>底层是TreeMap实现。添加到TreeSet的元素是作为TreeMap的key，value是一个Object类型的常量对象PRESENT。</p><p>依赖于元素的大小，要么是java.lang.Comparable接口compareTo(Object obj)，要么是java.util.Comparator接口的compare(Object o1, Object o2)来比较元素的大小。认为大小相等的两个元素就是重复元素。</p><p>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。使用元素的自然顺序(Comparable)对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。</p><h1 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h1><p>用来存储键值对，映射关系的集合。所有的Map的key都不能重复。</p><p>键值对、映射关系的类型：Entry类型</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entry接口是Map接口的内部接口。所有的Map的键值对的类型都实现了这个接口。</span><br><span class="line">HashMap中的映射关系，是有一个内部类来实现Entry的接口，JDK1.7是一个叫做Entry的内部类实现Entry接口。</span><br><span class="line">JDK1.8是一个叫做Node的内部类实现Entry接口。</span><br><span class="line">TreeMap中的映射关系，是有一个内部类Entry来实现Entry的接口</span><br></pre></td></tr></table></figure><ul><li><p>Map 中的 key 和 value 都可以是任何引用类型的数据</p></li><li><p>Map 中的 key 不允许重复</p></li><li><p>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value。</p></li></ul><p>Map 接口提供三种collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。映射顺序 定义为迭代器在映射的 collection 视图上返回其元素的顺序。某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap 类</p><h2 id="Map的方法"><a href="#Map的方法" class="headerlink" title="Map的方法"></a>Map的方法</h2><p>1、添加操作</p><ul><li><p>Object put(Object key,Object value)</p></li><li><p>void putAll(Map t)</p></li></ul><p>2、删除</p><ul><li><p>void clear()</p></li><li><p>Object remove(Object key)</p></li></ul><p>3、元素查询的操作</p><ul><li><p>Object get(Object key)</p></li><li><p>boolean containsKey(Object key)</p></li><li><p>boolean containsValue(Object value)</p></li><li><p>boolean isEmpty()</p></li></ul><p>4、元视图操作的方法：</p><ul><li><p>Set keySet()</p></li><li><p>Collection values()</p></li><li><p>Set entrySet()</p></li></ul><p>5、其他方法</p><ul><li>int size()</li></ul><h2 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h2><p>Collection集合的遍历：（1）foreach（2）通过Iterator对象遍历</p><p>Map的遍历，不能支持foreach</p><p>（1）分开遍历：单独遍历所有key</p><p>​      单独遍历所有value</p><p>（2）成对遍历：遍历的是映射关系Map.Entry</p><p>Map.Entry是Map接口的内部接口。每一种Map内部有自己的Map.Entry的实现类</p><p>在Map中存储数据，实际上是将Key—-&gt;value的数据存储在Map.Entry接口的实例中，再在Map集合中插入Map.Entry的实例化对象</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/map.png" alt="map"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMap</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">"许仙"</span>, <span class="string">"白娘子"</span>);</span><br><span class="line">map.put(<span class="string">"董永"</span>, <span class="string">"七仙女"</span>);</span><br><span class="line">map.put(<span class="string">"牛郎"</span>, <span class="string">"织女"</span>);</span><br><span class="line">map.put(<span class="string">"许仙"</span>, <span class="string">"小青"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"所有的key:"</span>);</span><br><span class="line">Set keySet = map.keySet();</span><br><span class="line"><span class="keyword">for</span> (Object key : keySet) &#123;</span><br><span class="line">System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"所有的value："</span>);</span><br><span class="line">Collection values = map.values();</span><br><span class="line"><span class="keyword">for</span> (Object value : values) &#123;</span><br><span class="line">System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"所有的映射关系"</span>);</span><br><span class="line">Set entrySet = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Object entry : entrySet) &#123;</span><br><span class="line">System.out.println(entry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map的实现类们的区别"><a href="#Map的实现类们的区别" class="headerlink" title="Map的实现类们的区别"></a>Map的实现类们的区别</h2><ul><li><p>HashMap：</p><p>依据key的hashCode()和equals()来保证key是否重复。</p><p>key如果重复，新的value会替换旧的value。</p><p>hashCode()决定了映射关系在table数组中的存储的位置，index = hash(key.hashCode()) &amp; table.length-1 </p><p>HashMap的底层实现：JDK1.7是数组+链表；JDK1.8是数组+链表/红黑树</p></li><li><p>TreeMap</p><p>依据key的大小来保证key是否重复。key如果重复，新的value会替换旧的value。</p><p>key的大小依赖于，java.lang.Comparable或java.util.Comparator。</p></li><li><p>LinkedHashMap</p><p>依据key的hashCode()和equals()来保证key是否重复。key如果重复，新的value会替换旧的value。</p><p>LinkedHashMap是HashMap的子类，比HashMap多了添加顺序</p></li><li><p>Properties</p><p>Properties 类是 Hashtable 的子类，Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。</p><p>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Properties properties = System.getProperties();</span><br><span class="line">String p2 = properties.getProperty(<span class="string">"file.encoding"</span>);<span class="comment">//当前源文件字符编码</span></span><br><span class="line">System.out.println(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h2><h3 id="JDK1-6源码："><a href="#JDK1-6源码：" class="headerlink" title="JDK1.6源码："></a>JDK1.6源码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//this.loadFactor加载因子，影响扩容的频率</span></span><br><span class="line">  <span class="comment">//DEFAULT_LOAD_FACTOR：默认加载因子0.75</span></span><br><span class="line">  <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">  <span class="comment">//threshold阈值 = 容量 * 加载因子</span></span><br><span class="line">  <span class="comment">//threshold阈值，当size达到threhold时，考虑扩容</span></span><br><span class="line">  <span class="comment">//扩容需要两个条件同时满足：（1）size &gt;= threhold （2）table[index]！=null，即新映射关系要存入的位置非空</span></span><br><span class="line">  threshold = (<span class="keyword">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</span><br><span class="line">  <span class="comment">//table是数组，</span></span><br><span class="line">  <span class="comment">//DEFAULT_INITIAL_CAPACITY：默认是16</span></span><br><span class="line">  table = <span class="keyword">new</span> Entry[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">  init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK1-7源码："><a href="#JDK1-7源码：" class="headerlink" title="JDK1.7源码："></a>JDK1.7源码：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//DEFAULT_INITIAL_CAPACITY：默认初始容量16</span></span><br><span class="line">  <span class="comment">//DEFAULT_LOAD_FACTOR：默认加载因子0.75</span></span><br><span class="line">  <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//校验initialCapacity合法性</span></span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">  <span class="comment">//校验initialCapacity合法性                                       </span></span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">  <span class="comment">//校验loadFactor合法性</span></span><br><span class="line">  <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line">                                               </span><br><span class="line"><span class="comment">//加载因子，初始化为0.75</span></span><br><span class="line">  <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">  <span class="comment">// threshold 初始为初始容量                                  </span></span><br><span class="line">  threshold = initialCapacity;</span><br><span class="line">  init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果table数组是空的，那么先创建数组</span></span><br><span class="line">  <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">    <span class="comment">//threshold一开始是初始容量的值</span></span><br><span class="line">    inflateTable(threshold);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果key是null，单独处理</span></span><br><span class="line">  <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对key的hashCode进行干扰，算出一个hash值</span></span><br><span class="line">  <span class="keyword">int</span> hash = hash(key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算新的映射关系应该存到table[i]位置，</span></span><br><span class="line">  <span class="comment">//i = hash &amp; table.length-1，可以保证i在[0,table.length-1]范围内</span></span><br><span class="line">  <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查table[i]下面有没有key与我新的映射关系的key重复，如果重复替换value</span></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">    Object k;</span><br><span class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      e.value = value;</span><br><span class="line">      e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//添加新的映射关系</span></span><br><span class="line">  addEntry(hash, key, value, i);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">  <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);<span class="comment">//容量是等于toSize值的最接近的2的n次方</span></span><br><span class="line">  <span class="comment">//计算阈值 = 容量 * 加载因子</span></span><br><span class="line">  threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">//创建Entry[]数组，长度为capacity</span></span><br><span class="line">  table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">  initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果key是null，直接存入[0]的位置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判断是否有重复的key，如果有重复的，就替换value</span></span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      e.value = value;</span><br><span class="line">      e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  modCount++;</span><br><span class="line">  <span class="comment">//把新的映射关系存入[0]的位置，而且key的hash值用0表示</span></span><br><span class="line">  addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判断是否需要库容</span></span><br><span class="line">  <span class="comment">//扩容：（1）size达到阈值（2）table[i]正好非空</span></span><br><span class="line">  <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">    <span class="comment">//table扩容为原来的2倍，并且扩容后，会重新调整所有映射关系的存储位置</span></span><br><span class="line">    resize(<span class="number">2</span> * table.length);</span><br><span class="line">    <span class="comment">//新的映射关系的hash和index也会重新计算</span></span><br><span class="line">    hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">    bucketIndex = indexFor(hash, table.length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//存入table中</span></span><br><span class="line">  createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">  Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">  <span class="comment">//原来table[i]下面的映射关系作为新的映射关系next</span></span><br><span class="line">  table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">  size++;<span class="comment">//个数增加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>put(key,value)</strong></p><ul><li><p>当第一次添加映射关系时，数组初始化为一个长度为<strong>16</strong>的<strong>HashMap$Entry</strong>的数组，这个HashMap$Entry类型是实现了java.util.<strong>Map.Entry</strong>接口</p></li><li><p>特殊考虑：如果key为null，index直接是[0]</p></li><li><p>在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p></li><li><p>计算index = table.length-1 &amp; hash;</p></li><li><p>如果table[index]下面，已经有映射关系的key与我要添加的新的映射关系的key相同了，会用新的value替换旧的value。</p></li><li><p>如果没有相同的，会把新的映射关系添加到链表的头，原来table[index]下面的Entry对象连接到新的映射关系的next中。</p></li><li><p>添加之前先判断if(size &gt;= threshold  &amp;&amp;  table[index]!=null)如果该条件为true，会扩容</p></li></ul><p>​    if ( size &gt;= threshold  &amp;&amp;  table[index]!=null ) {</p><p>​        ①会扩容</p><p>​        ②会重新计算key的hash</p><p>​        ③会重新计算index</p><p>​    }</p><p><strong>get(key)</strong></p><ul><li><p>计算key的hash值，用这个方法hash(key)</p></li><li><p>找index = table.length-1 &amp; hash;</p></li><li><p>如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就返回它的value</p></li></ul><p><strong>remove(key)</strong></p><ul><li><p>计算key的hash值，用这个方法hash(key)</p></li><li><p>找index = table.length-1 &amp; hash;</p></li><li><p>如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</p></li></ul><h3 id="JDK1-8源码"><a href="#JDK1-8源码" class="headerlink" title="JDK1.8源码"></a>JDK1.8源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">几个常量和变量：</span><br><span class="line">（<span class="number">1</span>）DEFAULT_INITIAL_CAPACITY：默认的初始容量 <span class="number">16</span></span><br><span class="line">（<span class="number">2</span>）MAXIMUM_CAPACITY：最大容量  <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br><span class="line">（<span class="number">3</span>）DEFAULT_LOAD_FACTOR：默认加载因子 <span class="number">0.75</span></span><br><span class="line">（<span class="number">4</span>）TREEIFY_THRESHOLD：默认树化阈值<span class="number">8</span>，当链表的长度达到这个值后，要考虑树化</span><br><span class="line">（<span class="number">5</span>）UNTREEIFY_THRESHOLD：默认反树化阈值<span class="number">6</span>，当树中的结点的个数达到这个阈值后，要考虑变为链表</span><br><span class="line">（<span class="number">6</span>）MIN_TREEIFY_CAPACITY：最小树化容量<span class="number">64</span></span><br><span class="line">当单个的链表的结点个数达到<span class="number">8</span>，并且table的长度达到<span class="number">64</span>，才会树化。</span><br><span class="line">当单个的链表的结点个数达到<span class="number">8</span>，但是table的长度未达到<span class="number">64</span>，会先扩容</span><br><span class="line">（<span class="number">7</span>）Node&lt;K,V&gt;[] table：数组</span><br><span class="line">（<span class="number">8</span>）size：记录有效映射关系的对数，也是Entry对象的个数</span><br><span class="line">（<span class="number">9</span>）<span class="keyword">int</span> threshold：阈值，当size达到阈值时，考虑扩容</span><br><span class="line">（<span class="number">10</span>）<span class="keyword">double</span> loadFactor：加载因子，影响扩容的频率</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">  <span class="comment">// all other fields defaulted，其他字段都是默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目的：干扰hashCode值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="comment">//如果key是null，hash是0</span></span><br><span class="line">  <span class="comment">//如果key非null，用key的hashCode值 与 key的hashCode值高16进行异或</span></span><br><span class="line">  <span class="comment">//即就是用key的hashCode值高16位与低16位进行了异或的干扰运算</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">index = hash &amp; table.length-1</span></span><br><span class="line"><span class="comment">如果用key的原始的hashCode值  与 table.length-1 进行按位与，那么基本上高16没机会用上。</span></span><br><span class="line"><span class="comment">这样就会增加冲突的概率，为了降低冲突的概率，把高16位加入到hash信息中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; <span class="comment">//数组</span></span><br><span class="line">  Node&lt;K,V&gt; p; <span class="comment">//一个结点</span></span><br><span class="line">  <span class="keyword">int</span> n, i;<span class="comment">//n是数组的长度   i是下标</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//tab和table等价</span></span><br><span class="line">  <span class="comment">//如果table是空的</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)&#123;</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">tab = resize();</span></span><br><span class="line"><span class="comment">n = tab.length;*/</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">如果table是空的，resize()完成了①创建了一个长度为16的数组②threshold = 12</span></span><br><span class="line"><span class="comment">n = 16</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//i = (n - 1) &amp; hash ，下标 = 数组长度-1 &amp; hash</span></span><br><span class="line">  <span class="comment">//p = tab[i] 第1个结点</span></span><br><span class="line">  <span class="comment">//if(p==null) 条件满足的话说明 table[i]还没有元素</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//把新的映射关系直接放入table[i]</span></span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//newNode（）方法就创建了一个Node类型的新结点，新结点的next是null</span></span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; </span><br><span class="line">    K k;</span><br><span class="line">    <span class="comment">//p是table[i]中第一个结点</span></span><br><span class="line">    <span class="comment">//if(table[i]的第一个结点与新的映射关系的key重复)</span></span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">      e = p;<span class="comment">//用e记录这个table[i]的第一个结点</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123;<span class="comment">//如果table[i]第一个结点是一个树结点</span></span><br><span class="line">      <span class="comment">//单独处理树结点</span></span><br><span class="line">      <span class="comment">//如果树结点中，有key重复的，就返回那个重复的结点用e接收，即e!=null</span></span><br><span class="line">      <span class="comment">//如果树结点中，没有key重复的，就把新结点放到树中，并且返回null，即e=null</span></span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//table[i]的第一个结点不是树结点，也与新的映射关系的key不重复</span></span><br><span class="line">      <span class="comment">//binCount记录了table[i]下面的结点的个数</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="comment">//如果p的下一个结点是空的，说明当前的p是最后一个结点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//把新的结点连接到table[i]的最后</span></span><br><span class="line">          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//如果binCount&gt;=8-1，达到7个时</span></span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)&#123; <span class="comment">// -1 for 1st</span></span><br><span class="line">            <span class="comment">//要么扩容，要么树化</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果key重复了，就跳出for循环，此时e结点记录的就是那个key重复的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = e;<span class="comment">//下一次循环，e=p.next，就类似于e=e.next，往链表下移动</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果这个e不是null，说明有key重复，就考虑替换原来的value</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)&#123;</span><br><span class="line">        e.value = value;</span><br><span class="line">      &#125;</span><br><span class="line">      afterNodeAccess(e);<span class="comment">//什么也没干</span></span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++modCount;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//元素个数增加</span></span><br><span class="line">  <span class="comment">//size达到阈值</span></span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)&#123;</span><br><span class="line">    resize();<span class="comment">//一旦扩容，重新调整所有映射关系的位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  afterNodeInsertion(evict);<span class="comment">//什么也没干</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//oldTab原来的table</span></span><br><span class="line">  <span class="comment">//oldCap：原来数组的长度</span></span><br><span class="line">  <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//oldThr：原来的阈值</span></span><br><span class="line">  <span class="keyword">int</span> oldThr = threshold;<span class="comment">//最开始threshold是0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//newCap，新容量</span></span><br><span class="line">  <span class="comment">//newThr：新阈值</span></span><br><span class="line">  <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//说明原来不是空数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//是否达到数组最大限制</span></span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">              oldCap &gt;= DEFAULT_INITIAL_CAPACITY)&#123;</span><br><span class="line">      <span class="comment">//newCap = 旧的容量*2 ，新容量&lt;最大数组容量限制</span></span><br><span class="line">      <span class="comment">//新容量：32,64，...</span></span><br><span class="line">      <span class="comment">//oldCap &gt;= 初始容量16</span></span><br><span class="line">      <span class="comment">//新阈值重新算 = 24，48 ....</span></span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)&#123; <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//新容量是默认初始化容量16</span></span><br><span class="line">    <span class="comment">//新阈值= 默认的加载因子 * 默认的初始化容量 = 0.75*16 = 12</span></span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  threshold = newThr;<span class="comment">//阈值赋值为新阈值12，24.。。。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建了一个新数组，长度为newCap，16，32,64.。。</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;<span class="comment">//原来不是空数组</span></span><br><span class="line">    <span class="comment">//把原来的table中映射关系，倒腾到新的table中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;<span class="comment">//e是table下面的结点</span></span><br><span class="line">        oldTab[j] = <span class="keyword">null</span>;<span class="comment">//把旧的table[j]位置清空</span></span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)<span class="comment">//如果是最后一个结点</span></span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;<span class="comment">//重新计算e的在新table中的存储位置，然后放入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果e是树结点</span></span><br><span class="line">          <span class="comment">//把原来的树拆解，放到新的table</span></span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">把原来table[i]下面的整个链表，重新挪到了新的table中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建一个新结点</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, index; </span><br><span class="line">  Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="comment">//MIN_TREEIFY_CAPACITY：最小树化容量64</span></span><br><span class="line">  <span class="comment">//如果table是空的，或者  table的长度没有达到64</span></span><br><span class="line">  <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">    resize();<span class="comment">//先扩容</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//用e记录table[index]的结点的地址</span></span><br><span class="line">    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">do...while，把table[index]链表的Node结点变为TreeNode类型的结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">        hd = p;<span class="comment">//hd记录根结点</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        p.prev = tl;</span><br><span class="line">        tl.next = p;</span><br><span class="line">      &#125;</span><br><span class="line">      tl = p;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果table[index]下面不是空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">      hd.treeify(tab);<span class="comment">//将table[index]下面的链表进行树化</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加过程</strong></p><ul><li><p>当第一次添加映射关系时，数组初始化为一个长度为<strong>16</strong>的<strong>HashMap$Node</strong>的数组，这个HashMap$Node类型是实现了java.util.<strong>Map.Entry</strong>接口</p></li><li><p>在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p></li></ul><blockquote><p>JDK1.8关于hash(key)方法的实现比JDK1.7要简洁。 key.hashCode() ^ key.Code()&gt;&gt;&gt;16;</p></blockquote><ul><li><p>计算index = table.length-1 &amp; hash;</p></li><li><p>如果table[index]下面，已经有映射关系的key与我要添加的新的映射关系的key相同了，会用新的value替换旧的value。</p></li><li><p>如果没有相同的，</p><p>① table[index]链表的长度没有达到8个，会把新的映射关系添加到链表的尾</p><p>② table[index]链表的长度达到8个，但是table.length没有达到64，会先对table进行扩容，然后再添加</p><p>③ table[index]链表的长度达到8个，并且table.length达到64，会先把该分支进行树化，结点的类型变为TreeNode，然后把链表转    为一棵红黑树</p><p>④table[index]本来就已经是红黑树了，那么直接连接到树中，可能还会考虑考虑左旋右旋以保证树的平衡问题</p></li><li><p>添加完成后判断 if (size &gt; threshold ){</p><p>① 会扩容</p><p>② 会重新计算key的hash</p><p>③ 会重新计算index</p></li></ul><p>​    }</p><p><strong>remove(key)</strong></p><ul><li>计算key的hash值，用这个方法hash(key)</li><li>找index = table.length-1 &amp; hash;</li><li>如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</li><li>如果table[index]下面原来是红黑树，结点删除后，个数小于等于6，会把红黑树变为链表</li></ul><h3 id="关于HashMap的面试问题"><a href="#关于HashMap的面试问题" class="headerlink" title="关于HashMap的面试问题"></a>关于HashMap的面试问题</h3><p>1、HashMap的底层实现</p><blockquote><p>答：JDK1.7是数组+链表，JDK1.8是数组+链表/红黑树</p></blockquote><p>2、HashMap的数组的元素类型</p><blockquote><p>答：java.util.Map$Entry接口类型。</p><p>JDK1.7的HashMap中有内部类Entry实现Entry接口</p><p>JDK1.8的HashMap中有内部类Node和TreeNode类型实现Entry接口</p></blockquote><p>3、为什么要使用数组？</p><blockquote><p> 答：因为数组的访问的效率高</p></blockquote><p>4、为什么数组还需要链表？或问如何解决hash或[index]冲突问题？</p><blockquote><p> 答：为了解决hash和[index]冲突问题</p><p> （1）两个不相同的key的hashCode值本身可能相同</p><p> （2）两个hashCode不相同的key，通过hash(key)以及 hash &amp; table.length-1运算得到的[index]可能相同</p><p> 那么意味着table[index]下可能需要存储多个Entry的映射关系对象，所以需要链表</p></blockquote><p>5、HashMap的数组的初始化长度</p><blockquote><p>答：默认的初始容量值是16</p></blockquote><p>6、HashMap的映射关系的存储索引index如何计算</p><blockquote><p>答：hash &amp; table.length-1</p></blockquote><p>7、为什么要使用hashCode()? 空间换时间</p><blockquote><p>答：因为hashCode()是一个整数值，可以用来直接计算index，效率比较高，用数组这种结构虽然会浪费一些空间，但是可以提高查询效率。</p></blockquote><p>8、hash()函数的作用是什么</p><blockquote><p> 答：在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p><p> JDK1.8关于hash(key)方法的实现比JDK1.7要简洁。 key.hashCode() ^ key.Code()&gt;&gt;&gt;16; 因为这样可以使得hashCode的高16位信息也能参与到运算中来</p></blockquote><p>9、HashMap的数组长度为什么一定要是2的幂次方</p><blockquote><p>答：因为2的n次方-1的二进制值是前面都0，后面几位都是1，这样的话，与hash进行&amp;运算的结果就能保证在[0,table.length-1]范围内，而且是均匀的。</p></blockquote><p>10、HashMap 为什么使用 &amp;按位与运算代替%模运算？</p><blockquote><p>答：因为&amp;效率高</p></blockquote><p>11、HashMap的数组什么时候扩容？</p><blockquote><p>答：JDK1.7版：当要添加新Entry对象时发现（1）size达到threshold（2）table[index]!=null时，两个条件同时满足会扩容</p><p>JDK1.8版：当要添加新Entry对象时发现（1）size达到threshold（2）当table[index]下的结点个数达到8个但是table.length又没有达到64。两种情况满足其一都会导致数组扩容</p><p>而且数组一旦扩容，不管哪个版本，都会导致所有映射关系重新调整存储位置。</p></blockquote><p>12、如何计算扩容阈值(临界值)？</p><blockquote><p>答：threshold = capacity * loadfactor</p></blockquote><p>13、loadFactor为什么是0.75，如果是1或者0.1呢有什么不同？</p><blockquote><p>答：1的话，会导致某个table[index]下面的结点个数可能很长</p><p>0.1的话，会导致数组扩容的频率太高</p></blockquote><p>14、JDK1.8的HashMap什么时候树化？</p><blockquote><p>答：当table[index]下的结点个数达到8个但是table.length已经达到64</p></blockquote><p>15、JDK1.8的HashMap什么时候反树化？</p><blockquote><p>答：当table[index]下的树结点个数少于6个</p></blockquote><p>16、JDK1.8的HashMap为什么要树化？</p><blockquote><p>答：因为当table[index]下的结点个数超过8个后，查询效率就低下了，修改为红黑树的话，可以提高查询效率</p></blockquote><p>17、JDK1.8的HashMap为什么要反树化？</p><blockquote><p>答：因为因为当table[index]下树的结点个数少于6个后，使用红黑树反而过于复杂了，此时使用链表既简洁又效率也不错</p></blockquote><p>18、作为HashMap的key类型重写equals和hashCode方法有什么要求</p><p>​    （1）equals与hashCode一起重写</p><p>​    （2）重写equals()方法，但是有一些注意事项；</p><ul><li>自反性：x.equals(x)必须返回true。<br>对称性：x.equals(y)与y.equals(x)的返回值必须相等。<br>传递性：x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)必须为true。<br>一致性：如果对象x和y在equals()中使用的信息都没有改变，那么x.equals(y)值始终不变。<br>非null：x不是null，y为null，则x.equals(y)必须为false。</li></ul><p>​    （3）重写hashCode（）的注意事项</p><ul><li>如果equals返回true的两个对象，那么hashCode值一定相同，并且只要参与equals判断属性没有修改，hashCode值也不能修改；<br>如果equals返回false的两个对象，那么hashCode值可以相同也可以不同；<br>如果hashCode值不同的，equals一定要返回false；<br>hashCode不宜过简单，太简单会导致冲突严重，hashCode也不宜过于复杂，会导致性能低下；</li></ul><p>19、为什么大部分 hashcode 方法使用 31？</p><blockquote><p> 答：因为31是一个不大不小的素数</p></blockquote><p>20、请问已经存储到HashMap中的key的对象属性是否可以修改？为什么？</p><blockquote><p>答：如果该属性参与hashCode的计算，那么不要修改。因为一旦修改hashCode()已经不是原来的值。<br>而存储到HashMap中时，key的hashCode()–&gt;hash()–&gt;hash已经确定了，不会重新计算。用新的hashCode值再查询get(key)/删除remove(key)时，算的hash值与原来不一样就不找不到原来的映射关系了。</p></blockquote><p>21、所以为什么，我们实际开发中，key的类型一般用String和Integer</p><blockquote><p>答：因为他们不可变。</p></blockquote><p>22、为什么HashMap中的Node或Entry类型的hash变量与key变量加final声明？</p><blockquote><p> 答：因为不希望你修改hash和key值</p></blockquote><p>23、为什么HashMap中的Node或Entry类型要单独存储hash？</p><blockquote><p> 答：为了在添加、删除、查找过程中，比较hash效率更高，不用每次重新计算key的hash值</p></blockquote><p>24、请问已经存储到HashMap中的value的对象属性是否可以修改？为什么？</p><blockquote><p>答：可以。因为我们存储、删除等都是根据key，和value无关。</p></blockquote><p>25、如果key是null是如何存储的？</p><blockquote><p>答：会存在table[0]中</p></blockquote><h1 id="集合框架图"><a href="#集合框架图" class="headerlink" title="集合框架图"></a>集合框架图</h1><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/Collection12.png" alt="collection"></p>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用类</title>
      <link href="/2020/06/17/java-common-class/"/>
      <url>/2020/06/17/java-common-class/</url>
      
        <content type="html"><![CDATA[<h1 id="包装类Wrapper"><a href="#包装类Wrapper" class="headerlink" title="包装类Wrapper"></a>包装类Wrapper</h1><p>Java并不是纯面向对象的语言。Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的。基本数据类型有它的优势：性能（效率高，节省空间）。</p><p>但是我们在实际使用中经常需要将基本数据类型转化成对象，便于操作。比如：（1）集合的操作，（2）使用Object类型接收任意类型的数据等，（3）泛型实参，这时，我们就需要将基本数据类型数据转化为对象。</p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>包装类均位于java.lang包，包装类和基本数据类型的对应关系</p><table><thead><tr><th align="center">序号</th><th align="center">基本数据类型</th><th align="center">包装类</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">byte</td><td align="center">Byte</td></tr><tr><td align="center">2</td><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center">3</td><td align="center">int</td><td align="center">Integer</td></tr><tr><td align="center">4</td><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">5</td><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">6</td><td align="center">double</td><td align="center">Double</td></tr><tr><td align="center">7</td><td align="center">char</td><td align="center">Character</td></tr><tr><td align="center">8</td><td align="center">boolean</td><td align="center">Boolean</td></tr><tr><td align="center">9</td><td align="center">void</td><td align="center">Void</td></tr></tbody></table><h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h2><p>JDK1.5之前需要手动装箱与拆箱，JDK1.5之后支持自动装箱与自动拆箱。</p><p>注意：只能与自己对应的类型之间才能实现自动装箱与拆箱。</p><p>装箱：把基本数据类型转为包装类对象。</p><blockquote><p>转为包装类的对象，是为了使用专门为对象设计的API和特性</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本数据类型就自动的封装到与它相同类型的包装中，如：</span></span><br><span class="line">Integer i = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//本质上是，编译器编译时为我们添加了：</span></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>拆箱：把包装类对象拆为基本数据类型。</p><blockquote><p>转为基本数据类型，一般是因为需要运算，Java中的大多数运算符是为基本数据类型设计的。比较、算术等</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包装类对象自动转换成基本类型数据。如：</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//本质上，编译器编译时为我们添加了：</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="keyword">new</span> Integer(<span class="number">100</span>).intValue();</span><br></pre></td></tr></table></figure><h2 id="包装类的一些API"><a href="#包装类的一些API" class="headerlink" title="包装类的一些API"></a>包装类的一些API</h2><p>1、基本数据类型和字符串之间的转换</p><p>（1）把基本数据类型转为字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//String str = a;//错误的</span></span><br><span class="line"><span class="comment">//方式一：</span></span><br><span class="line">String str = a + <span class="string">""</span>;</span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line">String str = String.valueOf(a);</span><br></pre></td></tr></table></figure><p>（2）把字符串转为基本数据类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = Integer.parseInt(<span class="string">"整数的字符串"</span>);</span><br><span class="line"><span class="keyword">double</span> a = Double.parseDouble(<span class="string">"小数的字符串"</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = Boolean.parseBoolean(<span class="string">"true或false"</span>);</span><br></pre></td></tr></table></figure><p>2、数据类型的最大最小值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.MAX_VALUE和Integer.MIN_VALUE</span><br><span class="line">Long.MAX_VALUE和Long.MIN_VALUE</span><br><span class="line">Double.MAX_VALUE和Double.MIN_VALUE</span><br></pre></td></tr></table></figure><p>3、转大小写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Character.toUpperCase(<span class="string">'x'</span>);</span><br><span class="line">Character.toLowerCase(<span class="string">'X'</span>);</span><br></pre></td></tr></table></figure><p>4、转进制</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.toBinaryString(<span class="keyword">int</span> i) </span><br><span class="line">Integer.toHexString(<span class="keyword">int</span> i)</span><br><span class="line">Integer.toOctalString(<span class="keyword">int</span> i)</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="包装类对象的缓存问题"><a href="#包装类对象的缓存问题" class="headerlink" title="包装类对象的缓存问题"></a>包装类对象的缓存问题</h2><table><thead><tr><th>包装类</th><th>缓存对象</th></tr></thead><tbody><tr><td>Byte</td><td>-128~127</td></tr><tr><td>Short</td><td>-128~127</td></tr><tr><td>Integer</td><td>-128~127</td></tr><tr><td>Long</td><td>-128~127</td></tr><tr><td>Float</td><td>没有</td></tr><tr><td>Double</td><td>没有</td></tr><tr><td>Character</td><td>0~127</td></tr><tr><td>Boolean</td><td>true和false</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>;</span><br><span class="line">Integer j = <span class="number">1</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="number">128</span>;</span><br><span class="line">Integer j = <span class="number">128</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);<span class="comment">//新new的在堆中</span></span><br><span class="line">Integer j = <span class="number">1</span>;<span class="comment">//这个用的是缓冲的常量对象，在方法区</span></span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);<span class="comment">//新new的在堆中</span></span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);<span class="comment">//另一个新new的在堆中</span></span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//true，凡是和基本数据类型比较，都会先拆箱，按照基本数据类型的规则比较</span></span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h2><p>1、字符串String类型本身是final声明的，意味着我们不能继承String。</p><p>2、字符串的对象也是不可变对象，意味着一旦进行修改，就会产生新对象</p><blockquote><p>我们修改了字符串后，如果想要获得新的内容，必须重新接受。</p><p>如果程序中涉及到大量的字符串的修改操作，那么此时的时空消耗比较高。可能需要考虑使用StringBuilder或StringBuffer。</p></blockquote><p>3、String对象内部是用字符数组进行保存的</p><blockquote><p>JDK1.9之前有一个char[] value数组，JDK1.9之后byte[]数组</p></blockquote><p>4、String类中这个char[] values数组也是final修饰的，意味着这个数组不可变，然后它是private修饰，外部不能直接操作它，String类型提供的所有的方法都是用新对象来表示修改后内容的，所以保证了String对象的不可变。</p><p>5、就因为字符串对象设计为不可变，那么所以字符串有常量池来保存很多常量对象</p><p>常量池在方法区。</p><p>如果细致的划分：</p><p>（1）JDK1.6及其之前：方法区</p><p>（2）JDK1.7：堆，即在堆中单独划分了一块内存</p><p>（3）JDK1.8：元空间（meta space），即类似于方法区</p><h2 id="String对象的创建"><a href="#String对象的创建" class="headerlink" title="String对象的创建"></a>String对象的创建</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = “hello”;</span><br><span class="line">String  s1 = <span class="keyword">new</span> String();   <span class="comment">//  本质上  this.value = new char[0];</span></span><br><span class="line">String  s2 = <span class="keyword">new</span> String(String original);  <span class="comment">//this.value = original.value;</span></span><br><span class="line">String  s3 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a);  <span class="comment">//this.value = Arrays.copyOf(value, value.length);</span></span><br><span class="line">String  s4 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> count)</span><br><span class="line"><span class="comment">//.......</span></span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/string1.png" alt="String"></p><h2 id="字符串对象是如何存储的"><a href="#字符串对象是如何存储的" class="headerlink" title="字符串对象是如何存储的"></a>字符串对象是如何存储的</h2><p>字符串常量存储在字符串常量池，目的是共享</p><p>字符串非常量对象存储在堆中。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/string2.png" alt="String"></p><h2 id="String的拼接"><a href="#String的拼接" class="headerlink" title="String的拼接"></a>String的拼接</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/string3.png" alt="String"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/string4.png" alt="String"></p><p>结论：<br>常量与常量的拼接结果在常量池<br>只要其中有一个是变量，结果就在堆中<br>如果拼接的结果调用intern()方法，就在常量池中</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/string5.png" alt="String"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/string6.png" alt="String"></p><h2 id="字符串对象的比较"><a href="#字符串对象的比较" class="headerlink" title="字符串对象的比较"></a>字符串对象的比较</h2><p>1、==：比较是对象的地址</p><blockquote><p>只有两个字符串变量都是指向字符串的常量对象时，才会返回true</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"hello"</span>;</span><br><span class="line">String str2 = <span class="string">"hello"</span>;</span><br><span class="line">str1 == str2<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>2、equals：比较是对象的内容，因为String类型重写equals，区分大小写</p><p>只要两个字符串的字符内容相同，就会返回true</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">str1.equals(strs) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>3、equalsIgnoreCase：比较的是对象的内容，不区分大小写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"HELLO"</span>);</span><br><span class="line">str1.equalsIgnoreCase(strs) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>4、compareTo：String类型重写了Comparable接口的抽象方法，自然排序，按照字符的Unicode编码值进行比较大小的，严格区分大小写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"hello"</span>;</span><br><span class="line">String str2 = <span class="string">"world"</span>;</span><br><span class="line">str1.compareTo(str2) <span class="comment">//小于0的值</span></span><br></pre></td></tr></table></figure><p>5、compareToIgnoreCase：不区分大小写，其他按照字符的Unicode编码值进行比较大小</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"HELLO"</span>);</span><br><span class="line">str1.compareToIgnoreCase(str2)  <span class="comment">//等于0</span></span><br></pre></td></tr></table></figure><h2 id="空字符串的比较"><a href="#空字符串的比较" class="headerlink" title="空字符串的比较"></a>空字符串的比较</h2><p>1、哪些是空字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">""</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String();</span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>空字符串：长度为0</p><p>2、如何判断某个字符串是否是空字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">""</span>.equals(str))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str!=<span class="keyword">null</span>  &amp;&amp; str.isEmpty())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str!=<span class="keyword">null</span> &amp;&amp; str.equals(<span class="string">""</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str!=<span class="keyword">null</span> &amp;&amp; str.length()==<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="字符串的对象的个数"><a href="#字符串的对象的个数" class="headerlink" title="字符串的对象的个数"></a>字符串的对象的个数</h2><p>1、字符串常量对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">"hello"</span>;<span class="comment">//1个，在常量池中</span></span><br></pre></td></tr></table></figure><p>2、字符串的普通对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String();</span><br><span class="line">String str22 = <span class="keyword">new</span> String(<span class="string">""</span>);</span><br><span class="line"><span class="comment">//两个对象，一个是常量池中的空字符串对象，一个是堆中的空字符串对象</span></span><br><span class="line"><span class="comment">//堆中的这个字符串对象char[]的value数组，指向常量池中“hello”的char[]的value</span></span><br></pre></td></tr></table></figure><p>3、字符串的普通对象和常量对象一起</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">//str3首先指向堆中的一个字符串对象，然后堆中字符串的value数组指向常量池中常量对象的value数组</span></span><br></pre></td></tr></table></figure><h2 id="字符串拼接结果"><a href="#字符串拼接结果" class="headerlink" title="字符串拼接结果"></a>字符串拼接结果</h2><p>原则：</p><p>（1）常量+常量：结果是常量池</p><p>（2）常量与变量 或 变量与变量：结果是堆</p><p>（3）拼接后调用intern方法：结果在常量池</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = <span class="string">"helloworld"</span>;</span><br><span class="line"></span><br><span class="line">String s4 = (s1 + <span class="string">"world"</span>).intern();<span class="comment">//把拼接的结果放到常量池中</span></span><br><span class="line">String s5 = (s1 + s2).intern();</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">final</span> String s1 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">final</span> String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = <span class="string">"helloworld"</span>;</span><br><span class="line"></span><br><span class="line">String s4 = s1 + <span class="string">"world"</span>;<span class="comment">//s4字符串内容也helloworld，s1是常量，"world"常量，常量+ 常量 结果在常量池中</span></span><br><span class="line">String s5 = s1 + s2;<span class="comment">//s5字符串内容也helloworld，s1和s2都是常量，常量+ 常量 结果在常量池中</span></span><br><span class="line">String s6 = <span class="string">"hello"</span> + <span class="string">"world"</span>;<span class="comment">//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = <span class="string">"helloworld"</span>;</span><br><span class="line"></span><br><span class="line">String s4 = s1 + <span class="string">"world"</span>;<span class="comment">//s4字符串内容也helloworld，s1是变量，"world"常量，变量 + 常量的结果在堆中</span></span><br><span class="line">String s5 = s1 + s2;<span class="comment">//s5字符串内容也helloworld，s1和s2都是变量，变量 + 变量的结果在堆中</span></span><br><span class="line">String s6 = <span class="string">"hello"</span> + <span class="string">"world"</span>;<span class="comment">//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串的API"><a href="#字符串的API" class="headerlink" title="字符串的API"></a>字符串的API</h2><p><strong>常用方法</strong></p><ul><li>int length()：返回字符串的长度： return value.length;</li><li>boolean isEmpty()：判断是否是空字符串：return value.length == 0;</li><li>String toLowerCase()：使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</li><li>String toUpperCase()：使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</li><li>String trim()：返回字符串的副本，忽略前导空白和尾部空白。</li><li>boolean equals(Object obj)：比较字符串的内容</li><li>boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写</li><li>String concat(String str)：将指定字符串连接到此字符串的结尾。 等价于用“+”</li></ul><p><strong>String类和字符相关操作</strong></p><ul><li>char[] toCharArray()：将此字符串转换为一个新的字符数组</li><li>char charAt(int index)： 返回某索引处的字符return value[index];</li><li>String(char[] value)：分配一个新的 String，使其表示字符数组参数中当前包含的字符序列。</li><li>String(char[] value, int offset, int count)：分配一个新的 String，它包含取自字符数组参数一个子数组的字符。</li></ul><p><strong>String类字节与字符串操作方法</strong></p><p>编码：把字符–&gt;字节</p><ul><li>byte[] getBytes()：使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</li><li>byte[] getBytes(Charset charset) ：使用给定的 charset 将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。</li><li>byte[] getBytes(String charsetName) ：使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</li></ul><p>解码：把字节–&gt;字符</p><ul><li>String(byte[] bytes) ：通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。</li><li>String(byte[] bytes, Charset charset)：通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。</li><li>String(byte[] bytes, int offset, int length) ：通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的 String。</li><li>String(byte[] bytes, int offset, int length, Charset charset)：通过使用指定的 charset 解码指定的 byte 子数组，构造一个新的 String。</li><li>String(byte[] bytes, int offset, int length, String charsetName)：通过使用指定的字符集解码指定的 byte 子数组，构造一个新的 String。</li><li>String(byte[] bytes, String charsetName)：通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。</li></ul><p><strong>String类判断是否以指定内容开头或结尾</strong></p><ul><li>boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束。</li><li>boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始。</li><li>boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</li></ul><p><strong>String类字符串查找操作</strong></p><ul><li>boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true。</li><li>int indexOf(int ch)：返回指定字符在此字符串中第一次出现处的索引。 </li><li>int indexOf(int ch, int fromIndex)：返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 </li><li>int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引。 </li><li>int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 </li><li>int lastIndexOf(int ch)：返回指定字符在此字符串中最后一次出现处的索引。 </li><li>int lastIndexOf(int ch, int fromIndex)：返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 </li><li>int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引。 </li><li>int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</li></ul><blockquote><p>indexOf和lastIndexOf方法如果未找到都是返回-1</p></blockquote><p><strong>String类字符串截取操作</strong></p><ul><li>String substring(int beginIndex) ：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。 </li><li>String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</li></ul><p><strong>String类是否匹配正则</strong></p><ul><li>boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。</li></ul><p><strong>String类替换操作</strong></p><ul><li><p>String replace(char oldChar, char newChar)： 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 </p></li><li><p>String replace(CharSequence target, CharSequence replacement)： 使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。 </p></li><li><p>String replaceAll(String regex, String replacement)： 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 </p></li><li><p>String replaceFirst(String regex, String replacement)： 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 </p></li></ul><p><strong>String类字符串拆分操作</strong></p><ul><li><p>String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。 </p></li><li><p>String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</p></li></ul><p>面试题：字符串的length和数组的length有什么不同？</p><p>字符串的length()，数组的length属性</p><h1 id="可变字符序列：字符串缓冲区"><a href="#可变字符序列：字符串缓冲区" class="headerlink" title="可变字符序列：字符串缓冲区"></a>可变字符序列：字符串缓冲区</h1><p>1、可变字符序列：StringBuilder和StringBuffer</p><p>一个类似于 String 的字符串缓冲区，但能被修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容，所有对StringBuffer或StringBuilder对象的字符序列的修改不会产生新的StringBuffer或StringBuilder对象，这点和String很大的不同。</p><p>StringBuffer：老的，线程安全的（因为它的方法有synchronized修饰）</p><p>StringBuilder：线程不安全的</p><p>2、面试题：String和StringBuilder、StringBuffer的区别？</p><p>String：不可变对象，不可变字符序列</p><p>StringBuilder、StringBuffer： 可变字符序列</p><p>3、常用的API，StringBuilder、StringBuffer的API是完全一致的</p><p><strong>构造器</strong></p><p>StringBuffer或StringBuilder对象的创建必须用new+构造器。</p><ul><li><p>StringBuffer()  初始容量为16的字符串缓冲区</p></li><li><p>StringBuffer(int size)  构造指定容量的字符串缓冲区</p></li><li><p>StringBuffer(String str)  将内容初始化为指定字符串内容</p></li></ul><p><strong>常用方法</strong></p><ul><li><p>StringBuffer append(xx)：提供了很多的append()方法，用于进行字符串拼接</p></li><li><p>StringBuffer delete(int start,int end)：删除指定位置的内容</p></li><li><p>StringBuffer insert(int offset, xx)：在指定位置插入xx</p></li><li><p>StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str</p></li><li><p>StringBuffer reverse() ：把当前字符序列逆转</p><p>….</p></li></ul><h1 id="System系统类"><a href="#System系统类" class="headerlink" title="System系统类"></a>System系统类</h1><p>System 类包含一些有用的类字段和方法。它不能被实例化。 </p><p>在 System 类提供的设施中，有标准输入、标准输出和错误输出流；对外部定义的属性和环境变量的访问；加载文件和库的方法；还有快速复制数组的一部分的实用方法。</p><h2 id="标准输入、标准输出和错误输出流对象"><a href="#标准输入、标准输出和错误输出流对象" class="headerlink" title="标准输入、标准输出和错误输出流对象"></a>标准输入、标准输出和错误输出流对象</h2><p>PrintStream err：“标准”错误输出流。 </p><p>InputStream in：“标准”输入流。 </p><p>PrintStream out：“标准”输出流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSystem</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.print(<span class="string">"请输入成绩："</span>);</span><br><span class="line"><span class="keyword">int</span> score = input.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(score&gt;=<span class="number">0</span> &amp;&amp; score&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"成绩是："</span> + score);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.err.println(<span class="string">"输入有误，成绩应该在[0,100]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li><p>void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) ：从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。</p></li><li><p>long currentTimeMillis() ：返回以毫秒为单位的当前时间。</p></li><li><p>void exit(int status) ：终止当前正在运行的 Java 虚拟机。</p></li><li><p>void gc()：运行垃圾回收器。</p></li><li><p>Properties getProperties()：确定当前的系统属性。</p></li><li><p>String getProperty(String key)：获取指定键指示的系统属性。</p></li><li><p>void setErr(PrintStream err) ：重新分配“标准”错误输出流。</p></li><li><p>void setIn(InputStream in)：重新分配“标准”输入流。</p></li><li><p>void setOut(PrintStream out)：重新分配“标准”输出流。</p></li><li><p>String setProperty(String key, String value) ：设置指定键指示的系统属性。</p></li></ul><h1 id="数学相关类"><a href="#数学相关类" class="headerlink" title="数学相关类"></a>数学相关类</h1><h2 id="java-lang-Math类"><a href="#java-lang-Math类" class="headerlink" title="java.lang.Math类"></a>java.lang.Math类</h2><p>java.lang.Math提供了一系列静态方法用于科学计算；其方法的参数和返回值类型一般为double型。</p><ul><li><p>abs()   绝对值</p></li><li><p>acos,asin,atan,cos,sin,tan  三角函数</p></li><li><p>sqrt()  平方根</p></li><li><p>pow(double a,doble b)   a的b次幂</p></li><li><p>log()   自然对数</p></li><li><p>exp   e为底指数</p></li><li><p>max(x,y)  找x,y最大值</p></li><li><p>min(x,y)  找x,y找最小值</p></li><li><p>random()    返回0.0到1.0的随机数</p></li><li><p>long round(double a)   double型数据a转换为long型（四舍五入）</p></li><li><p>toDegrees(double angrad)   弧度—&gt;角度</p></li><li><p>toRadians(double angdeg)   角度—&gt;弧度</p></li><li><p>random()  返回[0,1)范围的小数</p></li><li><p>round(x)：四舍五入</p></li><li><p>ceil(x)：进一法/上取整</p></li><li><p>floor(x)：退一法/下取整</p><p>…..</p></li></ul><h2 id="java-math包"><a href="#java-math包" class="headerlink" title="java.math包"></a>java.math包</h2><h3 id="BigInteger-大整数"><a href="#BigInteger-大整数" class="headerlink" title="BigInteger 大整数"></a>BigInteger 大整数</h3><p>Integer类作为int的包装类，能存储的最大整型值为231-1，Long类也是有限的，最大为263-1如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。</p><p>java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。</p><p><strong>构造方法</strong></p><ul><li>BigInteger(String val)：根据字符串构建BigInteger对象</li></ul><p><strong>常用方法</strong></p><ul><li>BigInteger add(BigInteger val) ：返回其值为 (this + val) 的 BigInteger。</li><li>BigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigInteger。</li><li>BigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigInteger。</li><li>BigInteger divide(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数相除只保留整数部分。</li><li>BigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。</li><li>BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (this / val) 后跟 (this % val) 的两个 BigInteger 的数组。</li><li>BigInteger pow(int exponent) ：返回其值为 (this^exponent) 的 BigInteger。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//long num1 = 12345678901234567890L;//out of range 超过long的范围</span></span><br><span class="line">BigInteger num1 = <span class="keyword">new</span> BigInteger(<span class="string">"12345678901234567890"</span>);</span><br><span class="line">BigInteger num2 = <span class="keyword">new</span> BigInteger(<span class="string">"92345678901234567890"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println("和：" + (num1 + num2));//错误的</span></span><br><span class="line">System.out.println(<span class="string">"和："</span> + num1.add(num2));</span><br><span class="line">System.out.println(<span class="string">"减："</span> + num1.subtract(num2));</span><br><span class="line">System.out.println(<span class="string">"乘："</span> + num1.multiply(num2));</span><br><span class="line">System.out.println(<span class="string">"除："</span> + num2.divide(num1));<span class="comment">//两个整数相除只保留整数部分</span></span><br><span class="line">System.out.println(<span class="string">"幂次方："</span> + num2.pow(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BigDecimal-大小数"><a href="#BigDecimal-大小数" class="headerlink" title="BigDecimal 大小数"></a>BigDecimal 大小数</h3><p>一般的Float类和Double类可以用来做科学计算或工程计算，但是在商业计算中，要求数字精度比较高，所以用到java.math.BigDecimal类。BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p><p><strong>构造器</strong></p><ul><li>BigDecimal(double val)</li><li>BigDecimal(String val)</li></ul><p><strong>常用方法</strong></p><ul><li>BigDecimal add(BigDecimal augend) :返回一个 BigDecimal，其值为 (this + augend)，其标度为 max(this.scale(), augend.scale())。</li><li>BigDecimal subtract(BigDecimal subtrahend) ：返回一个 BigDecimal，其值为 (this - subtrahend)，其标度为 max(this.scale(), subtrahend.scale())。</li><li>BigDecimal multiply(BigDecimal multiplicand)：返回一个 BigDecimal，其值为 (this × multiplicand)，其标度为 (this.scale() + multiplicand.scale())。</li><li>BigDecimal pow(int n) ：返回其值为 (thisn) 的 BigDecimal，准确计算该幂，使其具有无限精度。</li><li>BigDecimal divide(BigDecimal divisor)： 返回一个 BigDecimal，其值为 (this / divisor)，其首选标度为 (this.scale() - divisor.scale())；如果无法表示准确的商值（因为它有无穷的十进制扩展），则抛出 ArithmeticException。</li><li>BigDecimal divide(BigDecimal divisor, int roundingMode) ：返回一个 BigDecimal，其值为 (this / divisor)，其标度为 this.scale()。</li><li>BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) ：返回一个 BigDecimal，其值为 (this / divisor)，其标度为指定标度。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">BigDecimal num1 = <span class="keyword">new</span> BigDecimal(<span class="string">"-12.1234567890123456567899554544444332"</span>);</span><br><span class="line">BigDecimal num2 = <span class="keyword">new</span> BigDecimal(<span class="string">"89.6734567890123456567899554544444333"</span>);</span><br><span class="line">System.out.println(<span class="string">"和："</span> + num1.add(num2));</span><br><span class="line">System.out.println(<span class="string">"减："</span> + num1.subtract(num2));</span><br><span class="line">System.out.println(<span class="string">"乘："</span> + num1.multiply(num2));</span><br><span class="line">System.out.println(<span class="string">"除："</span> + num2.divide(<span class="keyword">new</span> BigDecimal(<span class="string">"2"</span>)));<span class="comment">//可以整除（除尽）就对，不能整除就报异常</span></span><br><span class="line">System.out.println(<span class="string">"除："</span> + num2.divide(num1,BigDecimal.ROUND_HALF_UP));</span><br><span class="line">System.out.println(<span class="string">"除："</span> + num2.divide(num1,BigDecimal.ROUND_DOWN));<span class="comment">//往零的方向舍去</span></span><br><span class="line">System.out.println(<span class="string">"除："</span> + num2.divide(num1,BigDecimal.ROUND_FLOOR));<span class="comment">//往小的方向舍去</span></span><br><span class="line">System.out.println(<span class="string">"除："</span> + num2.divide(num1,BigDecimal.ROUND_CEILING));<span class="comment">//往大的方向舍去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="日期时间API"><a href="#日期时间API" class="headerlink" title="日期时间API"></a>日期时间API</h1><h2 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h2><h3 id="java-lang-System"><a href="#java-lang-System" class="headerlink" title="java.lang.System"></a>java.lang.System</h3><p>System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒GMT之间以毫秒为单位的时间差。此方法适于计算时间差。</p><h3 id="java-util-Date"><a href="#java-util-Date" class="headerlink" title="java.util.Date"></a>java.util.Date</h3><p>它的对象表示一个特定的瞬间，精确到毫秒。</p><p>Java中时间的表示说白了也是数字，是从标准纪元1970年1月1日0时0分0秒GMT到某个时刻的毫秒数，类型是long</p><p>理解：一维的时间轴，选择1970年1月1日0时0分0秒时间为0刻度，1毫秒一刻度</p><p><strong>构造方法：</strong></p><ul><li>Date()：    源代码：this(System.currentTimeMillis());</li><li>Date(long date)</li></ul><p><strong>常用方法：</strong></p><ul><li><p>getTime():返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</p></li><li><p>toString():把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)， zzz是时间标准。</p></li></ul><p><strong>已过时的方法：</strong></p><ul><li><p>public Date(int year,int month,int date,int hrs,int min,int sec)</p><p>参数：</p><p>​    year - 减 1900 的年份。</p><p>​    month - 0-11 之间的月份。</p><p>​    date - 一月中 1-31 之间的某一天。</p><p>​    hrs - 0-23 之间的小时数。</p><p>​    min - 0-59 之间的分钟数。</p><p>​    sec - 0-59 之间的秒数。</p></li><li><p>getYear() 从 JDK 1.1 开始，由 Calendar.get(Calendar.YEAR) - 1900 取代。</p></li><li><p>getMonth()从 JDK 1.1 开始，由 Calendar.get(Calendar.MONTH) 取代。返回的值在 0 和 11 之间，值 0 表示 1 月。 </p></li><li><p>getDate() JDK 1.1 开始，由 Calendar.get(Calendar.DAY_OF_MONTH) 取代。返回的值在 1 和 31 之间</p></li><li><p>getDay()从 JDK 1.1 开始，由 Calendar.get(Calendar.DAY_OF_WEEK) 取代。 返回值 (0 = Sunday, 1 = Monday, 2 = Tuesday, 3 = Wednesday, 4 = Thursday, 5 = Friday, 6 = Saturday) 表示一周中的某一天</p></li><li><p>getHours()从 JDK 1.1 开始，由 Calendar.get(Calendar.HOUR_OF_DAY) 取代。返回值是一个数字（0 至 23）</p></li><li><p>getMinutes()从 JDK 1.1 开始，由 Calendar.get(Calendar.MINUTE) 取代。 返回值在 0 和 59 之间。 </p></li><li><p>getSeconds()从 JDK 1.1 开始，由 Calendar.get(Calendar.SECOND) 取代。回的值在 0 和 61 之间。值 60 和 61 只可能发生在考虑了闰秒的 Java 虚拟机上。</p></li></ul><h3 id="java-util-TimeZone和Locale"><a href="#java-util-TimeZone和Locale" class="headerlink" title="java.util.TimeZone和Locale"></a>java.util.TimeZone和Locale</h3><p>Locale 对象表示了特定的地理、政治和文化地区。需要 Locale 来执行其任务的操作称为语言环境敏感的 操作，它使用 Locale 为用户量身定制信息。例如，显示一个数值，日期就是语言环境敏感的操作，应该根据用户的国家、地区或文化的风俗/传统来格式化该数值。</p><p><strong>获取Locale对象：</strong></p><ul><li><p>Locale(String language)</p></li><li><p>Locale(String language, String country)</p></li><li><p>Locale.CHINA、Locale.US等</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Locale loc = Locale.CHINA;</span><br><span class="line">System.out.println(loc);<span class="comment">//zh_CN</span></span><br><span class="line">System.out.println(Locale.US);<span class="comment">//en_US</span></span><br><span class="line">System.out.println(Locale.JAPAN);<span class="comment">//ja_JP</span></span><br><span class="line"></span><br><span class="line">Locale c = <span class="keyword">new</span> Locale(<span class="string">"zh"</span>,<span class="string">"CN"</span>);</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常，使用 TimeZone的getDefault 获取 TimeZone，getDefault 基于程序运行所在的时区创建 TimeZone。例如，对于在日本运行的程序，getDefault 基于日本标准时间创建 TimeZone 对象。 </p><p>也可以用TimeZone的 getTimeZone 及时区 ID 获取 TimeZone 。例如美国太平洋时区的时区 ID 是 “America/Los_Angeles”。因此，可以使用下面语句获得美国太平洋时间 TimeZone 对象：</p><p>TimeZone tz = TimeZone.getTimeZone(“America/Los_Angeles”);</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">TimeZone t = TimeZone.getDefault();</span><br><span class="line">System.out.println(t);</span><br><span class="line"></span><br><span class="line">TimeZone t1 = TimeZone.getTimeZone(<span class="string">"America/New_York"</span>);</span><br><span class="line">System.out.println(t1);</span><br><span class="line"></span><br><span class="line">TimeZone t2 = TimeZone.getTimeZone(<span class="string">"Asia/Shanghai"</span>);</span><br><span class="line">System.out.println(t2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String[] all = TimeZone.getAvailableIDs();</span><br><span class="line"><span class="keyword">for</span> (String id : all) &#123;</span><br><span class="line">  System.out.println(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-util-Calendar"><a href="#java-util-Calendar" class="headerlink" title="java.util.Calendar"></a>java.util.Calendar</h3><p>Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。瞬间可用毫秒值来表示，它是距历元（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00.000，格里高利历）的偏移量。 </p><p>人们对于时间的认识是：某年某月某日，这样的日期概念。计算机是long类型的数字。通过Calendar在二者之间搭起桥梁。而且Calendar提供了很多关于日期时间计算的方法。</p><p>GregorianCalendar（公历）是Calendar的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。</p><p><strong>注意：</strong></p><p>月份：一月是0，二月是1，以此类推，12月是11</p><p>星期：周日是1，周二是2,。。。。周六是7</p><p>public static Calendar getInstance()使用默认时区和语言环境获得一个日历。返回的 Calendar 基于当前时间，使用了默认时区和默认语言环境。 </p><p>public static Calendar getInstance(TimeZone zone, Locale aLocale)使用指定时区和语言环境获得一个日历。返回的 Calendar 基于当前时间，使用了给定的时区和给定的语言环境。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">System.out.println(c);</span><br><span class="line"></span><br><span class="line">Calendar c2 = Calendar.getInstance(TimeZone.getTimeZone(<span class="string">"Asia/Shanghai"</span>), Locale.CHINA);</span><br><span class="line">System.out.println(c2);</span><br><span class="line"></span><br><span class="line">Calendar c3 = Calendar.getInstance(TimeZone.getTimeZone(<span class="string">"America/New_York"</span>), Locale.US);</span><br><span class="line">System.out.println(c3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-text-DateFormat和SimpleDateFormat"><a href="#java-text-DateFormat和SimpleDateFormat" class="headerlink" title="java.text.DateFormat和SimpleDateFormat"></a>java.text.DateFormat和SimpleDateFormat</h3><p>完成字符串和时间对象的转化：</p><ul><li><p>String format(date)</p></li><li><p>Date parse(string)</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss 是本年的第几D"</span>);</span><br><span class="line">System.out.println(sf.format(date));</span><br><span class="line"></span><br><span class="line">String s = <span class="string">"2016-12-01 14:12:23"</span>;</span><br><span class="line">SimpleDateFormat sf2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Date d = sf2.parse(s);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/date.png" alt="date"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">String str = <span class="string">"2019年06月06日 16时03分14秒 545毫秒  星期四 +0800"</span>;</span><br><span class="line">SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒  E Z"</span>);</span><br><span class="line">Date d = sf.parse(str);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span>&#123;</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒  E Z"</span>);</span><br><span class="line"><span class="comment">//把Date日期转成字符串，按照指定的格式转</span></span><br><span class="line">String str = sf.format(d);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">String[] all = TimeZone.getAvailableIDs();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all.length; i++) &#123;</span><br><span class="line">System.out.println(all[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">TimeZone t = TimeZone.getTimeZone(<span class="string">"America/Los_Angeles"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//getInstance(TimeZone zone)</span></span><br><span class="line">Calendar c = Calendar.getInstance(t);</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">System.out.println(c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">System.out.println(year);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> month = c.get(Calendar.MONTH)+<span class="number">1</span>;</span><br><span class="line">System.out.println(month);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> time = Long.MAX_VALUE;</span><br><span class="line">Date d = <span class="keyword">new</span> Date(time);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> time = <span class="number">1559807047979L</span>;</span><br><span class="line">Date d = <span class="keyword">new</span> Date(time);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="keyword">long</span> time = d.getTime();</span><br><span class="line">System.out.println(time);<span class="comment">//1559807047979</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">System.out.println(time);<span class="comment">//1559806982971</span></span><br><span class="line"><span class="comment">//当前系统时间距离1970-1-1 0:0:0 0毫秒的时间差，毫秒为单位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h2><p>Java1.0中包含了一个Date类，但是它的大多数方法已经在Java 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是：</p><ul><li><p>可变性：象日期和时间这样的类对象应该是不可变的。Calendar类中可以使用三种方法更改日历字段：set()、add() 和 roll()。</p></li><li><p>偏移性：Date中的年份是从1900开始的，而月份都是从0开始的。</p></li><li><p>格式化：格式化只对Date有用，Calendar则不行。</p></li></ul><p>此外，它们也不是线程安全的，不能处理闰秒等。</p><p>Date的API：</p><p>尽管 Date 类打算反映协调世界时 (UTC)，但无法做到如此准确，这取决于 Java 虚拟机的主机环境。当前几乎所有操作系统都假定 1 天 = 24 × 60 × 60 = 86400 秒。但对于 UTC，大约每一两年出现一次额外的一秒，称为“闰秒”。闰秒始终作为当天的最后一秒增加，并且始终在 12 月 31 日或 6 月 30 日增加。例如，1995 年的最后一分钟是 61 秒，因为增加了闰秒。大多数计算机时钟不是特别的准确，因此不能反映闰秒的差别。</p><p>在类 Date 所有可以接受或返回年、月、日期、小时、分钟和秒值的方法中，将使用下面的表示形式： </p><ul><li><p>年份 y 由整数 y - 1900 表示。 </p></li><li><p>月份由从 0 至 11 的整数表示；0 是一月、1 是二月等等；因此 11 是十二月。 </p></li><li><p>日期（一月中的某天）按通常方式由整数 1 至 31 表示。 </p></li><li><p>小时由从 0 至 23 的整数表示。因此，从午夜到 1 a.m. 的时间是 0 点，从中午到 1 p.m. 的时间是 12 点。 </p></li><li><p>分钟按通常方式由 0 至 59 的整数表示。 </p></li><li><p>秒由 0 至 61 的整数表示；值 60 和 61 只对闰秒发生，尽管那样，也只用在实际正确跟踪闰秒的 Java 实现中。于按当前引入闰秒的方式，两个闰秒在同一分钟内发生是极不可能的，但此规范遵循 ISO C 的日期和时间约定。 </p></li></ul><p>在所有情形中，针对这些目的赋予方法的参数不需要在指定的范围内；例如，可以把日期指定为 1 月 32 日，并把它解释为 2 月 1 日的相同含义。</p><p>​        Date date = new Date(2017-1900,8-1,28);</p><p>​        System.out.println(date);//Mon Aug 28 00:00:00 CST 2017</p><p>可以说，对日期和时间的操作一直是Java程序员最痛苦的地方之一。第三次引入的API是成功的，并且java 8中引入的java.time API 已经纠正了过去的缺陷，将来很长一段时间内它都会为我们服务。</p><p>Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。</p><ul><li><p>java.time – 包含值对象的基础包</p></li><li><p>java.time.chrono – 提供对不同的日历系统的访问。</p></li><li><p>java.time.format – 格式化和解析时间和日期</p></li><li><p>java.time.temporal – 包括底层框架和扩展特性</p></li><li><p>java.time.zone – 包含时区支持的类</p></li></ul><p>Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。新的 java.time 中包含了所有关于时钟（Clock），本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了了日期时间和本地化的管理。</p><p>说明：大多数开发者只会用到基础包和format包，也可能会用到temporal包。因此，尽管有68个新的公开类型，大多数开发者，大概将只会用到其中的很少一部分。</p><p><strong>java.time</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/time.png" alt="time"></p><blockquote><p>注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是公历。</p></blockquote><p><strong>java.time.chrono</strong></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/time2.png" alt="time"></p><h3 id="java-time"><a href="#java-time" class="headerlink" title="java.time"></a>java.time</h3><p>本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）</p><p>LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储“生日、纪念日”等日期。</p><p>LocalTime表示一个时间，而不是日期</p><p>LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一。</p><p>（1）now()：获取系统日期或时间</p><p>（2）of(xxx)：或者指定的日期或时间</p><p>（3）运算：运算后得到新对象，需要重新接受</p><p>plusXxx()：在当前日期或时间对象上加xx</p><p>minusXxx() ：在当前日期或时间对象上减xx</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>now() / now(ZoneId zone)</td><td>静态方法，根据当前时间创建对象/指定时区的对象</td></tr><tr><td>of()</td><td>静态方法，根据指定日期/时间创建对象</td></tr><tr><td>getDayOfMonth()/getDayOfYear()</td><td>获得月份天数(1-31) /获得年份天数(1-366)</td></tr><tr><td>getDayOfWeek()</td><td>获得星期几(返回一个 DayOfWeek 枚举值)</td></tr><tr><td>getMonth()</td><td>获得月份, 返回一个 Month 枚举值</td></tr><tr><td>getMonthValue() / getYear()</td><td>获得月份(1-12) /获得年份</td></tr><tr><td>getHours()/getMinute()/getSecond()</td><td>获得当前对象对应的小时、分钟、秒</td></tr><tr><td>withDayOfMonth()/withDayOfYear()/withMonth()/withYear()</td><td>将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</td></tr><tr><td>with(TemporalAdjuster t)</td><td>将当前日期时间设置为校对器指定的日期时间</td></tr><tr><td>plusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours()</td><td>向当前对象添加几天、几周、几个月、几年、几小时</td></tr><tr><td>minusMonths() / minusWeeks()/minusDays()/minusYears()/minusHours()</td><td>从当前对象减去几月、几周、几天、几年、几小时</td></tr><tr><td>plus(TemporalAmount t)/minus(TemporalAmount t)</td><td>添加或减少一个 Duration 或 Period</td></tr><tr><td>isBefore()/isAfter()</td><td>比较两个 LocalDate</td></tr><tr><td>isLeapYear()</td><td>判断是否是闰年（在LocalDate类中声明）</td></tr><tr><td>format(DateTimeFormatter t)</td><td>格式化本地日期、时间，返回一个字符串</td></tr><tr><td>parse(Charsequence text)</td><td>将指定格式的字符串解析为日期、时间</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//now()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLocalDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">  LocalDate date = LocalDate.now();</span><br><span class="line">  LocalTime time = LocalTime.now();</span><br><span class="line">  LocalDateTime datetime = LocalDateTime.now();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//of()或parse</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLocalDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// LocalDate date = LocalDate.now();</span></span><br><span class="line">  <span class="comment">// LocalDate date = LocalDate.of(2017, 3, 20);</span></span><br><span class="line">  LocalDate date = LocalDate.parse(<span class="string">"2017-03-12"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  LocalDateTime t = LocalDateTime.now();</span><br><span class="line">  System.out.println(<span class="string">"这一天是这一年的第几天："</span>+t.getDayOfYear());</span><br><span class="line">  System.out.println(<span class="string">"年："</span>+t.getYear());</span><br><span class="line">  System.out.println(<span class="string">"月："</span>+t.getMonth());</span><br><span class="line">  System.out.println(<span class="string">"月份值："</span>+t.getMonthValue());</span><br><span class="line">  System.out.println(<span class="string">"日："</span>+t.getDayOfMonth());</span><br><span class="line">  System.out.println(<span class="string">"星期："</span>+t.getDayOfWeek());</span><br><span class="line">  System.out.println(<span class="string">"时："</span>+t.getHour());</span><br><span class="line">  System.out.println(<span class="string">"分："</span>+t.getMinute());</span><br><span class="line">  System.out.println(<span class="string">"秒："</span>+t.getSecond());</span><br><span class="line">  System.out.println(t.getMonthValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLocalDate2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  LocalDate date = LocalDate.now();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//withXxx()方法，不改变原来的date对象，返回一个新的对象，不可变性</span></span><br><span class="line">  <span class="comment">// LocalDate date2 = date.withDayOfMonth(1);//获取这个月的第一天</span></span><br><span class="line">  LocalDate date2 = date.with(TemporalAdjusters.firstDayOfMonth());<span class="comment">// 获取这个月的第一天</span></span><br><span class="line">  System.out.println(date2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取这个月的最后一天</span></span><br><span class="line">  LocalDate date3 = date.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">  System.out.println(date3);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//45天后的日期</span></span><br><span class="line">  LocalDate date4 = date.plusDays(<span class="number">45</span>);</span><br><span class="line">  System.out.println(date4);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//20天前的日期</span></span><br><span class="line">  LocalDate date5 = date.minusDays(<span class="number">20</span>);</span><br><span class="line">  System.out.println(date5);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> before = date.isBefore(date5);</span><br><span class="line">  System.out.println(date+<span class="string">"是否比"</span>+date5+<span class="string">"早"</span> + before);</span><br><span class="line"></span><br><span class="line">  System.out.println(date+<span class="string">"是否是闰年："</span>+date.isLeapYear());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MonthDay month = MonthDay.of(<span class="number">8</span>, <span class="number">14</span>);</span><br><span class="line">MonthDay today = MonthDay.from(date);</span><br><span class="line">System.out.println(<span class="string">"今天是否是生日："</span> + month.equals(today));</span><br></pre></td></tr></table></figure><h3 id="瞬时：Instant"><a href="#瞬时：Instant" class="headerlink" title="瞬时：Instant"></a>瞬时：Instant</h3><p>Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。</p><p>在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位。</p><p>java.time包通过值类型Instant提供机器视图。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/time3.png" alt="time"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/time4.png" alt="time"></p><p>时间戳：指格林威治时间1970年01月01日00时00分00秒（北京时间1970年01月01日08时00分00秒）起至现在的总秒数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Instant t = Instant.now();</span><br><span class="line">System.out.println(t);</span><br><span class="line"></span><br><span class="line"><span class="comment">//偏移8个小时</span></span><br><span class="line">OffsetDateTime atOffset = t.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">System.out.println(atOffset);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> milli = t.toEpochMilli();</span><br><span class="line">System.out.println(milli);</span><br><span class="line"></span><br><span class="line">Instant in2 = Instant.ofEpochSecond(<span class="number">10000000</span>);</span><br><span class="line">System.out.println(in2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带时区的日期、时间的处理"><a href="#带时区的日期、时间的处理" class="headerlink" title="带时区的日期、时间的处理"></a>带时区的日期、时间的处理</h3><p>作为一个开发者，如果不用去处理时区和它带来的复杂性，那是幸运的。java.time包下的LocalDate、LocalTime、LocalDateTime和Instant基本能满足需求。当你不可避免时区时，ZonedDateTime等类可以满足我们的需求。</p><p>ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12-03T10:15:30+01:00 Europe/Paris。</p><ul><li><p>其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如：Asia/Shanghai等</p></li><li><p>now()：使用系统时间获取当前的ZonedDateTime</p></li><li><p>now(ZoneId)：返回指定时区的ZonedDateTime</p></li></ul><p>ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris</p><ul><li><p>getAvailableZoneIds()：静态方法，可以获取所有时区信息</p></li><li><p>of(String id)：静态方法，用指定的时区信息获取ZoneId对象</p></li></ul><p>Clock：使用时区提供对当前即时、日期和时间的访问的时钟。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line">  <span class="keyword">for</span> (String string : availableZoneIds) &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ZonedDateTime t = ZonedDateTime.now();</span><br><span class="line">  System.out.println(t);</span><br><span class="line"></span><br><span class="line">  ZonedDateTime t1 = ZonedDateTime.now(ZoneId.of(<span class="string">"America/New_York"</span>));</span><br><span class="line">  System.out.println(t1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Clock clock = Clock.systemDefaultZone();</span></span><br><span class="line">  Clock c = Clock.system(ZoneId.of(<span class="string">"America/New_York"</span>));</span><br><span class="line">  System.out.println(c.getZone());</span><br><span class="line">  System.out.println(c.instant());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="持续时间：Duration"><a href="#持续时间：Duration" class="headerlink" title="持续时间：Duration"></a>持续时间：Duration</h3><p>Duration:用于计算两个“时间”间隔</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  LocalDateTime t1 = LocalDateTime.now();</span><br><span class="line">  LocalDateTime t2 = LocalDateTime.of(<span class="number">2017</span>, <span class="number">8</span>, <span class="number">29</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  Duration between = Duration.between(t1, t2);</span><br><span class="line">  System.out.println(between);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"相差的总天数："</span>+between.toDays());</span><br><span class="line">  System.out.println(<span class="string">"相差的总小时数："</span>+between.toHours());</span><br><span class="line">  System.out.println(<span class="string">"相差的总分钟数："</span>+between.toMinutes());</span><br><span class="line">  System.out.println(<span class="string">"相差的总秒数："</span>+between.getSeconds());</span><br><span class="line">  System.out.println(<span class="string">"相差的总毫秒数："</span>+between.toMillis());</span><br><span class="line">  System.out.println(<span class="string">"相差的总纳秒数："</span>+between.toNanos());</span><br><span class="line">  System.out.println(<span class="string">"不够一秒的纳秒数："</span>+between.getNano());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="日期间隔：Period"><a href="#日期间隔：Period" class="headerlink" title="日期间隔：Period"></a>日期间隔：Period</h3><p>Period:用于计算两个“日期”间隔</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  LocalDate t1 = LocalDate.now();</span><br><span class="line">  LocalDate t2 = LocalDate.of(<span class="number">2018</span>, <span class="number">12</span>, <span class="number">31</span>);</span><br><span class="line">  Period between = Period.between(t1, t2);</span><br><span class="line">  System.out.println(between);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"相差的年数："</span>+between.getYears());<span class="comment">//1年</span></span><br><span class="line">  System.out.println(<span class="string">"相差的月数："</span>+between.getMonths());<span class="comment">//又7个月</span></span><br><span class="line">  System.out.println(<span class="string">"相差的天数："</span>+between.getDays());<span class="comment">//零25天</span></span><br><span class="line">  System.out.println(<span class="string">"相差的总数："</span>+between.toTotalMonths());<span class="comment">//总共19个月</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-time-temporal-TemporalAdjuster-时间校正器"><a href="#java-time-temporal-TemporalAdjuster-时间校正器" class="headerlink" title="java.time.temporal .TemporalAdjuster : 时间校正器"></a>java.time.temporal .TemporalAdjuster : 时间校正器</h3><p>TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。</p><p>TemporalAdjusters : 该类通过静态方法(firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用 TemporalAdjuster 的实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  LocalDate now = LocalDate.now();</span><br><span class="line">  System.out.println(<span class="string">"下一个周日:"</span>+now.with(TemporalAdjusters.next(DayOfWeek.SUNDAY)));</span><br><span class="line">  System.out.println(<span class="string">"下周五"</span> + now.with(TemporalAdjusters.next(DayOfWeek.FRIDAY)));</span><br><span class="line">  System.out.println(<span class="string">"本月最后一天:"</span>+now.with(TemporalAdjusters.lastDayOfMonth()));<span class="comment">//2017-08-31</span></span><br><span class="line">  LocalDate week = LocalDate.now().with(<span class="keyword">new</span> TemporalAdjuster()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Temporal <span class="title">adjustInto</span><span class="params">(Temporal temporal)</span> </span>&#123;</span><br><span class="line">      LocalDate date = (LocalDate) temporal;</span><br><span class="line">      <span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.MONDAY))&#123;</span><br><span class="line">        <span class="keyword">return</span> date.plusDays(<span class="number">7</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.TUESDAY))&#123;</span><br><span class="line">        <span class="keyword">return</span> date.plusDays(<span class="number">6</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.WEDNESDAY))&#123;</span><br><span class="line">        <span class="keyword">return</span> date.plusDays(<span class="number">5</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.THURSDAY))&#123;</span><br><span class="line">        <span class="keyword">return</span> date.plusDays(<span class="number">4</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.FRIDAY))&#123;</span><br><span class="line">        <span class="keyword">return</span> date.plusDays(<span class="number">3</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.SATURDAY))&#123;</span><br><span class="line">        <span class="keyword">return</span> date.plusDays(<span class="number">2</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date.plusDays(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  System.out.println(<span class="string">"下一个工作日："</span> + week);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-time-format-DateTimeFormatter"><a href="#java-time-format-DateTimeFormatter" class="headerlink" title="java.time.format.DateTimeFormatter"></a>java.time.format.DateTimeFormatter</h3><p>该类提供了三种格式化方法：</p><p>预定义的标准格式。如：ISO_DATE_TIME;ISO_DATE</p><p>本地化相关的格式。如：ofLocalizedDate(FormatStyle.MEDIUM)</p><p>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test12</span><span class="params">()</span></span>&#123;</span><br><span class="line">  LocalDateTime now = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">  DateTimeFormatter df = DateTimeFormatter.ofPattern(<span class="string">"yyyy年MM月dd日 HH时mm分ss秒  SSS毫秒  E 是这一年的D天"</span>);</span><br><span class="line">  String string = df.format(now);</span><br><span class="line">  System.out.println(string);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//预定义模式</span></span><br><span class="line">  DateTimeFormatter df2 = DateTimeFormatter.ISO_DATE_TIME;</span><br><span class="line">  System.out.println(df2.format(now));</span><br><span class="line"></span><br><span class="line">  DateTimeFormatter df3 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line">  System.out.println(df3.format(now));</span><br><span class="line"></span><br><span class="line">  DateTimeFormatter df4 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);</span><br><span class="line">  System.out.println(df4.format(now));</span><br><span class="line"></span><br><span class="line">  DateTimeFormatter df5 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM);</span><br><span class="line">  System.out.println(df5.format(now));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与传统日期处理的转换"><a href="#与传统日期处理的转换" class="headerlink" title="与传统日期处理的转换"></a>与传统日期处理的转换</h3><table><thead><tr><th>类</th><th>To 遗留类</th><th>From 遗留类</th></tr></thead><tbody><tr><td>java.time.Instant与java.util.Date</td><td>Date.from(instant)</td><td>date.toInstant()</td></tr><tr><td>java.time.Instant与java.sql.Timestamp</td><td>Timestamp.from(instant)</td><td>timestamp.toInstant()</td></tr><tr><td>java.time.ZonedDateTime与java.util.GregorianCalendar</td><td>GregorianCalendar.from(zonedDateTime)</td><td>cal.toZonedDateTime()</td></tr><tr><td>java.time.LocalDate与java.sql.Time</td><td>Date.valueOf(localDate)</td><td>date.toLocalDate()</td></tr><tr><td>java.time.LocalTime与java.sql.Time</td><td>Date.valueOf(localDate)</td><td>date.toLocalTime()</td></tr><tr><td>java.time.LocalDateTime与java.sql.Timestamp</td><td>Timestamp.valueOf(localDateTime)</td><td>timestamp.toLocalDateTime()</td></tr><tr><td>java.time.ZoneId与java.util.TimeZone</td><td>Timezone.getTimeZone(id)</td><td>timeZone.toZoneId()</td></tr><tr><td>java.time.format.DateTimeFormatter与java.text.DateFormat</td><td>formatter.toFormat()</td><td>无</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 常用类 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2020/06/17/java-design-pattern/"/>
      <url>/2020/06/17/java-design-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="模版设计模式"><a href="#模版设计模式" class="headerlink" title="模版设计模式"></a>模版设计模式</h1><p>1、当解决某个问题，或者完成某个功能时，主体的算法结构（步骤）是确定的，只是其中的一个或者几个小的步骤不确定，要有使用者（子类）来确定时，就可以使用模板设计模式</p><p>2、示例代码：计算任意一段代码的运行时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CalTime</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、获取开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start =  System.currentTimeMills();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、运行xx代码：这个是不确定的</span></span><br><span class="line">        doWork();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、获取结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end =  System.currentTimeMills();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4、计算时间差</span></span><br><span class="line">        <span class="keyword">return</span> end - start;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用模板类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCalTime</span> <span class="keyword">extends</span> <span class="title">CalTime</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//....需要计算运行时间的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyCalTime my = <span class="keyword">new</span> MyCalTime();</span><br><span class="line">        System.out.println(<span class="string">"运行时间："</span> + my.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><p>单例设计模式，是软件开发中最常用的设计模式之一，它是指某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式。例如：代表JVM运行环境的Runtime类。</p><p>通常有饿汉式和懒汉式两种。</p><h2 id="饿汉式单例设计模式"><a href="#饿汉式单例设计模式" class="headerlink" title="饿汉式单例设计模式"></a>饿汉式单例设计模式</h2><p>所谓饿汉式，就是在类初始化时，直接创建对象。</p><p>优势：因为Java的类加载和初始化的机制可以保证线程安全，所以这类形式的单例设计模式不存在线程安全问题。</p><p>劣势：不管你暂时是否需要该实例对象，都会创建，使得类初始化时间加长。</p><h3 id="直接实例化饿汉式"><a href="#直接实例化饿汉式" class="headerlink" title="直接实例化饿汉式"></a>直接实例化饿汉式</h3><p>形式一：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton1 INSTANCE = <span class="keyword">new</span> Singleton1();</span><br><span class="line"><span class="comment">//构造器私有化</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形式二：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton3 INSTANCE = <span class="keyword">new</span> Singleton3();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举式"><a href="#枚举式" class="headerlink" title="枚举式"></a>枚举式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton2 &#123;</span><br><span class="line">INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉式单例设计模式"><a href="#懒汉式单例设计模式" class="headerlink" title="懒汉式单例设计模式"></a>懒汉式单例设计模式</h2><p>所谓懒汉式：即延迟创建对象，直到用户来获取这个对象时，再创建。</p><p>优势：不用不创建，用时再创建</p><p>劣势：需要考虑线程安全问题</p><h3 id="在获取实例的方法中创建单例对象"><a href="#在获取实例的方法中创建单例对象" class="headerlink" title="在获取实例的方法中创建单例对象"></a>在获取实例的方法中创建单例对象</h3><p>方式一：线程不安全</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSingleton4</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance1;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">instance1 = Singleton4.getInstance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">instance2 = Singleton4.getInstance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">t2.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(instance1);</span><br><span class="line">System.out.println(instance2);</span><br><span class="line">    System.out.println(instance1 == instance2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：解决了线程安全</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton5 instance;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (Singleton5<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类形式"><a href="#静态内部类形式" class="headerlink" title="静态内部类形式"></a>静态内部类形式</h3><p>当调用getInstance()方法，才会去加载和初始化Inner类，所以是懒汉式，因为是在类初始化时创建对象，所以线程安全</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton6 INSTANCE = <span class="keyword">new</span> Singleton6();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程基础</title>
      <link href="/2020/06/16/java-thread/"/>
      <url>/2020/06/16/java-thread/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h1><h2 id="相关的概念"><a href="#相关的概念" class="headerlink" title="相关的概念"></a>相关的概念</h2><p>前面我们写的程序都是单线程的，它们都只有一条顺序执行流：程序从main方法开始执行，依次向下执行每行代码，如果程序执行某行代码遇到了阻塞，则程序将会停滞在该处。如果我们使用Eclipse等IDE工具的单步调试功能将可以非常清楚地看出这一点。</p><p>多线程听上去是非常专业的概念，但其实非常简单：单线程的程序只有一条执行路径，多线程的程序则包含多条执行路径，多条执行路径之间互不干扰</p><p>1、程序（Program）</p><p>​    为了实现一个功能，完成一个任务而选择一种编程语言编写的一组指令的集合。</p><p>2、进程（Process）</p><p>​    几乎所有操作系统都支持进程的概念，所有运行中的任务通常对应一条进程（Process）。当一个程序进入内存运行，即变成一个进程。进程是处于运行过程中的程序，并且具有一定独立功能，进程是操作系统进行资源分配和调度的一个独立单位。</p><p>​    一般而言，进程包含如下三个特性：</p><ul><li><p>独立性：进程是操作系统进行资源分配和调度的一个独立单位，每一个进程都拥有自己私有的地址空间。在没有经过进程本身允许的情况下，一个用户进程不可以直接访问其他进程的地址空间。哪怕在同一台计算机上运行，进程之间通信可能也需要通过网络、独立于进程的文件来交换数据。</p></li><li><p>动态性：程序只是一个静态的指令的集合，而进程是一个正在系统中运行的活动的指令集合，即进程是处于运行过程中的程序。在进程中加入了时间的概念，进程具有自己的生命周期和各种不同状态，这些概念在程序中都是不具备的。</p></li><li><p>并发性：多个进程可以在单个处理器上并发执行，多个进程之间不会相互影响。</p><p>现代的操作系统都支持多进程的并发，但在具体的实现细节上可能因为硬件和操作系统的不同而采用不同的策略，目前大多数采用效率更高的抢占式多任务策略。对于一个CPU而言，它在某个时间点上只能执行一个程序，也就是只能运行一个进程，CPU不断的在这些进程之间轮换执行。那么，我们为什么可以一边用开发工具写程序，一边听音乐，一边还上网查资料…..，我们没有感觉到中断和轮换呢？这是因为CPU的执行速度相对于我们的感知速度来说实在是太快了，所以我们感觉像是同时运行一样。但是当我们启动足够多的程序时，依然可以感觉到运行速度下降的。</p></li></ul><blockquote><p>程序的一次运行。操作系统会给这个进程分配资源（内存）。</p></blockquote><blockquote><p>进程是操作系统分配资源的最小单位。</p></blockquote><blockquote><p>进程与进程之间的内存是独立，无法直接共享。</p></blockquote><blockquote><p>最早的DOS操作系统是单任务的，同一时间只能运行一个进程。后来现在的操作系统都是支持多任务的，可以同时运行多个进程。进程之间来回切换。成本比较高。</p></blockquote><p>3、线程（Thread）</p><p>多线程则扩展了多进程的概念，使得通一个进程可以同时并发处理多个任务。线程（Thread）也被称为轻量级进程。就像进程在操作系统中地位一样，线程在进程中也是独立的、并发的执行流。当进程被初始化后，主线程就被创建了，对于Java程序来说，main线程就是主线程，但我们可以在该进程内创建多条顺序执行路径，这些独立的顺序执行路径就是线程。</p><p>进程中的每一个线程可以完成一定的任务，并且是独立的，线程可以拥有自己独立的堆栈、自己的程序计数器和自己的局部变量，但不再拥有系统资源，它与父进程的其他线程共享该进程所拥有的全部资源。由于线程间的通信是在同一个地址空间上进行的，所以不需要额外的通信机制，这就使得通信更简便而且信息传递的速度也更快，因此可以通过简单编程实现多线程相互协同来完成进程所要完成的任务。但是也存在安全问题，因为其中一个线程对共享的系统资源的操作都会给其他线程带来影响，由此可知，多线程中的同步是非常重要的问题。</p><p>线程的执行也是抢占式的，也就是说，当前运行的线程在任何时候都可能被挂起，以便另一个线程可以运行。我们说CPU在不同的进程之间轮换，进程又在不同的线程之间轮换，因此线程是CPU执行和调度的最小单元。</p><p>总之，一个程序运行后至少有一个进程，一个进程里可以包含多个线程，但至少要包含一个线程。当操作系统创建一个进程时，必须为该进程分配独立的内存空间，并分配大量的相关资源；但创建一个线程简单的多，而且多个线程共享同一个进程的虚拟空间，所以，使用多线程来实现并发比使用多进程实现并发的性能要高的多。</p><p>在实际应用中，多线程是非常有用的，一个Web服务器必须能同时响应多个客户端的请求；一个浏览器必须能同时下载多个图片；一个在线播放器必须能一边下载一边播放……</p><p><strong>注意：</strong></p><p>并发性（concurrency）和并行性（parallel）是两个概念，并行是指在同一时刻，有多条指令在多个处理器上同时执行；并发是指在同一个时刻只能有一条指令执行，但多个进程的指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。</p><blockquote><p>线程是进程中的其中一条执行路径。一个进程中至少有一个线程，也可以有多个线程。有的时候也把线程称为轻量级的进程。</p></blockquote><blockquote><p>同一个进程的多个线程之间有些内存是可以共享的（方法区、堆），也有些内存是独立的（栈（包括虚拟机栈和本地方法栈）、程序计数器）。</p></blockquote><blockquote><p>线程之间的切换相对进程来说成本比较低。</p></blockquote><p>4、并行： 多个处理器同时可以执行多条执行路径。</p><p>5、并发：多个任务同时执行，但是可能存在先后关系。</p><h2 id="两种实现多线程的方式"><a href="#两种实现多线程的方式" class="headerlink" title="两种实现多线程的方式"></a>两种实现多线程的方式</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p> 步骤：</p><p>（1）编写线程类，去继承Thread类</p><p>（2）重写public void run(){}</p><p>（3）创建线程对象</p><p>（4）调用start()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Overrid</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyThread my = <span class="keyword">new</span> MyThread();</span><br><span class="line">        my.start();<span class="comment">//有名字的线程对象启动</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> MyThread().start();<span class="comment">//匿名线程对象启动</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名内部类的匿名对象启动</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名内部类，但是通过父类的变量多态引用，启动线程</span></span><br><span class="line">        Thread t =  <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>Thread.currentThread()方法总是返回当前在执行的线程对象；</li><li>getName()方法是Thread的实例方法，该方法返回当前线程对象的名字，可以通过setName(String name)方法设置线程名称，否则依次为Thread-0，Thread-1……等</li></ul><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>步骤：</p><p>（1）编写线程类，实现Runnable接口</p><p>（2）重写public void run(){}</p><p>（3）创建线程对象</p><p>（4）借助Thread类的对象启动线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//两个匿名对象</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名内部类的匿名对象作为实参直接传给Thread的构造器</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>一个完整的生命周期中通常要经历如下的五种状态：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、死亡（Dead）。CPU需要在多条线程之间切换，于是线程状态会多次在运行、阻塞、就绪之间切换。</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/thread.png" alt="thread"></p><ul><li><p>新建</p><p>当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状。此时它和其他Java对象一样，仅仅由JVM为其分配了内存，并初始化了实例变量的值。此时的线程对象并没有任何线程的动态特征，程序也不会执行它的线程体run()。</p></li><li><p>就绪</p><p>但是当线程对象调用了start()方法之后，就不一样了，线程就从新建状态转为就绪状态。JVM会为其创建方法调用栈和程序计数器，当然，处于这个状态中的线程并没有开始运行，只是表示已具备了运行的条件，随时可以被调度。至于什么时候被调度，取决于JVM里线程调度器的调度。</p></li><li><p>运行</p><p>如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程体代码，则该线程处于运行状态。如果计算机只有一个CPU，在任何时刻只有一个线程处于运行状态，如果计算机有多个处理器，将会有多个线程并行（Parallel）执行。</p><p>当然，美好的时光总是短暂的，而且CPU讲究雨露均沾。对于抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务，当该时间用完，系统会剥夺该线程所占用的资源，让其回到就绪状态等待下一次被调度。此时其他线程将获得执行机会，而在选择下一个线程时，系统会适当考虑线程的优先级。</p></li><li><p>阻塞</p><p>当在运行过程中的线程遇到如下情况时，线程会进入阻塞状态：</p><ul><li>线程调用了sleep()方法，主动放弃所占用的CPU资源；</li><li>线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞；</li><li>线程试图获取一个同步监视器，但该同步监视器正被其他线程持有；</li><li>线程执行过程中，同步监视器调用了wait()，让它等待某个通知（notify）；</li><li>线程执行过程中，遇到了其他线程对象的加塞（join）；</li><li>线程被调用suspend方法被挂起（已过时，因为容易发生死锁）；</li></ul><p>当前正在执行的线程被阻塞后，其他线程就有机会执行了。针对如上情况，当发生如下情况时会解除阻塞，让该线程重新进入就绪状态，等待线程调度器再次调度它：</p><ul><li>线程的sleep()时间到；</li><li>线程调用的阻塞式IO方法已经返回；</li><li>线程成功获得了同步监视器；</li><li>线程等到了通知(notify)；</li><li>加塞的线程结束了；</li><li>被挂起的线程又被调用了resume恢复方法（已过时，因为容易发生死锁）；</li></ul></li><li><p>死亡</p><p>线程会以以下三种方式之一结束，结束后的线程就处于死亡状态：</p><ul><li><p>run()方法执行完成，线程正常结束</p></li><li><p>线程执行过程中抛出了一个未捕获的异常（Exception）或错误（Error）</p></li><li><p>直接调用该线程的stop()来结束该线程（已过时，因为容易发生死锁）</p><p>可以调用线程的isAlive()方法判断该线程是否死亡，当线程处于就绪、运行、阻塞三种状态时，该方法返回true，当线程处于新建、死亡两种状态时，该方法将返回false。 </p></li></ul></li></ul><p><strong>注意：</strong></p><p>程序只能对新建状态的线程调用start()，并且只能调用一次，如果对非新建状态的线程，如已启动的线程或已死亡的线程调用start()都会报错IllegalThreadStateException异常。</p><h2 id="Thread的相关API"><a href="#Thread的相关API" class="headerlink" title="Thread的相关API"></a>Thread的相关API</h2><p>1、构造器</p><ul><li>Thread()</li><li>Thread(String name)</li><li>Thread(Runnable target)</li><li>Thread(Runnable target, String name)</li></ul><p>2、其他方法</p><p>（1）public void run()：子类必须重写，它的方法体也称为线程体，即线程的任务代码</p><p>（2）public void start()：启动线程</p><p>（3）Thread.currentThread()：获取当前线程对象</p><p>（4）getName()：获取当前线程的名称</p><p>（5）set/getPriority()：设置或获取线程的优先级</p><p>​        优先级的范围：[1,10]，Thread类中有三个常量：MAX_PRIORITY(10)，MIN_PRIORITY(1)，NORM_PRIORITY(默认优先级5)</p><p>​        优先级只是影响概率。 </p><p>（6）线程休眠：Thread.sleep(毫秒)</p><p>（7）打断线程：interrupt()</p><p>（8）暂停当前线程：Thread.yield()</p><p>（9）线程要加塞：join()</p><blockquote><p>xx.join()这句代码写在哪个线程体中，哪个线程被加塞，和其他线程无关。</p></blockquote><p>（10）判断线程是否已启动但未终止：isAlive()</p><h2 id="关键字：volatile"><a href="#关键字：volatile" class="headerlink" title="关键字：volatile"></a>关键字：volatile</h2><p>volatile：易变，不稳定，不一定什么时候会变</p><p>修饰：成员变量</p><p>作用：当多个线程同时去访问的某个成员变量时，而且是频繁的访问，再多次访问时，发现它的值没有修改，Java执行引擎就会对这个成员变量的值进行缓存。一旦缓存之后，这个时候如果有一个线程把这个成员变量的值修改了，Jav执行引擎还是从缓存中读取，导致这个值不是最新的。如果不希望Java执行引擎把这个成员变的值缓存起来，那么就可以在成员变量的前面加volatile，每次用到这个成员变量时，都是从主存中读取。</p><h2 id="关键字：synchronized（同步）"><a href="#关键字：synchronized（同步）" class="headerlink" title="关键字：synchronized（同步）"></a>关键字：synchronized（同步）</h2><p>1、什么情况下会发生线程安全问题？</p><p>（1）多个线程</p><p>（2）共享数据</p><p>（3）多个线程的线程体中，多条语句再操作这个共享数据时</p><p>2、如何解决线程安全问题？同步锁</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/synchronized.png" alt="synchronized"></p><p>形式一：同步代码块</p><p>形式二：同步方法</p><p>3、同步代码块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">    <span class="comment">//一次任务代码，这其中的代码，在执行过程中，不希望其他线程插一脚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁对象：</p><p>​    锁对象又称为监视器对象，同一时刻，某一段代码，只允许一个线程运行，这个锁就记录当前线程，其他线程进不来，直到当前线程执行完毕代码，然后才释放锁对象</p><p>（1）任意类型的对象</p><p>（2）确保使用共享数据的这几个线程，使用同一个锁对象</p><p>4、同步方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> 【修饰符】 返回值类型  方法名(【形参列表】)<span class="keyword">throws</span> 异常列表&#123;</span><br><span class="line">    <span class="comment">//同一时间，只能有一个线程能进来运行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】<span class="keyword">synchronized</span> 返回值类型  方法名(【形参列表】)<span class="keyword">throws</span> 异常列表&#123;</span><br><span class="line">    <span class="comment">//同一时间，只能有一个线程能进来运行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其实就是方法加上synchronized关键字</span></span><br></pre></td></tr></table></figure><p>锁对象：</p><p>​    同步方法的锁对象，程序员是无法选择的</p><p>（1）非静态方法：锁对象是this（谨慎）</p><p>（2）静态方法：锁对象是当前类的Class对象</p><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>生产者与消费者问题（英语：Producer-consumer problem），也称有限缓冲问题（英语：Bounded-buffer problem），是一个多线程同步问题的经典案例。</p><p>该问题描述了两个（多个）共享固定大小缓冲区的线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p><p>生产者与消费者问题中其实隐含了两个问题：</p><ul><li><p>线程安全问题：</p><p>因为生产者与消费者共享数据缓冲区，不过这个问题可以使用同步解决。</p></li><li><p>线程的协调工作问题：</p><p>要解决该问题，就必须让生产者线程在缓冲区满时等待(wait)，暂停进入阻塞状态，等到下次消费者消耗了缓冲区中的数据的时候，通知(notify)正在等待的线程恢复到就绪状态，重新开始往缓冲区添加数据。同样，也可以让消费者线程在缓冲区空时进入等待(wait)，暂停进入阻塞状态，等到生产者往缓冲区添加数据之后，再通知(notify)正在等待的线程恢复到就绪状态。通过这样的通信机制来解决此类问题。</p></li></ul><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/thread2.png" alt="thread"></p><p>Object类中提供了wait()、notify()、notifyAll()方法，这三个方法并不属于Thread类，那是因为这三个方法必须有同步监视器对象来调用，而同步监视器对象可以是任意类型的对象，因此它们只能声明在Object类中。</p><p>1、为了解决“生产者与消费者问题”。</p><p>当一些线程负责往“数据缓冲区”放数据，另一个线程负责从“数据缓冲区”取数据。</p><p>问题1：生产者线程与消费者线程使用同一个数据缓冲区，就是共享数据，那么要考虑同步</p><p>问题2：当数据缓冲区满的时候，生产者线程需要wait()， 当消费者消费了数据后，需要notify或notifyAll</p><p>​        当数据缓冲区空的时候，消费者线程需要wait()， 当生产者生产了数据后，需要notify或notifyAll</p><p>2、java.lang.Object类中声明了：</p><p>（1）wait()：必须由“同步锁”对象调用</p><p>（2）notfiy()和notifyAll()：必须由“同步锁”对象调用</p><p>3、面试题：sleep()和wait的区别</p><p>（1）sleep()不释放锁，wait()释放锁</p><p>（2）sleep()在Thread类中声明的，wait()在Object类中声明</p><p>（3）sleep()是静态方法，是Thread.sleep()</p><p>​        wait()是非静态方法，必须由“同步锁”对象调用</p><p>（4）sleep()方法导致当前线程进入阻塞状态后，当时间到或interrupt()醒来</p><p>​     wait()方法导致当前线程进入阻塞状态后，由notify或notifyAll()</p><p>4、哪些操作会释放锁？</p><p>（1）同步代码块或同步方法正常执行完一次自动释放锁</p><p>（2）同步代码块或同步方法遇到return等提前结束</p><p>（3）wait()</p><p>5、不释放锁</p><p>（1）sleep()</p><p>（2）yield()</p><p>（3）suspend()</p>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举与注解</title>
      <link href="/2020/06/12/java-exception/"/>
      <url>/2020/06/12/java-exception/</url>
      
        <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常的类型的体系结构"><a href="#异常的类型的体系结构" class="headerlink" title="异常的类型的体系结构"></a>异常的类型的体系结构</h2><p>1、异常系列的超父类：java.lang.Throwable</p><p>（1）只有它或它子类的对象，才能被JVM或throw语句“抛”出</p><p>（2）也只有它或它子类的对象，才能被catch“捕获”</p><p>2、Throwable分为两大派别</p><p>（1）Error：严重的错误，需要停下来重新设计、升级解决这个问题</p><p>（2）Exception： 一般的异常，可以通过判断、检验进行避免，或者使用try…catch进行处理</p><p>3、Exception又分为两大类</p><p>（1）运行时异常：</p><p>​    它是RuntimeException或它子类的对象。</p><p>​    这种类型的异常，编译器不会提醒你，要进行throws或try…catch进行处理，但是运行时可能导致崩溃。</p><p>（2）编译时异常：</p><p>​    异常除了运行时异常以外的都是编译时异常。</p><p>​    这种类型的异常，编译器是强制要求你，throws或try…catch进行处理，否则编译不通过。</p><p>4、列出常见的异常类型</p><p>（1）运行时异常</p><p>RuntimeException、NullPointerException（空指针异常），ClassCastException（类型转换异常），ArithmeticException（算术异常），NubmerFormatException（数字格式化异常），IndexOutOfBoundsException（下标越界异常）（ArrayIndexOutOfBoundsException（数组下标越界异常）、StringIndexOutOfBoundsException（字符串下标越界异常））、InputMisMatchException（输入类型不匹配异常）。。。。</p><p>（2）编译时异常</p><p>FileNotFoundException（文件找不到异常）、IOException（输入输出异常）、SQLException（数据库sql语句执行异常）。。。</p><h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><p>1、在当前方法中处理：try…catch…finally</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形式一：try...catch</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;。。。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//形式二：try...finally</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的代码</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    无论<span class="keyword">try</span>中是否有异常，也不管是不是有<span class="keyword">return</span>，都要执行的部分</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形式三：try..catch..finally</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;。。。</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    无论<span class="keyword">try</span>中是否有异常，也不管<span class="keyword">catch</span>是否可以捕获异常，也不管<span class="keyword">try</span>和<span class="keyword">catch</span>中是不是有<span class="keyword">return</span>，都要执行的部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行特点：</p><p>（1）如果try中的代码没有异常，那么try中的代码会正常执行，catch部分就不执行，finally中会执行</p><p>（2）如果try中的代码有异常，那么try中发生异常的代码的后面就不执行了，找对应的匹配的catch分支执行，finally中会执行</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/exception.png" alt="exception"></p><p>2、finally与return混合使用时</p><p>（1）如果finally中有return，一定从finally中的return返回。</p><p>此时try和catch中的return语句，执行了一半，执行了第一个动作。所以，finally中的return语句会覆盖刚刚的返回值</p><p>return 返回值; 语句有两个动作：（1）把返回值放到“操作数栈”中，等当前方法结束后，这个“操作数栈”中的值会返回给调用处（2）结束当前方法的执行</p><p>（2）如果finally中没有return，finally中的语句会执行，但是不影响最终的返回值</p><p>即try和catch中的return语句两步拆开来走，先把（1）把返回值放到“操作数栈”中，（2）然后走finally中的语句（3）再执行return后半个动作，结束当前方法</p><p>3、在当前方法中不处理异常，明确要抛给调用者处理，使用throws</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 返回值类型  方法名(【形参列表】) <span class="keyword">throws</span> 异常列表&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时调用者，就知道需要处理哪些异常。</p><p>方法的重写的要求：</p><p>（1）方法名：相同</p><p>（2）形参列表：相同</p><p>（3）返回值类型：</p><p>​    基本数据类型和void：相同</p><p>​    引用数据类型：&lt;=</p><p>（4）修饰符：</p><p>​    权限修饰符：&gt;=</p><p>​    其他修饰符：static，final，private不能被重写</p><p>（5）throws：&lt;=</p><p>方法的重载：</p><p>（1）方法名：相同</p><p>（2）形参列表：必须不同</p><p>（3）返回值类型：无关</p><p>（4）修饰符：无关</p><p>（5）throws：无关</p><h2 id="手动抛出异常：throw"><a href="#手动抛出异常：throw" class="headerlink" title="手动抛出异常：throw"></a>手动抛出异常：throw</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> 异常对象;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AccountException(<span class="string">"xxx"</span>);</span><br></pre></td></tr></table></figure><p>throw抛出来的异常对象，和JVM抛出来的异常对象一样，也要用try..catch处理或者throws。</p><p>如果是运行时异常，编译器不会强制要求你处理，如果是编译时异常，那么编译器会强制要求你处理。</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>1、必须继承Throwable或它的子类</p><p>我们见到比较多的是继承RuntimeException和Exception.</p><p>如果你继承RuntimeException或它的子类，那么你自定义的这个异常就是运行时异常。编译器就不会提醒你处理。</p><p>如果你继承Exception，那么它属于编译时异常，编译器会强制你处理。</p><p>2、建议大家保留两个构造器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">public</span> 自定义异常名()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line"><span class="keyword">public</span> 自定义异常名(String message)&#123;</span><br><span class="line">    <span class="keyword">super</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、自定义异常对象，必须手动抛出，用throw抛出</p><h2 id="关于异常的几个方法"><a href="#关于异常的几个方法" class="headerlink" title="关于异常的几个方法"></a>关于异常的几个方法</h2><p>（1）e.printStackTrace()：打印异常对象的详细信息，包括异常类型，message，堆栈跟踪信息。这个对于调试，或者日志跟踪是非常有用的</p><p>（2）e.getMessage()：只是获取异常的message信息</p><p>关于异常信息的打印：</p><p>用System.err打印和用e.printStackTrace()都是会标记红色的突出。</p><p>用System.out打印，当成普通信息打印。</p><p>这两个打印是两个独立的线程，顺序是不能精确控制的。</p>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 异常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举与注解</title>
      <link href="/2020/06/11/java-enum/"/>
      <url>/2020/06/11/java-enum/</url>
      
        <content type="html"><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>1、枚举（JDK1.5引入的）</p><p>​    枚举类型的对象是有限、固定的几个常量对象。</p><p>​    某些类的对象只有确定的有限个时，可以把这样的类声明为枚举类。</p><p>​    例如：</p><p>​        星期：Monday(星期一)……Sunday(星期天)</p><p>​        性别：Man(男)、Woman(女)</p><p>​        月份：January(1月)……December(12月)</p><p>​        季节：Spring(春节)……Winter(冬天)</p><p>​        七彩标准色：Red(红)……Purple(紫)</p><p>​        支付方式：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡)</p><p>​        就职状态：Busy、Free、Vocation、Dimission</p><p>​        订单状态：Nonpayment（未付款）、Paid（已付款）、Fulfilled（已配货）、Delivered（已发货）、Return（退货）、Checked（已确认）</p><p>2、语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形式一：枚举类型中只有常量对象列表</span></span><br><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类型名&#123;</span><br><span class="line">    常量对象列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形式二：枚举类型中只有常量对象列表</span></span><br><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类型名&#123;</span><br><span class="line">    常量对象列表;</span><br><span class="line">    </span><br><span class="line">    其他成员列表；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：常量对象列表必须在枚举类型的首行</p><ul><li><p>使用 enum 定义的枚举类，默认继承了 java.lang.Enum类。因此不能再继承其他类。</p></li><li><p>枚举类的所有构造器只能使用 private 访问控制符</p></li><li><p>枚举类的所有实例必须在枚举类的首行显式列出(, 分隔   ; 结尾)，它们实际上都是public static final修饰的常量对象。</p></li><li><p>JDK 1.5 之后可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEnumType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Season s = Season.SPRING;</span><br><span class="line"><span class="keyword">switch</span>(s)&#123;</span><br><span class="line">      <span class="keyword">case</span> SPRING:</span><br><span class="line">        System.out.println(<span class="string">"春暖花开"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> SUMMER:</span><br><span class="line">        System.out.println(<span class="string">"夏日炎炎"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AUTUMN:</span><br><span class="line">        System.out.println(<span class="string">"秋高气爽"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> WINTER:</span><br><span class="line">        System.out.println(<span class="string">"白雪皑皑"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Season&#123;</span><br><span class="line">SPRING,SUMMER,AUTUMN,WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回忆：首行</p><p>（1）super()或super(实参列表)：必须在子类构造器的首行</p><p>（2）this()或this(实参列表)：必须在本类构造器的首行</p><p>（3）package 包; 声明包的语句必须在源文件.java的代码首行</p><p>（4）枚举常量对象列表必须在枚举类型的首行</p><p>3、在其他类中如何获取枚举的常量对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取一个常量对象</span></span><br><span class="line">枚举类型名.常量对象名</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个常量对象</span></span><br><span class="line">枚举类型名.valueOf(<span class="string">"常量对象名"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取所有常量对象</span></span><br><span class="line">枚举类型名[] all = 枚举类型名.values();</span><br></pre></td></tr></table></figure><p>4、枚举类型的特点</p><p>（1）枚举类型有一个公共的基本的父类，是java.lang.Enum类型，所以不能再继承别的类型</p><p>（2）枚举类型的构造器必须是私有的</p><p>（3）枚举类型可以实现接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyRunnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Gender implements MyRunnable&#123;</span><br><span class="line">    NAN,NV;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">enum</span> Gender implements MyRunnable&#123;</span><br><span class="line">    NAN&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;,NV&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、父类java.lang.Enum类型</p><p>（1）构造器</p><p>​        protected Enum(String name, int ordinal)：由编译器自动调用</p><p>（2）String name()：常量对象名</p><p>（3）int ordinal()：返回常量对象的序号，第一个的序号是0</p><p>（4）String toString()：返回常量对象名，如果子类想重写，需要手动写</p><p>（5）int compareTo(Object obj)：按照常量对象的顺序比较</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>1、注解</p><p>​    它是代码级别的注释</p><p>2、标记符号：@</p><p>3、系统预定义的三个最基本的注解：</p><p>（1）@Override：表示某个方法是重写的方法</p><p>​        它只能用在方法上面，会让编译器对这个方法进行格式检查，是否满足重写的要求</p><p>（2）@SuppressWarnings(xx)：抑制警告</p><p>（3）@Deprecated：表示xx已过时</p><p>4、和文档注释相关的注解</p><p>（1）文档注释</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">文档注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>（2）常见的文档注释</p><p>@author：作者</p><p>@since：从xx版本加入的</p><p>@see：另请参考</p><p>@param：形参</p><p>@return：返回值</p><p>@throws或@exception：异常</p><p>5、JUnit相关的几个注解</p><p>（1）@Test：表示它是一个单元测试方法</p><p>这个方法需要是：public void xxx(){}</p><p>（2）@Before：表示在每一个单元测试方法之前执行</p><p>这个方法需要是：public void xxx(){}</p><p>（3）@After：表示在每一个单元测试方法之后执行</p><p>这个方法需要是：public void xxx(){}</p><p>（4）@BeforeClass：表示在类初始化阶段执行，而且只执行一次</p><p>这个方法需要是：public static void xxx(){}</p><p>（3）@AfterClass：表示在类的“卸载”阶段执行，而且只执行一次</p><p>这个方法需要是：public static void xxx(){}</p><p>6、元注解</p><p>（1）@Target(xx)：用它标记的注解能够用在xx位置</p><p>(xx)：由ElementType枚举类型的10个常量对象指定，例如：TYPE，METHOD，FIELD等</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;TYPE,METHOD,FIELD&#125;)</span><br></pre></td></tr></table></figure><p>（2）@Retention（xx）：用它标记的注解可以滞留到xx阶段</p><p>(xx)：由RetentionPolicy枚举类型的3个常量对象指定，分别是：SOURCE，CLASS，RUNTIME</p><p>唯有RUNTIME阶段的注解才能被反射读取到</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br></pre></td></tr></table></figure><p>（3）@Documentd：用它标记的注解可以读取到API中</p><p>（4）@Inherited：用它标记的注解可以被子类继承</p><p>7、自定义注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@元注解</span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@元注解</span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    配置参数列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置参数的语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型  配置参数名();</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">数据类型  配置参数名() <span class="keyword">default</span> 默认值;</span><br></pre></td></tr></table></figure><p>关于配置参数：</p><p>（1）配置参数的类型有要求：</p><p>八种基本数据类型、String、枚举、Class类型、注解、它们的数组。</p><p>（2）如果自定义注解声明了配置参数，那么在使用这个注解时必须为配置参数赋值，除非它有默认值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@自定义注解名(配置参数名<span class="number">1</span>=值，配置参数名<span class="number">2</span>=值。。。)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果配置参数类型是数组，那么赋值时，可以用&#123;&#125;表示数组</span></span><br><span class="line">@自定义注解名(配置参数名<span class="number">1</span>=&#123;值&#125;，配置参数名<span class="number">2</span>=值。。。)</span><br></pre></td></tr></table></figure><p>（3）如果配置参数只有一个，并且名称是value，那么赋值时可以省略value=</p><p>（4）如果读取这个注解时，要获取配置参数的值的话，可以当成方法一样来访问</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">自定义注解对象.配置参数();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 枚举与注解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 枚举与注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象的高级特征</title>
      <link href="/2020/06/03/java-oop3/"/>
      <url>/2020/06/03/java-oop3/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象的高级特性"><a href="#面向对象的高级特性" class="headerlink" title="面向对象的高级特性"></a>面向对象的高级特性</h1><h2 id="关键字：final"><a href="#关键字：final" class="headerlink" title="关键字：final"></a>关键字：final</h2><p>final：最终的</p><p>用法：</p><p>（1）修饰类（包括外部类、内部类类）</p><p>​        表示这个类不能被继承，没有子类</p><p>（2）修饰方法</p><p>​        表示这个方法不能被重写,但是任然被继承</p><p>（3）修饰变量（成员变量（类变量、实例变量），局部变量）</p><p>​        表示这个变量的值不能被修改</p><p>注意：如果某个成员变量用final修饰后，也得手动赋值，而且这个值一旦赋完，就不能修改了，即没有set方法</p><h2 id="关键字：native"><a href="#关键字：native" class="headerlink" title="关键字：native"></a>关键字：native</h2><p>native：本地的，原生的<br>用法：</p><p>​    只能修饰方法，而且看不见方法体</p><p>​    表示这个方法的方法体代码不是用Java语言实现的，而是调用了底层C/C++的代码，这些代码被编译为.dll文件，让Java来执行的</p><p>​    但是对于Java程序员来说，可以当做Java的方法一样去正常调用它，或者子类重写它。</p><p>JVM内存的管理：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jvm.png" alt="jvm"></p><p>方法区：类的信息、常量、静态变量、动态编译生成的字节码信息</p><p>虚拟机栈：Java语言实现的方法的局部变量</p><p>本地方法栈：非Java语言实现的方法的局部变量，即native方法执行时的内存区域</p><p>堆：new出来的对象</p><p>程序计数器：记录每一个线程目前执行到哪一句指令</p><h2 id="关键字：static"><a href="#关键字：static" class="headerlink" title="关键字：static"></a>关键字：static</h2><p>static：静态的</p><p>用法：</p><p>1、成员方法：我们一般称为静态方法或类方法</p><p>（1）不能被重写</p><p>（2）被使用</p><p>​        本类中：其他方法中可以直接使用它</p><p>​        其他类中：可以使用“类名.方法”进行调用，也可以使用”对象名.方法”，推荐使用“类名.方法”</p><p>（3）在静态方法中，我们不能出现：this，super，非静态的成员</p><p>2、成员变量：我们一般称为静态变量或类变量</p><p>（1）静态变量的值是该类所有对象共享的</p><p>（2）静态变量存储在方法区</p><p>（3）静态变量对应的get/set也是静态的</p><p>（4）静态变量与局部变量同名时，就可以使用“类名.静态变量”进行区分</p><p>3、内部类：后面讲</p><p>4、代码块：静态代码块</p><p>5、静态导入（JDK1.5引入）</p><p>没有静态导入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">1000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.unclehe.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(Utils.MAX_VALUE);</span><br><span class="line">        Utils.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用静态导入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">1000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.unclehe.utils.Utils.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(MAX_VALUE);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>1、语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        静态代码块;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、作用：</p><p>协助完成类初始化，可以为类变量赋值。</p><p>3、类初始化<clinit>()</p><p>类的初始化有：</p><p>①静态变量的显式赋值代码</p><p>②静态代码块中代码</p><p>其中①和②按顺序执行</p><p>注意：类初始化方法，一个类只有一个</p><p>4、类的初始化的执行特点：</p><p>（1）每一个类的<clinit>()只执行一次</p><p>（2）如果一个子类在初始化时，发现父类也没有初始化，会先初始化父类</p><p>（3）如果既要类初始化又要实例化初始化，那么一定是先完成类初始化的</p><h2 id="变量的分类与区别"><a href="#变量的分类与区别" class="headerlink" title="变量的分类与区别"></a>变量的分类与区别</h2><p>1、变量按照数据类型分：</p><p>（1）基本数据类型的变量，里面存储数据值</p><p>（2）引用数据类型的变量，里面存储对象的地址值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//a中存储的是数据值</span></span><br><span class="line"></span><br><span class="line">Student stu = <span class="keyword">new</span> Student();<span class="comment">//stu存储的是对象的地址值</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];<span class="comment">//arr存储的是数组对象的地址值</span></span><br><span class="line">String str = <span class="string">"hello"</span>;<span class="comment">//str存储的是"hello"对象的地址值</span></span><br></pre></td></tr></table></figure><p>2、变量按照声明的位置不同：</p><p>（1）成员变量</p><p>（2）局部变量</p><p>3、成员变量与局部变量的区别</p><p>（1）声明的位置不同</p><p>成员变量：类中方法外</p><p>局部变量：（1）方法的()中，即形参（2）方法体的{}的局部变量（3）代码块{}中</p><p>（2）存储的位置不同</p><p>成员变量：</p><p>​    如果是静态变量（类变量），在方法区中</p><p>​    如果是非静态的变量（实例变量），在堆中</p><p> 局部变量：栈</p><p>（3）修饰符不同</p><p>成员变量：4种权限修饰符、static、final…</p><p>局部变量：只有final</p><p>（4）生命周期</p><p>成员变量：</p><p>​    如果是静态变量（类变量），和类相同</p><p>​    如果是非静态的变量（实例变量），和所属的对象相同，每一个对象是独立</p><p>局部变量：每次执行都是新的</p><p>（5）作用域</p><p>成员变量：</p><p>​    如果是静态变量（类变量），在本类中随便用，在其他类中使用“类名.静态变量”</p><p>​    如果是非静态的变量（实例变量），在本类中只能在非静态成员中使用，在其他类中使用“对象名.非静态的变量”</p><p>局部变量：有作用域</p><h2 id="根父类"><a href="#根父类" class="headerlink" title="根父类"></a>根父类</h2><p>1、java.lang.Object类是类层次结构的根父类。包括数组对象。</p><p>（1）Object类中声明的所有的方法都会被继承到子类中，那么即所有的对象，都拥有Object类中的方法</p><p>（2）每一个对象的创建，最终都会调用到Object实例初始化方法<init>()</p><p>（3）Object类型变量、形参、数组，可以存储任意类型的对象</p><p>2、Object类的常用方法</p><p>（1）public String toString()：</p><p>​        ①默认情况下，返回的是“对象的运行时类型 @ 对象的hashCode值的十六进制形式”</p><p>​        ②通常是建议重写，如果在eclipse中，可以用Alt +Shift + S–&gt;Generate toString()</p><p>​        ③如果我们直接System.out.println(对象)，默认会自动调用这个对象的toString()</p><p>（2）public final Class&lt;?&gt; getClass()：获取对象的运行时类型</p><p>（3）protected void finalize()：当对象被GC确定为要被回收的垃圾，在回收之前由GC帮你调用这个方法。而且这个方法只会被调用一次。子类可以选择重写。</p><p>（4）public int hashCode()：返回每个对象的hash值。</p><p>​        <strong>规定：</strong></p><p>​                ①如果两个对象的hash值是不同的，那么这两个对象一定不相等；</p><p>​                ②如果两个对象的hash值是相同的，那么这两个对象不一定相等。</p><p>​        主要用于后面当对象存储到哈希表等容中时，为了提高性能用的。</p><p>（5）public boolean equals(Object obj)：用于判断当前对象this与指定对象obj是否“相等”</p><p>​        ①默认情况下，equals方法的实现等价于<code>==</code>，比较的是对象的地址值</p><p>​        ②我们可以选择重写，重写有些要求：</p><p>​            A：如果重写equals，那么一定要一起重写hashCode()方法，因为规定：</p><p>​                a：如果两个对象调用equals返回true，那么要求这两个对象的hashCode值一定是相等的；</p><p>​                b：如果两个对象的hashCode值不同的，那么要求这个两个对象调用equals方法一定是false；</p><p>​                c：如果两个对象的hashCode值相同的，那么这个两个对象调用equals可能是true，也可能是false</p><p>​            B：如果重写equals，那么一定要遵循如下几个原则：</p><p>​                a：自反性：x.equals(x)返回true</p><p>​                b：传递性：x.equals(y)为true, y.equals(z)为true，然后x.equals(z)也应该为true</p><p>​                c：一致性：只要参与equals比较的属性值没有修改，那么无论何时调用结果应该一致</p><p>​                d：对称性：x.equals(y)与y.equals(x)结果应该一样</p><p>​                e：非空对象与null的equals一定是false</p><h2 id="关键字：abstract"><a href="#关键字：abstract" class="headerlink" title="关键字：abstract"></a>关键字：abstract</h2><p>类用于描述现实生活中一类事物。类中有属性、有方法等成员。</p><p>某种情况下，父类只能知道子类应该具备一个怎样的方法，但是不能够明确知道如何实现该方法。</p><p>只能在子类中才能确定如何去实现方法体。</p><p>例如：定义一个几何图形。所有几何图形都应该具备一个计算面积的方法。但是不同的几何图形计算面积的方式完全不同。</p><p>Java中为上述问题提供了相应的解决办法：</p><p>Java允许父类中只是提供一个方法的声明（方法的签名），但是不提供具体的实现。</p><p>具体的实现由子类来完成，该方法被称为“抽象方法”。</p><p>拥有一个或者多个抽象方法的类，被称为“抽象类”。</p><p>1、什么时候会用到抽象方法和抽象类？</p><p>当声明父类的时候，在父类中某些方法的方法体的实现不能确定，只能由子类决定。但是父类中又要体现子类的共同的特征，即它要包含这个方法，为了统一管理各种子类的对象，即为了多态的应用。</p><p>那么此时，就可以选择把这样的方法声明为抽象方法。如果一个类包含了抽象方法，那么这个类就必须是个抽象类。</p><p>2、抽象类的语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【权限修饰符】 <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">【权限修饰符】 <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、抽象方法的语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【其他修饰符】 <span class="keyword">abstract</span> 返回值类型  方法名(【形参列表】);</span><br></pre></td></tr></table></figure><p>抽象方法没有方法体</p><p>4、抽象类的特点</p><p>（1）抽象类不能直接实例化，即不能直接new对象</p><p>（2）抽象类就是用来被继承的，那么子类继承了抽象类后，必须重写所有的抽象方法，否则这个子类也得是抽象类</p><p>（3）抽象类也有构造器，这个构造的作用不是创建抽象类自己的对象用的，给子类在实例化过程中调用；</p><p>（4）抽象类也可以没有抽象方法，那么目的是不让你创建对象，让你创建它子类的对象</p><p>（5）抽象类的变量与它子类的对象也构成多态引用</p><p>5、不能和abstract一起使用的修饰符？</p><p>（1）final：和final不能一起修饰方法和类</p><p>（2）static：和static不能一起修饰方法</p><p>（3）native：和native不能一起修饰方法</p><p>（4）private：和private不能一起修饰方法</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>1、接口的概念</p><p>接口是一种标准。注意关注行为标准（即方法）。</p><p>面向对象的开发原则中有一条：面向接口编程。</p><p>2、接口的声明格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">interface</span> 接口名</span>&#123;</span><br><span class="line">    接口的成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、类实现接口的格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 实现类  <span class="keyword">implements</span> 父接口们</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 实现类 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 父接口们</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、接口继承接口的格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">interface</span> 接口名 <span class="keyword">extends</span> 父接口们</span>&#123;</span><br><span class="line">    接口的成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、接口的特点</p><p>（1）接口不能直接实例化，即不能直接new对象</p><p>（2）只能创建接口的实现类对象，那么接口与它的实现类对象之间可以构成多态引用。</p><p>（3）实现类在实现接口时，必须重写所有抽象的方法，否则这个实现类也得是抽象类。</p><p>（4）Java规定类与类之间，只能是单继承，但是Java的类与接口之间是多实现的关系，即一个类可以同时实现多个接口</p><p>（5）Java还支持接口与接口之间的多继承。</p><p>6、接口的成员</p><p>JDK1.8之前：</p><p>（1）全局的静态的常量：public static final，这些修饰符可以省略</p><p>（2）公共的抽象方法：public abstract，这些修饰符也可以省略</p><p>JDK1.8之后：</p><p>（3）公共的静态的方法：public static ,这个就不能省略了</p><p>（4）公共的默认的方法：public default，这个就不能省略了</p><p>7、默认方法冲突问题</p><p>（1） 当一个实现类同时实现了两个或多个接口，这个多个接口的默认方法的签名相同。</p><p>解决方案：</p><p>方案一：选择保留其中一个</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口名.<span class="keyword">super</span>.方法名(【实参列表】);</span><br></pre></td></tr></table></figure><p>方案二：完全重写</p><p>（2）当一个实现类同时继承父类，又实现接口，父类中有一个方法与接口的默认方法签名相同</p><p>解决方案：</p><p>方案一：默认方案，保留父类的</p><p>方案二：选择保留接口的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口名.<span class="keyword">super</span>.方法名(【实参列表】);</span><br></pre></td></tr></table></figure><p>方案三：完全重写</p><p>8、示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> MAX_SPEED = <span class="number">7900000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9、常用的接口</p><p>（1）java.lang.Comparable接口：自然排序</p><p>​    抽象方法：int compareTo(Object obj)</p><p>（2）java.util.Comparator接口：定制排序</p><p>​    抽象方法：int compare(Object obj1 ,Object obj2)</p><p>（3）示例代码</p><p>如果员工类型，默认顺序，自然顺序是按照编号升序排列，那么就实现Comparable接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略了构造器，get/set,toString</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id - ((Employee)obj).id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在后面又发现有新的需求，想要按照薪资排序，那么只能选择用定制排序，实现Comparator接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalaryComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span></span>&#123;</span><br><span class="line">        Employee e1 = (Employee)o1;</span><br><span class="line">        Employee e2 = (Employee)o2;</span><br><span class="line">        <span class="keyword">if</span>(e1.getSalary() &gt; e2.getSalary())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e1.getSalary() &lt; e2.getSalary())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>1、内部类的概念</p><p>​    声明在另外一个类里面的类就是内部类。</p><p>2、内部类的4种形式</p><p>（1）静态内部类</p><p>（2）非静态成员内部类</p><p>（3）有名字的局部内部类</p><p>（4）匿名内部类</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>1、语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在匿名子类中调用父类的无参构造</span></span><br><span class="line"><span class="keyword">new</span> 父类()&#123;</span><br><span class="line">    内部类的成员列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在匿名子类中调用父类的有参构造</span></span><br><span class="line"><span class="keyword">new</span> 父类(实参列表)&#123;</span><br><span class="line">    内部类的成员列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口没有构造器，那么这里表示匿名子类调用自己的无参构造，调用默认父类Object的无参构造</span></span><br><span class="line"><span class="keyword">new</span> 父接口名()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、匿名内部类、匿名对象的区别？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> Student(<span class="string">"张三"</span>));<span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">Student stu = <span class="keyword">new</span> Student(<span class="string">"张三"</span>);<span class="comment">//这个对象有名字，stu</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//既有匿名内部类，又是一个匿名的对象</span></span><br><span class="line"><span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.test();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个匿名内部类的对象，使用obj这个名字引用它，既对象有名字，但是这个Object的子类没有名字</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3、使用的形式</p><p>（1）示例代码：继承式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//用父类与匿名内部类的对象构成多态引用</span></span><br><span class="line">        Father f = <span class="keyword">new</span> Father()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"用匿名内部类继承了Father这个抽象类，重写了test抽象方法"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        f.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）示例代码：实现式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//用父接口与匿名内部类的对象构成了多态引用</span></span><br><span class="line">        Flyable f = <span class="keyword">new</span> Flyable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"用匿名内部类实现了Flyable这个接口，重写了抽象方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        f.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）示例代码：用匿名内部类的匿名对象直接调用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用匿名内部类的匿名对象直接调用方法"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.test();</span><br></pre></td></tr></table></figure><p>（4）示例代码：用匿名内部类的匿名对象直接作为实参</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student[] all = <span class="keyword">new</span> Student[<span class="number">3</span>];</span><br><span class="line">all[<span class="number">0</span>] = <span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="number">23</span>);</span><br><span class="line">all[<span class="number">1</span>] = <span class="keyword">new</span> Student(<span class="string">"李四"</span>,<span class="number">22</span>);</span><br><span class="line">all[<span class="number">2</span>] = <span class="keyword">new</span> Student(<span class="string">"王五"</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用匿名内部类的匿名对象直接作为实参</span></span><br><span class="line"><span class="comment">//这个匿名内部类实现了Comparator接口</span></span><br><span class="line"><span class="comment">//这个匿名内部类的对象，是定制比较器的对象</span></span><br><span class="line">Arrays.sort(all, <span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Obeject o1, Object o2)</span></span>&#123;</span><br><span class="line">        Student s1 = (Student)o1;</span><br><span class="line">        Student s2 = (Student)o2;</span><br><span class="line">        <span class="keyword">return</span> s1.getAge() - s2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 外部类名  【<span class="keyword">extends</span> 外部类的父类】 【<span class="keyword">implements</span> 外部类的父接口们】</span>&#123;</span><br><span class="line">【其他修饰符】 <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  静态内部类 【<span class="keyword">extends</span> 静态内部类自己的父类】 【<span class="keyword">implements</span> 静态内部类的父接口们】</span>&#123;</span><br><span class="line">        静态内部类的成员列表;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">外部类的其他成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 使用注意事项</p><p>（1）包含成员是否有要求：</p><p>​        可以包含类的所有成员</p><p>（2）修饰符要求：</p><ul><li>​        权限修饰符：4种</li><li>​        其他修饰符：abstract、final</li></ul><p>（3）使用外部类的成员上是否有要求</p><ul><li>​        只能使用外部类的静态成员</li></ul><p>（4）在外部类中使用静态内部类是否有要求</p><ul><li>​        正常使用</li></ul><p>（5）在外部类的外面使用静态内部类是否有要求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）如果使用的是静态内部类的静态成员</span><br><span class="line">外部类名.静态内部类名.静态成员</span><br><span class="line">（<span class="number">2</span>）如果使用的是静态内部类的非静态成员</span><br><span class="line">①先创建静态内部类的对象</span><br><span class="line">外部类名.静态内部类名 对象名 = <span class="keyword">new</span> 外部类名.静态内部类名(【实参列表】);</span><br><span class="line">②通过对象调用非静态成员</span><br><span class="line">对象名.xxx</span><br></pre></td></tr></table></figure><p>（6）字节码文件形式：外部类名$静态内部类名.class</p><p>3、示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer.Inner.test();</span><br><span class="line">        </span><br><span class="line">        Outer.Inner in = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h3><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 外部类名  【<span class="keyword">extends</span> 外部类的父类】 【<span class="keyword">implements</span> 外部类的父接口们】</span>&#123;</span><br><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span>  非静态内部类 【<span class="keyword">extends</span> 非静态内部类自己的父类】 【<span class="keyword">implements</span> 非静态内部类的父接口们】</span>&#123;</span><br><span class="line">        非静态内部类的成员列表;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">外部类的其他成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 使用注意事项</p><p>（1）包含成员是否有要求：</p><p>​    不允许出现静态的成员</p><p>（2）修饰符要求</p><p>​    权限修饰符：4种</p><p>​    其他修饰符：abstract，final</p><p>（3）使用外部类的成员上是否有要求</p><p>​    都可以使用</p><p>（4）在外部类中使用非静态内部类是否有要求</p><p>​    在外部类的静态成员中不能使用非静态内部类</p><p>（5）在外部类的外面使用非静态内部类是否有要求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用非静态内部类的非静态成员</span></span><br><span class="line"><span class="comment">//(1)创建外部类的对象</span></span><br><span class="line">外部类名  对象名<span class="number">1</span> = <span class="keyword">new</span>  外部类名(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)通过外部类的对象去创建或获取非静态内部类的对象</span></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line">外部类名.非静态内部类名  对象名<span class="number">2</span> = 对象名<span class="number">1</span>.<span class="keyword">new</span> 非静态内部类名(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line">外部类名.非静态内部类名  对象名<span class="number">2</span> = 对象名<span class="number">1</span>.get非静态内部类对象的方法(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）通过非静态内部类调用它的非静态成员</span></span><br><span class="line">对象名<span class="number">2</span>.xxx</span><br></pre></td></tr></table></figure><p>（6）字节码文件形式：外部类名$非静态内部类名.class</p><p>3、示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">            System.out.println(j);<span class="comment">//可以</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">// Inner in = new Inner();//不可以</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        </span><br><span class="line">        Outer.Inner in1 = out.<span class="keyword">new</span> Inner();     <span class="comment">//创建   </span></span><br><span class="line">        in1.method();</span><br><span class="line">        </span><br><span class="line">        Outer.Inner in2 = out.getInner();<span class="comment">//获取</span></span><br><span class="line">        in2.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 外部类名  【<span class="keyword">extends</span> 外部类的父类】 【<span class="keyword">implements</span> 外部类的父接口们】</span>&#123;</span><br><span class="line">【修饰符】 返回值类型  方法名(【形参列表】)&#123;</span><br><span class="line">        【修饰符】 <span class="class"><span class="keyword">class</span>  局部内部类 【<span class="keyword">extends</span> 局部内部类自己的父类】 【<span class="keyword">implements</span> 局部内部类的父接口们】</span>&#123;</span><br><span class="line">        局部内部类的成员列表;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">外部类的其他成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 使用注意事项</p><p>（1）包含成员是否有要求</p><p>​    不允许出现静态的成员</p><p>（2）修饰符要求</p><p>​    权限修饰符：不能</p><p>​    其他修饰符：abstract、final</p><p>（3）使用外部类的成员等上是否有要求</p><p>​    ①使用外部类的静态成员：随便用</p><p>​    ②使用外部类的非静态成员：能不能用要看所在的方法是否是静态的</p><p>​    ③使用所在方法的局部变量：必须 final修饰的</p><p>（4）在外部类中使用局部内部类是否有要求</p><p>​    有作用域</p><p>（5）在外部类的外面使用局部内部类是否有要求</p><p>​    没法使用</p><p>（6）字节码文件形式：外部类名$编号局部内部类名.class</p><p>3、示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">                System.out.println(j);<span class="comment">//可以</span></span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> k = <span class="number">30</span>;</span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">                System.out.println(j);<span class="comment">//不可以</span></span><br><span class="line">                System.out.println(k);<span class="comment">//可以</span></span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象的基本特征</title>
      <link href="/2020/06/02/java-oop2/"/>
      <url>/2020/06/02/java-oop2/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象的基本特征"><a href="#面向对象的基本特征" class="headerlink" title="面向对象的基本特征"></a>面向对象的基本特征</h1><p>面向对象的基本特征：</p><p>1、封装</p><p>2、继承</p><p>3、多态</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><blockquote><p>封装是面向对象编程的核心思想。将对象的属性和行为封装起来，其载体就是类。类通常对客户隐藏其实现细节，这就是封装的思想。</p></blockquote><p>1、好处：</p><p>（1）隐藏实现细节，方便使用者使用</p><p>（2）安全，可以控制可见范围</p><p>2、如何实现封装？</p><p>通过权限修饰符</p><blockquote><p>面试题：请按照可见范围从小到大（从大到小）列出权限修饰符？</p></blockquote><table><thead><tr><th>修饰符</th><th>本类</th><th>本包</th><th>其他包的子类</th><th>任意位置</th></tr></thead><tbody><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>缺省(什么都不写)</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>权限修饰符可以修饰什么？</p><p>类（类、接口等）、属性、方法、构造器、内部类</p><p>类（外部类）：常用<code>public</code>和<code>缺省</code>修饰</p><p>属性：4种都可以</p><p>方法：4种都可以</p><p>构造器：4种都可以</p><p>内部类：4种都可以</p><p>3、通常属性的封装是什么样的？</p><p>当属性的权限修饰符可以是private、缺省、protected、public。但是我们大多数时候，见到的都是private，然后给它们配上get/set方法。</p><p>示例代码：标准Javabean的写法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性私有化</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> marry;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公共的get/set</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">        name = n;<span class="comment">//这里因为还没有学习this等，可能还会优化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMarry</span><span class="params">(<span class="keyword">boolean</span> m)</span></span>&#123;</span><br><span class="line">        marry = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMarry</span><span class="params">()</span></span>&#123;<span class="comment">//boolean类型的属性的get方法，习惯使用把get换成is</span></span><br><span class="line">        <span class="keyword">return</span> marry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>1、构造器的作用：<br>（1）和new一起使用创建对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用无参构造创建对象</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参构造创建对象</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名(实参列表);</span><br></pre></td></tr></table></figure><p>（2）可以在创建对象的同时为属性赋值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">        radius = r;<span class="comment">//为radius赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、声明构造器的语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 类名()&#123;<span class="comment">//无参构造</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    【修饰符】 类名(形参列表)&#123;<span class="comment">//有参构造</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、构造器的特点：</p><p>（1）所有的类都有构造器</p><p>（2）如果一个类没有显式/明确的声明一个构造器，那么编译器将会自动添加一个默认的无参构造</p><p>（3）如果一个类显式/明确的声明了构造器，那么编译器将不再自动添加默认的无参构造，如果需要，那么就需要手动添加</p><p>（4）构造器的名称必须与类名相同</p><p>（5）构造器没有返回值类型</p><p>（6）构造器可以重载</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">        radius = r;<span class="comment">//为radius赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键字this"><a href="#关键字this" class="headerlink" title="关键字this"></a>关键字this</h2><p>1、this关键字：</p><p>意思：当前对象</p><p>（1）如果出现在构造器中：表示正在创建的对象</p><p>（2）如果出现在成员方法中：表示正在调用这个方法的对象</p><p>2、this的用法：</p><p>（1）this.属性</p><p>​    当局部变量与成员变量同名时，那么可以在成员变量的而前面加“this.”用于区别</p><p>（2）this.方法</p><p>​    调用当前对象的成员方法，完全可以省略“this.”</p><p>（3）this()或this(实参列表)</p><p>​    this()表示调用本类的无参构造</p><p>​    this(实参列表)表示调用本类的有参构造</p><blockquote><p>this()或this(实参列表)要么没有，要么必须出现在构造器的首行</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、成员变量与局部变量的区别？</p><p>这里只讨论实例变量（关于类变量见static部分）</p><p>（1）声明的位置不同</p><p>成员变量：类中方法外</p><p>局部变量：方法中或代码中</p><p>​    ①方法的形参列表</p><p>​    ②方法体中局部变量</p><p>​    ③代码块中的局部变量</p><p>（2）运行时在内存中的存储位置不同</p><p>成员变量：堆</p><p>局部变量：栈</p><blockquote><p>基本数据类型的变量在栈中，引用数据类型的变量在堆中：不准确</p></blockquote><p>（3）修饰符</p><p>成员变量：有很多修饰符，例如：权限修饰符</p><p>局部变量：不能加权限修饰符，唯一的能加的是final</p><p>（4）初始化</p><p>成员变量：有默认值</p><p>局部变量：没有默认值，必须手动初始化</p><p>（5）生命周期</p><p>成员变量：随着对象的创建而创建，随着对象被回收而消亡，即与对象同生共死。每一个对象都是独立的。</p><p>局部变量：方法调用时才分配，方法运行结束就没有了。每一次方法调用，都是独立的</p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>1、包的作用：</p><p>（1）可以避免类重名</p><p>​    有了包之后，类的全名称就变为：包.类名</p><p>（2）分类组织管理众多的类</p><p>​    例如：java.lang包，java.util包，java.io包…..</p><p>（3）可以控制某些类型或成员的可见范围</p><p>​    如果某个类型或者成员的权限修饰缺省的话，那么就仅限于本包使用</p><p>2、声明包的语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>(1)必须在源文件的代码首行</p><p>(2)一个源文件只能有一个</p></blockquote><p>3、包的命名规范和习惯：<br>（1）所有单词都小写，每一个单词之间使用.分割<br>（2）习惯用公司的域名倒置</p><p>例如：com.alibaba.xxx;</p><blockquote><p>建议大家取包名时不要使用“java.xx”包，可能与java的核心包重复</p></blockquote><p>4、使用其他包的类：</p><p>​    前提：被使用的类或成员的权限修饰符是 &gt; 缺省的</p><p>（1）使用类型的全名称</p><p>​    例如：java.util.Scanner input = new java.util.Scanner(System.in);</p><p>（2）使用import 语句之后，代码中使用简名称</p><p>5、import语句</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 包.类名;</span><br><span class="line"><span class="keyword">import</span> 包.*;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>当使用两个不同包的同名类时，例如：java.util.Date和java.sql.Date。一个使用全名称，一个使用简名称</p><p>Java.lang包中的类可以不使用import语句，直接使用简名称</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.project.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>1、为什么要继承</p><ul><li>当多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。提高了代码的复用性。</li><li>继承的出现让类与类之间产生了关系，可以创建更为特殊的类型。</li><li>利于可维护性。<br>此处的多个类称为<strong>子类</strong>（派生类SubClass），单独的这个类称为<strong>父类</strong>（基类或超类SuperClass）。</li></ul><p><strong>继承的好处</strong></p><p>（1）代码的复用</p><p>（2）代码的扩展</p><p>2、如何实现继承？</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 子类  <span class="keyword">extends</span> 父类</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、继承的特点</p><p>（1）子类会继承父类的所有特征（属性、方法）</p><p>​    但是，私有的在子类中是不能直接使用的(可通过get/set间接使用)</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/inherit.png" alt="inherit"></p><p>（2）子类不会继承父类的构造器</p><p>​    因为，父类的构造器是用于创建父类的对象的</p><p>（3）子类的构造器中又必须去调用父类的构造器</p><p>​    在创建子类对象的同时，为从父类继承的属性进行初始化用，可以借助父类的构造器中的代码为属性赋值。</p><p>（4）Java只支持单继承：一个子类只能有一个“直接”父类</p><p>（5）Java又支持多层继承：父类还可以有父类，特征会代代相传</p><p>（6）一个父类可以同时拥有很多个子类</p><h2 id="关键字super"><a href="#关键字super" class="headerlink" title="关键字super"></a>关键字super</h2><p>super关键字：引用父类的xx，找父类的xx</p><p>用法：</p><p>（1）super.属性</p><p>​    当子类声明了和父类同名的成员变量时，那么如果要表示某个成员变量是父类的，那么可以加“super.”</p><p>（2）super.方法</p><p>​    当子类重写了父类的方法，又需要在子类中调用父类被重写的方法，可以使用”super.”</p><p>（3）super()或super(实参列表)</p><p>​    super()：表示调用父类的无参构造</p><p>​    super(实参列表)：表示调用父类的有参构造</p><blockquote><p>注意：</p><p>（1）如果要写super()或super(实参列表)，必须写在子类构造器的首行</p><p>（2）如果子类的构造器中没有写：super()或super(实参列表)，那么默认会有 super()</p><p>（3）如果父类没有无参构造，那么在子类的构造器的首行“必须”写super(实参列表)</p><p>（4）如果子类构造器中写了super(实参列表)，那么super()就不会存在</p></blockquote><h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p>1、方法的重写（Override）</p><p>当子类继承了父类的方法时，又觉得父类的方法体的实现不适合于子类，那么子类可以选择进行重写。</p><p>2、方法的重写的要求</p><p>（1）方法名：必须相同</p><p>（2）形参列表：必须相同</p><p>（3）修饰符</p><p>​    权限修饰符：子类方法的权限修饰符的可见性范围 &gt;= 父类被重写方法的权限修饰符的可见性范围</p><p>​        例如：</p><p>​                子类方法的权限修饰符是public，父类被重写的权限修饰符public</p><p>​                子类方法的权限修饰符是public，父类被重写的权限修饰符protected</p><p>（4）返回值类型</p><p>​    如果是基本数据类型和void：必须相同</p><p>​    如果是引用数据类型：要求子类重写的方法返回值类型 &lt;= 父类被重写的方法的返回值类型</p><p>​        例如：</p><p>​                子类方法的返回值类型是Student，父类被重写的返回值类型是Student</p><p>​                子类方法的返回值类型是Student，父类被重写的返回值类型是Person</p><p>​    在Java中我们认为，在概念范围上：子类 &lt; 父类</p><p>3、重载（Overload）与重写（Override）的区别</p><p>​    重载（Overload）：在同一个类中，方法名相同，形参列表不同，和返回值类型无关的两个或多个方法。</p><p>​    重写（Override）：在父子类之间。对方法签名的要求见上面。</p><p>特殊的重载：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOverload</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="comment">//b对象可以调用几个a方法</span></span><br><span class="line">b.a();</span><br><span class="line">b.a(<span class="string">""</span>);<span class="comment">//从b对象同时拥有两个方法名相同，形参不同的角度来说，算是重载</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非静态代码块"><a href="#非静态代码块" class="headerlink" title="非静态代码块"></a>非静态代码块</h2><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        非静态代码块</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、作用</p><p>目的：在创建的过程中，为对象属性赋值，协助完成实例初始化的过程</p><p>3、什么时候执行？</p><p>（1）每次创建对象时都会执行</p><p>（2）优先于构造器执行</p><h2 id="实例初始化过程"><a href="#实例初始化过程" class="headerlink" title="实例初始化过程"></a>实例初始化过程</h2><p>1、概念描述</p><ul><li><p>实例初始化过程：实例对象创建的过程</p></li><li><p>实例初始化方法：实例对象创建时要执行的方法</p></li><li><p>实例初始化方法的由来：它是有编译器编译生成的</p></li><li><p>实例初始化方法的形式：<init>()或<init>(形参列表)</p></li><li><p>实例初始化方法的构成：</p><p>①属性的显式赋值代码</p><p>②非静态代码块的代码</p><p>③构造器的代码</p><blockquote><p>其中</p><p>①和②按顺序执行，从上往下</p><p>③在①和②的后面</p></blockquote></li></ul><p>因此一个类有几个构造器，就有几个实例初始化方法。</p><p>2、单个类实例初始化方法</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"非静态代码块1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String str = assign();<span class="comment">//调用方法，来为str进行显式赋值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.str = str;</span><br><span class="line">System.out.println(<span class="string">"有参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"非静态代码块2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">assign</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"assign方法"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/initialization.png" alt="initialization"></p><p>3、父子类的实例初始化</p><p>注意：</p><p>（1）原先super()和super(实参列表)说是调用父类的构造器，现在就要纠正为调用父类的实例初始化方法了</p><p>（2）原先super()和super(实参列表)说是必须在子类构造器的首行，现在要纠正为必须在子类实例初始化方法的首行</p><p>结论：</p><p>（1）执行顺序是先父类实例初始化方法，再子类实例初始化方法</p><p>（2）如果子类重写了方法，通过子类对象调用，一定是执行重写过的方法</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ba</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String str = assign();</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"(1)父类的非静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Ba</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"(2)父类的无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">assign</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"(3)父类的assign()"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"ba"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Er</span> <span class="keyword">extends</span> <span class="title">Ba</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String str = assign();</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"(4)子类的非静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Er</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//super()  ==&gt;调用父类的实例初始化方法，而且它在子类实例初始化方法的首行</span></span><br><span class="line">System.out.println(<span class="string">"(5)子类的无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">assign</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"(6)子类的assign()"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"er"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Er();<span class="comment">//612645</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/initialization2.png" alt="initialization"></p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>1、多态：</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类 引用/变量 = 子类的对象;</span><br></pre></td></tr></table></figure><p>2、前提：</p><p>（1）继承</p><p>（2）方法的重写</p><p>（3）多态引用</p><p>3、现象：</p><p>​    编译时看左边/“父类”，运行时看右边/“子类”。</p><p>​    编译时，因为按父类编译，那么只能父类有的方法，子类扩展的方法是无法调用的；    </p><p>​    执行时一定是运行子类重写的过的方法体。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"走路"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"细嚼慢咽的吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"婀娜多姿走路"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shop</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"买买买..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"狼吞虎咽的吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"大摇大摆的走路"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"吞云吐雾"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Woman();<span class="comment">//多态引用</span></span><br><span class="line">        p.eat();<span class="comment">//执行子类重写</span></span><br><span class="line">        p.walk();<span class="comment">//执行子类重写</span></span><br><span class="line">        <span class="comment">//p.shop();//无法调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、应用：</p><p>（1）多态参数：形参是父类类型，实参是子类对象</p><p>（2）多态数组：数组元素类型是父类，元素存储的是子类对象</p><p>示例代码：多态参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> Woman());<span class="comment">//实参是子类对象</span></span><br><span class="line">        test(<span class="keyword">new</span> Man());<span class="comment">//实参是子类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Person p)</span></span>&#123;<span class="comment">//形参是父类类型</span></span><br><span class="line">      <span class="comment">// 相当于 Person p = new Woman() 或者 new Man() 形成多态</span></span><br><span class="line">        p.eat();</span><br><span class="line">        p.walk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：多态数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person[] arr = <span class="keyword">new</span> Person[<span class="number">2</span>];<span class="comment">//多态数组</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> Woman(); <span class="comment">// arr[0] 的类型为Person 形成多态</span></span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> Man();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            all[i].eat();</span><br><span class="line">            all[i].walk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、向上转型与向下转型：父子类之间的转换</p><p>（1）向上转型：自动类型转换</p><p>​    当把子类的对象赋值给父类的变量时（即多态引用时），在编译时，这个对象就向上转型为父类。此时就看不见子类“特有、扩展”的方法。</p><p>（2）向下转型：强制转换。有风险，可能会报ClassCastException异常。</p><p>​    当需要把父类的变量赋值给一个子类的变量时，就需要向下转型。</p><p>​    <strong>要想转型成功，必须保证该变量中保存的对象的运行时类型是 &lt;= 强转的类型</strong></p><p><strong>为什么要向上转型？</strong></p><p>​    因为多态数组、多态参数的应用场景，使得有的时候，不得不向上转型，这是为了方便统一管理各种子类的对象。</p><p><strong>为什么要向下转型?</strong></p><p>​    向下转型的目的是为了调用子类特有的方法等    </p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChineseWoman</span> <span class="keyword">extends</span> <span class="title">Woman</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//向上转型</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Woman();</span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line">Woman m = (Woman)p1; </span><br><span class="line"><span class="comment">//p1变量中实际存储的对象就是Woman类型，和强转的Woman类型一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向上转型</span></span><br><span class="line">Person p2 = <span class="keyword">new</span> ChineseWoman();</span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line">Woman w2 = (Woman) p2; </span><br><span class="line"><span class="comment">//p2变量中实际存储的对象是ChineseWoman类型，强制的类型是Woman，ChineseWoman&lt;Woman类型     </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、instanceof</p><p>表达式语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象/变量  <span class="keyword">instanceof</span>  类型</span><br></pre></td></tr></table></figure><p>运算结果：true 或 false</p><p>作用：</p><p>用来判断这个对象是否属于这个类型，或者说，是否是这个类型的对象或这个类型子类的对象</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChineseWoman</span> <span class="keyword">extends</span> <span class="title">Woman</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Woman w = <span class="keyword">new</span> Woman();</span><br><span class="line">        ChineseWoman c = <span class="keyword">new</span> ChineseWoman();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p <span class="keyword">instanceof</span> Woman)&#123;<span class="comment">//false</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(w <span class="keyword">instanceof</span> Woman)&#123;<span class="comment">//true</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c <span class="keyword">instanceof</span> Woman)&#123;<span class="comment">//true</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象基础</title>
      <link href="/2020/05/31/java-oop1/"/>
      <url>/2020/05/31/java-oop1/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象编程思想"><a href="#面向对象编程思想" class="headerlink" title="面向对象编程思想"></a>面向对象编程思想</h1><p>常见的编程思想有：</p><p><strong>面向过程（POP）编程思想</strong></p><p>面向过程POP（Process-Oriented Programming）强调的是系统的数据被加工处理的过程，数据仅仅作为输入和输出存在，在程序设计中主要以函数或者过程为程序的基本组织方式。</p><p>比如说，C语言中，数据与处理这些数据的函数是分离的，程序的最小单元是函数。</p><p><strong>面向对象（OOP）编程思想</strong></p><p>前辈们说，这样不好，应该把数据和与这些数据相关的行为放在一起，用一个叫做类的东西装起来。于是，在Java中，程序的最小单元变成了类。——这种思想叫做面向对象编程。</p><p>面向对象（Object Oriented Programming）是以<strong>对象</strong>为中心，将对象的内部组织与外部环境区别开来，将表征对象的内部属性数据与外部隔离开来，其行为与属性构成了一个整体，而系统功能则表现为一系列对象之间的相互作用的序列，能更加形象的模拟或表达现实世界。</p><p>当然，会使用Java语言并不代表已经领会了面向对象的思想。面向对象有三大特性：封装、继承、多态。封装有什么作用？封装时要注意什么？继承有什么优点和缺点？什么时候使用继承？多态有什么好处？什么时候使用多态？……这些问题的解答有一些指导原则，比如单一职责原则、里氏替换原则、开闭原则、接口隔离原则、依赖倒置原则等等。这些原则就是编程思想。</p><p>举个例子来说，你写了一个程序，现在用的是SQLServer的数据库，但客户说，将来也可能换成MySQL、Oracle数据库。那你可能就会考虑了：如何在现有的基础上，做最少的改动，就能从SQLServer换到MySQL、Oracle。于是，你就会开始想这些问题：如何能达到更少的变动？是否需要创建接口？在什么地方创建接口？接口中定义哪些方法？如何让调用者更方便地获取接口的实现类的对象？……这个，就是你的编程思想。就是那些原则在你的实践中的应用。</p><p>面向过程：POP: Process-Oriented Programming</p><p>​    以函数（方法）为最小单位</p><p>​    以过程，步骤为主，考虑怎么做</p><p>​    </p><p>面向对象：OOP: Object Oriented Programming</p><p>​    以类/对象为最小单位，类包括：数据+方法</p><p>​    以对象（谁）为主，考虑谁来做，谁能做</p><p>面向对象仍然包含面向过程，只不过关注点变了，关注谁来做</p><p>​    </p><p>程序员的角色：</p><p>面向过程：程序员是具体执行者</p><p>面向对象：程序员是指挥者</p><p>面向对象的开发过程：其实就是不断创造对象，使用对象，指挥对象做事情</p><p>面向对象的设计过程：就是管理和维护对象之间的关系</p><h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><p>类与对象是面向对象的核心概念：</p><p>类(class)：对现实生活中一类事物的描述，抽象的，也可以说类是对象的设计模板。</p><p>对象(object)：是实际存在的该类事物的每个个体，因而也称实例(instance)，是一个实实在在的个体，具体的</p><p>比如：</p><p>​    宝马、奥迪、奔驰、特斯拉、比亚迪…这些就可以抽取一个<code>车</code>的类。</p><p>​    颜色、轴长、价格…这些就是<code>车</code>类的属性。</p><p>​    驾驶、拉人、撩妹…这些就是<code>车</code>类的行为(方法)。</p><h2 id="如何声明类"><a href="#如何声明类" class="headerlink" title="如何声明类"></a>如何声明类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    成员列表：属性、方法、构造器、代码块、内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名();  <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名(); <span class="comment">//有名对象</span></span><br></pre></td></tr></table></figure><h1 id="类的成员之一：属性"><a href="#类的成员之一：属性" class="headerlink" title="类的成员之一：属性"></a>类的成员之一：属性</h1><h2 id="如何声明属性"><a href="#如何声明属性" class="headerlink" title="如何声明属性"></a>如何声明属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 数据类型  属性名;    <span class="comment">//属性有默认值</span></span><br><span class="line">    【修饰符】 数据类型  属性名 = 值; <span class="comment">//属性有初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">car</span> </span>&#123;</span><br><span class="line">String color;</span><br><span class="line">  <span class="keyword">double</span> price;</span><br><span class="line">  <span class="keyword">double</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：属性的类型可以是Java的任意类型，包括基本数据类型、引用数据类型（类、接口、数组等）</p></blockquote><p><strong>总结：</strong></p><p>Java的数据类型</p><p>（1）基本数据类型</p><p>​        byte,short,int,long,float,double,char,boolean</p><p>（2）引用数据类型</p><p>​        ①类：</p><p>​            例如：String、Student、Circle、System、Scanner、Math…</p><p>​        ②接口：</p><p>​        ③数组：</p><p>​            例如：int[]，String[]，char[]，int[][]</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">这里把<span class="keyword">int</span>[]看成数组类型，是一种引用数据类型，右边赋值的是一个数组的对象</span><br><span class="line"></span><br><span class="line">元素的数据类型：<span class="keyword">int</span></span><br><span class="line">数组的数据类型：<span class="keyword">int</span>[]</span><br></pre></td></tr></table></figure><h2 id="如何为属性赋值"><a href="#如何为属性赋值" class="headerlink" title="如何为属性赋值"></a>如何为属性赋值</h2><ul><li>在声明属性时显式赋值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 数据类型  属性名 = 值; <span class="comment">//属性有初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">char</span> gender = <span class="string">'男'</span>;<span class="comment">//显式赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStudent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s1.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s1.gender);<span class="comment">//男</span></span><br><span class="line">        </span><br><span class="line">        s1.name = <span class="string">"小薇"</span>;<span class="comment">//修改属性的默认值</span></span><br><span class="line">        s1.gender = <span class="string">'女'</span>;<span class="comment">//修改属性的初始值</span></span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s1.name);<span class="comment">//小薇</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s1.gender);<span class="comment">//女</span></span><br><span class="line">        </span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s2.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s2.gender);<span class="comment">//男</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建对象之后赋值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 数据类型  属性名; <span class="comment">//属性有默认值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span>  类名();</span><br><span class="line"></span><br><span class="line"><span class="comment">//为对象的属性赋值</span></span><br><span class="line">对象名.属性名 = 值;</span><br></pre></td></tr></table></figure><p><strong>如何访问属性的值</strong></p><ul><li>在本类的方法中访问</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;<span class="comment">//直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在其他类的方法中访问</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCircle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Circle c1 = <span class="keyword">new</span> Circle();</span><br><span class="line">        <span class="keyword">double</span> area = <span class="number">3.14</span> * c1.radius * c1.radius;<span class="comment">//对象名.属性名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性的特点"><a href="#属性的特点" class="headerlink" title="属性的特点"></a>属性的特点</h2><ul><li><p>属性有默认值</p><p>基本数据类型：</p><p>​    byte,short,int,long：0</p><p>​    float，double：0.0</p><p>​    char：\u0000</p><p>​    boolean：false</p><p>引用数据类型：</p><p>​    null</p></li><li><p>每一个对象的属性是独立，互不干扰</p></li></ul><h2 id="对象属性的内存图"><a href="#对象属性的内存图" class="headerlink" title="对象属性的内存图"></a>对象属性的内存图</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">char</span> gender = <span class="string">'男'</span>;<span class="comment">//显式赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStudent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s1.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s1.gender);<span class="comment">//男</span></span><br><span class="line">        </span><br><span class="line">        s1.name = <span class="string">"小薇"</span>;</span><br><span class="line">        s1.gender = <span class="string">'女'</span>;</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s1.name);<span class="comment">//小薇</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s1.gender);<span class="comment">//女</span></span><br><span class="line">        </span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s2.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s2.gender);<span class="comment">//男</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/object.png" alt="object"></p><h1 id="类的成员之二：方法"><a href="#类的成员之二：方法" class="headerlink" title="类的成员之二：方法"></a>类的成员之二：方法</h1><h2 id="方法的概念"><a href="#方法的概念" class="headerlink" title="方法的概念"></a>方法的概念</h2><p>方法也叫函数，是一个独立功能的定义，是一个类中最基本的功能单元。</p><p>把一个功能封装为方法的目的是，可以实现代码重用，从而简化代码。</p><p>方法的使用原则：</p><p>（1）必须先声明后使用</p><p>​        类，变量，方法都要先声明后使用</p><p>（2）不调用不执行，调用一次执行一次。</p><h2 id="方法的语法"><a href="#方法的语法" class="headerlink" title="方法的语法"></a>方法的语法</h2><p><strong>方法的声明格式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 返回值类型  方法名(【形参列表】)&#123;</span><br><span class="line">        方法体：实现功能的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>（1）【修饰符】：</p><p>（2）返回值类型：</p><p>​        ①void：表示无返回值</p><p>​        ②非void：所有的Java数据类型都可以</p><p>（3）方法名：能很好的体现方法的功能</p><p>​        命名的规范：①见名知意②从第二个单词开始首字母大写</p><p>（4）【形参列表】：</p><p>​        在完成这个方法的功能时，需要一些数据，这些数据要由“调用者”来决定，那我们就可以设计形参。</p><p>​        语法格式：</p><p>​            ()：无参，空参</p><p>​            (数据类型  形参名)：一个形参</p><p>​            (数据类型1  形参名1,  ……,   数据类型n  形参名n)：n个形参</p><p>（5）方法体：实现方法的功能，最好一个方法就完成一个独立的功能。</p><p><strong>方法的调用格式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本类同级别方法调用：直接调用</span></span><br><span class="line">方法名(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在其他类的方法中调用</span></span><br><span class="line">对象名.方法名(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">如果方法有返回值，需要用变量接收</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>（1）是否传实参</p><p>​        看被调用的方法是否有形参</p><p>（2）是否接收返回值</p><p>​        看被调用的方法是否是void，如果是void，就不需要也不能接收，如果不是void，就可以接收。</p><p><strong>方法的声明与调用的代码示例</strong></p><ul><li>无参无返回值方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"半径："</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printInfo();<span class="comment">//本类中调用无参无返回值方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"半径："</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCircle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Circle c1 = <span class="keyword">new</span> Circle();</span><br><span class="line">        c1.printInfo(); <span class="comment">//其他类中调用无参无返回值方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无参有返回值方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//  System.out.println("半径：" + radius + "，面积：" + getArea());//本类中调用无参有返回值</span></span><br><span class="line">       <span class="keyword">double</span> area = getArea();<span class="comment">//本类中调用无参有返回值</span></span><br><span class="line">        System.out.println(<span class="string">"半径："</span> + radius + <span class="string">"，面积："</span> + area);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCircle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Circle c1 = <span class="keyword">new</span> Circle();</span><br><span class="line">        <span class="keyword">double</span> area = c1.getArea();</span><br><span class="line">        System.out.println(<span class="string">"面积："</span> + area);</span><br><span class="line">        <span class="comment">//或</span></span><br><span class="line">        System.out.println(<span class="string">"面积："</span> + c1.getArea());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有参无返回值方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicTools</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printRectange</span><span class="params">(<span class="keyword">int</span> line, <span class="keyword">int</span> column, <span class="keyword">char</span> sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=line; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=column; j++)&#123;</span><br><span class="line">                Sytem.out.print(sign);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printRectange(<span class="number">5</span>,<span class="number">10</span>,<span class="string">'%'</span>);<span class="comment">//本类中调用有参无返回值方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicTools</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printRectange</span><span class="params">(<span class="keyword">int</span> line, <span class="keyword">int</span> column, <span class="keyword">char</span> sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=line; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=column; j++)&#123;</span><br><span class="line">                Sytem.out.print(sign);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GraphicTools tools = <span class="keyword">new</span> GraphicTools();</span><br><span class="line">        tools.printRectange(<span class="number">5</span>,<span class="number">10</span>,<span class="string">'%'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有参有返回值方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">7</span>;</span><br><span class="line">        System.out.println(x + <span class="string">"+"</span> + y + <span class="string">"="</span> + sum(x,y));<span class="comment">//本类中调用有参有返回值的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyMath my = <span class="keyword">new</span> MyMath();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(x + <span class="string">"+"</span> + y + <span class="string">"="</span> + my.sum(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法声明与调用的原则</strong></p><p>（1）方法必须先声明后调用</p><blockquote><p>如果调用方法时，如果方法名写错或调用一个不存在的方法，编译会报错</p></blockquote><p>（2）方法声明的位置必须在类中方法外</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        方法<span class="number">2</span>()&#123;  <span class="comment">//错误</span></span><br><span class="line">        </span><br><span class="line">   &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    方法<span class="number">2</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）方法的调用的位置有要求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    调用方法  <span class="comment">//错误位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        调用方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）方法的调用格式要与方法的声明格式对应</p><p>​        ①是否要加“对象.”：看是否在本类中，还是其他类中</p><p>​        ②是否要接收返回值：看被调用方法是否是void</p><p>​        ③是否要传实参：看被调用方法是有形参列表</p><h2 id="方法的重载Overload"><a href="#方法的重载Overload" class="headerlink" title="方法的重载Overload"></a>方法的重载Overload</h2><blockquote><p>在同一个类中，出现了两个或多个的方法，它们的方法名称相同，形参列表不同，这样的形式称为方法的重载。和返回值类型无关。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求两个整数的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求三个整数的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(max(a,b),c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求两个小数的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法的参数传递机制"><a href="#方法的参数传递机制" class="headerlink" title="方法的参数传递机制"></a>方法的参数传递机制</h2><p>Java中方法的参数传递机制：值传递</p><p>（1）形参是基本数据类型时，实参给形参传递数据值，是copy的形式，形参对值的修改不影响实参。<br>（2）形参是引用数据类型时，实参给形参传递地址值，形参对对象的属性的修改，会影响实参对象的属性值，因为此时形参和实参就是指向同一个对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[] args)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">        swap(x,y);<span class="comment">//调用完之后，x与y的值不变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(MyData my)</span></span>&#123;</span><br><span class="line">        my.num *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyData m = <span class="keyword">new</span> MyData();</span><br><span class="line">        m.num = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        change(m);<span class="comment">//调用完之后，m对象的num属性值就变为2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p><strong>可变参数</strong></p><p>形参列表中出现了<code>数据类型... 形参名</code>形式的形参，就是可变参数</p><p><strong>包含可变参数的方法的调用原则</strong></p><p>可变参数的形参部分，可以传入0～n个对应类型的实参，也可以传入对应类型的数组对象</p><p><strong>可变参数的声明原则</strong></p><ul><li>一个方法只能包含一个可变参数</li><li>可变参数必须是形参列表的最后一个</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数传入个数0～n个</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VarParam</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 调用方式一创建数组传入</span></span><br><span class="line">    <span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    System.out.println(<span class="string">"0个元素的累加和："</span> + sum(arr1));<span class="comment">//0</span></span><br><span class="line">    <span class="keyword">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">"5个元素的累加和："</span> + sum(arr2));<span class="comment">//15</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用方式二传入不同个数的参数</span></span><br><span class="line">    System.out.println(<span class="string">"0个元素的累加和："</span> + sum());<span class="comment">//0</span></span><br><span class="line">    System.out.println(<span class="string">"1个元素的累加和："</span> + sum(<span class="number">3</span>));<span class="comment">//3</span></span><br><span class="line">    System.out.println(<span class="string">"0个元素的累加和："</span> + sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));<span class="comment">//15</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 可变参数nums当成数组用</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">      sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非可变参数"><a href="#非可变参数" class="headerlink" title="非可变参数"></a>非可变参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数传入个数1～n个</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VarParam</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"1个元素的累加和："</span> + max(<span class="number">5</span>));<span class="comment">//5</span></span><br><span class="line">    System.out.println(<span class="string">"5个元素的累加和："</span> + max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>));<span class="comment">//8</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//求1～n个整数参数的最大值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span>... nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">// sum1就是非可变参数，至少传入一个参数</span></span><br><span class="line">    <span class="keyword">int</span> max = num1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(max &gt; num[i])&#123;</span><br><span class="line">        max = num[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h1><blockquote><p>元素类型是引用数据类型的数组称为对象数组。因为元素中存储的是对象。</p></blockquote><p>一维数组：</p><p>1、元素是基本数据类型</p><p>2、元素是引用数据类型，也称为对象数组，即数组的元素是对象</p><blockquote><p>注意：对象数组，首先要创建数组对象本身，即确定数组的长度，然后再创建每一个元素对象，如果不创建，数组的元素的默认值就是null，所以很容易出现空指针异常NullPointerException。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> year;</span><br><span class="line"><span class="keyword">int</span> month;</span><br><span class="line"><span class="keyword">int</span> day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyDate[] arr = <span class="keyword">new</span> MyDate[<span class="number">3</span>];<span class="comment">//创建数组对象本身，指定数组的长度</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> MyDate();<span class="comment">//每一个元素要创建对象</span></span><br><span class="line">            arr[i].year = <span class="number">1990</span> + i;</span><br><span class="line">            arr[i].month = <span class="number">1</span> + i;</span><br><span class="line">            arr[i].day = <span class="number">1</span> + i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象数组的内存图"><a href="#对象数组的内存图" class="headerlink" title="对象数组的内存图"></a>对象数组的内存图</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.delivr.net/gh/uncle-he/blog-resource/img/object-array.png" alt="objectArray"></p>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2020/05/31/java-array/"/>
      <url>/2020/05/31/java-array/</url>
      
        <content type="html"><![CDATA[<h1 id="数组的相关概念"><a href="#数组的相关概念" class="headerlink" title="数组的相关概念"></a>数组的相关概念</h1><h2 id="数组的相关概念-1"><a href="#数组的相关概念-1" class="headerlink" title="数组的相关概念"></a>数组的相关概念</h2><blockquote><p> 所谓<code>数组(Array)</code>，就是相同数据类型的元素按一定顺序排列的集合，就是把有限个类型相同的变量用一个名字命名，以便统一管理他们，然后用编号区分他们，这个名字称为<code>数组名</code>，编号称为<code>下标或索引(index)</code>。组成数组的各个变量称为数组的<code>元素(element)</code>。数组中元素的个数称为<code>数组的长度(length)</code>。</p></blockquote><p>例如：</p><p>​    int s1_score = 80; </p><p>​    int s2_score = 90; </p><p>​    int s3_score = 87; </p><p>​    …..</p><p>​    int[] scores = {80, 90, 87, 68, 99, 100, 79, 96};  </p><p>​    元素1：scores[0]=80; </p><p>​    数组的长度为8</p><h2 id="数组的特点"><a href="#数组的特点" class="headerlink" title="数组的特点"></a>数组的特点</h2><ul><li><p>数组的长度一旦确定就不能修改</p></li><li><p>创建数组对象会在内存中开辟一整块连续的空间。而数组名中引用的是这块连续空间的首地址。</p></li><li><p>遍历数组和获取某个元素的速度快，因为可以通过数组名+下标，直接定位到任意一个元素。</p></li></ul><h2 id="数组类型与数组元素的类型"><a href="#数组类型与数组元素的类型" class="headerlink" title="数组类型与数组元素的类型"></a>数组类型与数组元素的类型</h2><p>数组中的元素可以是任何数据类型，包括基本类型和引用类型</p><p>数组属引用类型，把数组看成对象(object)，数组中的每个元素相当于该对象的成员变量。</p><p>例如：</p><p>（1）基本数据类型元素的数组</p><p>​        int[] scores = {80, 90, 87, 68, 99, 100, 79, 96};</p><p>​        scores数组的类型是：int[]，元素的类型是int</p><p>​        scores是一个对象，scores[0],scores[1]等元素是scores对象的成员变量</p><p>（2）引用数据类型元素的数组</p><p>​        String[] strings = {“hello”,”java”,”world”,”array”};</p><p>​        strings数组的类型是：String[]，元素的类型是String</p><p>​        strings是一个对象，strings[0]，strings[1]等元素是strings对象的成员变量</p><h2 id="数组的分类"><a href="#数组的分类" class="headerlink" title="数组的分类"></a>数组的分类</h2><p>数组按照维度分为：一维数组、二维数组、多维数组</p><p>数组按照元素的数据类型分：基本数据类型元素的数据，引用数据类型元素的数组（也称为对象数组）</p><h1 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h1><h2 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h2><p>元素数据类型[] 数组名 = new 元素数据类型[]{元素1的值，元素2的值，….};</p><p>说明：</p><p>（1）静态初始化时数组的长度由{}中罗列的元素的个数决定</p><p>（2）静态初始化时[]中不可以再写长度</p><p>（3）如果声明与初始化一起，可以简写：</p><p>元素数据类型[] 数组名 = {元素1的值，元素2的值，….};</p><p>例如：</p><p>​    int[] arr = {1, 2, 3, 4, 5, 6};</p><p>​    String[] arr = {“hello”, ”java”, ”world”};</p><h2 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h2><p>元素数据类型 数组名 = new 元素数据类型[数组的长度];</p><p>说明：</p><p>（1）动态初始化时数组的长度在[]中指定，而且必须指定</p><p>（2）动态初始化时每一个元素有默认值</p><p>注意：</p><p>（1）无论是静态初始化还是动态初始化必须确定数组长度。</p><p>动态初始化在创建数组对象时，显式指明长度，静态初始化，由列出的元素个数确定数组的长度</p><p>（2）数组的长度一旦确定，不可改变</p><p>（3）只指定数组长度，没有为元素手动赋值，那么元素有默认值</p><ul><li><p>基本数据类型</p><p>byte,short,int,long：0</p><p>float,double：0.0</p><p>char：\u0000</p><p>boolean：false</p></li><li><p>引用数据类型</p><p>统统都是null</p></li></ul><p>（4）元素的数据类型是引用数据类型，在刚刚动态初始化后，元素的值是null，并没有创建元素的对象，元素的对象需要单独创建。</p><p>例如：</p><p>Student[] arr = new Student[3];</p><p>此时arr[i]为null，arr[i]并没有指向任何学生对象，此时arr[i].属性或arr[i].方法都会报空指针异常</p><p>String[] arr = new String[3];</p><p>此时arr[i]也为null，arr[i]中并没有存储任何字符串对象</p><h2 id="元素的访问与赋值"><a href="#元素的访问与赋值" class="headerlink" title="元素的访问与赋值"></a>元素的访问与赋值</h2><p>数组的元素表示方式：数组名[下标]</p><p>下标的范围是：[0,数组的长度)  或[0,数组的长度-1]</p><p>数组元素的赋值：数组名[下标] = 值;</p><p>例如：</p><p>nums[0] = 15;</p><p>students[1] = new Student(“大美女”);</p><h2 id="数组的长度"><a href="#数组的长度" class="headerlink" title="数组的长度"></a>数组的长度</h2><p>数组名.length</p><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><h3 id="普通for循环遍历"><a href="#普通for循环遍历" class="headerlink" title="普通for循环遍历"></a>普通for循环遍历</h3><p>for(int i = 0;  i&lt;数组名.length; i++) {</p><p>​    System.out.println(数组名[i]);</p><p>}</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增强for循环遍历"><a href="#增强for循环遍历" class="headerlink" title="增强for循环遍历"></a>增强for循环遍历</h3><p>for(元素的数据类型  变量名 : 被遍历的数组名) {</p><p>​    System.out.println(变量名);  //每循环一次，变量名代表一个元素</p><p>}</p><p>区别：</p><ul><li><p>普通for可以修改数组元素的值，增强for不行；</p></li><li><p>普通for可以获取下标信息，增强for没有下标信息；</p></li><li><p>仅遍历时增强for效率高</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">"孙悟空"</span>, <span class="string">"唐僧"</span> , <span class="string">"猪八戒"</span>, <span class="string">"沙悟净"</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String name : names) &#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的内存分析"><a href="#数组的内存分析" class="headerlink" title="数组的内存分析"></a>数组的内存分析</h2><p>数组对象是在堆中创建的，元素相当于数组对象的成员变量。创建数组对象会在堆中开辟连续的空间</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/array1.png" alt="array"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/array2.png" alt="array"></p><h1 id="数组的相关算法"><a href="#数组的相关算法" class="headerlink" title="数组的相关算法"></a>数组的相关算法</h1><h2 id="数组中找最值"><a href="#数组中找最值" class="headerlink" title="数组中找最值"></a>数组中找最值</h2><h3 id="数组中找最大-小值"><a href="#数组中找最大-小值" class="headerlink" title="数组中找最大/小值"></a>数组中找最大/小值</h3><p>思路：</p><p>（1）先假设第一个元素最大/最小</p><p>（2）然后用max/min与后面的元素一一比较</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//找最大值</span></span><br><span class="line"><span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">        max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组中找最值及其下表"><a href="#数组中找最值及其下表" class="headerlink" title="数组中找最值及其下表"></a>数组中找最值及其下表</h3><p>思路：</p><p>（1）先假设第一个元素最大/最小</p><p>（2）然后用max/min与后面的元素一一比较</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//找最大值</span></span><br><span class="line"><span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">        max = arr[i];</span><br><span class="line">        index = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//找最大值</span></span><br><span class="line"><span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; arr[maxIndex])&#123;</span><br><span class="line">        maxIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"最大值："</span> + arr[maxIndex]);</span><br></pre></td></tr></table></figure><h2 id="数组统计：求总和、均值、统计偶数个数等"><a href="#数组统计：求总和、均值、统计偶数个数等" class="headerlink" title="数组统计：求总和、均值、统计偶数个数等"></a>数组统计：求总和、均值、统计偶数个数等</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//求总和、均值</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//因为0加上任何数都不影响结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    sum += arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> avg = (<span class="keyword">double</span>)sum/arr.length;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求总乘积</span></span><br><span class="line"><span class="keyword">long</span> result = <span class="number">1</span>;<span class="comment">//因为1乘以任何数都不影响结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    result *= arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//统计偶数个数</span></span><br><span class="line"><span class="keyword">int</span> even = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        even++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h2><ul><li>借助一个新数组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)先创建一个新数组</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)复制元素</span></span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newArr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[len -<span class="number">1</span> - i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)舍弃旧的，让arr指向新数组</span></span><br><span class="line">arr = newArr;<span class="comment">//这里把新数组的首地址赋值给了arr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首尾对应位置交换</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)计算要交换的次数：  次数 = arr.length/2</span></span><br><span class="line"><span class="comment">//(2)首尾交换</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length/<span class="number">2</span>; i++)&#123;<span class="comment">//循环的次数就是交换的次数</span></span><br><span class="line">    <span class="comment">//首  与  尾交换</span></span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[arr.length-<span class="number">1</span>-i];</span><br><span class="line">arr[arr.length-<span class="number">1</span>-i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p><strong>应用场景：</strong></p><ul><li>扩容</li><li>备份</li><li>截取</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要把arr数组扩容，增加1个位置</span></span><br><span class="line"><span class="comment">//(1)先创建一个新数组，它的长度 = 旧数组的长度+1</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)复制元素</span></span><br><span class="line"><span class="comment">//注意：i&lt;arr.length   因位arr比newArr短，避免下标越界</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)把新元素添加到newArr的最后</span></span><br><span class="line">newArr[newArr.length-<span class="number">1</span>] = 新值;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)如果下面继续使用arr，可以让arr指向新数组</span></span><br><span class="line">arr = newArr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 备份</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建一个长度和原来的数组一样的新数组</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、复制元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 截取</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> end = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建一个新数组，新数组的长度 = end-start + 1;</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[end-start+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、赋值元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newArr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[start + i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newArr.length; i++)&#123;</span><br><span class="line">    System.out.println(newArr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul><li>顺序查找</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] == value)&#123;</span><br><span class="line">        index = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(value + <span class="string">"不存在"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(value + <span class="string">"的下标是"</span> + index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>二分查找</p><p>对数组有要求，元素必须有大小顺序</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用二分查找法在数组中查找 int value = 2;是否存在，如果存在显示下标，不存在显示不存在。</span></span><br><span class="line"><span class="comment">已知数组：int[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam2</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;<span class="comment">//数组是有序的</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="comment">//找到结束</span></span><br><span class="line">            <span class="keyword">if</span>(value == arr[mid])&#123;</span><br><span class="line">                index = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//没找到</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; arr[mid])&#123;<span class="comment">//往右继续查找</span></span><br><span class="line">                <span class="comment">//移动左边界，使得mid往右移动</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value &lt; arr[mid])&#123;<span class="comment">//往左边继续查找</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(value + <span class="string">"不存在"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(value + <span class="string">"的下标是"</span> + index);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li>冒泡排序</li><li>简单的直接排序</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;<span class="comment">//外循环的次数 = 轮数 = 数组的长度-1</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第1轮，i=1,从左到右两两比较，arr[0]与arr[1]。。。。。arr[3]与arr[4]</span></span><br><span class="line"><span class="comment">    第2轮，i=2,从左到右两两比较，arr[0]与arr[1]。。。。。arr[2]与arr[3]</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    arr[j]与arr[j+1]比较</span></span><br><span class="line"><span class="comment">    找两个关键点：（1）j的起始值：0（2）找j的终止值，依次是3,2,1,0，得出j&lt;arr.length-i</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arr.length-i; j++)&#123;</span><br><span class="line">        <span class="comment">//两两比较</span></span><br><span class="line">        <span class="comment">//从小到大，说明前面的比后面的大，就交换</span></span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单的直接排序</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;<span class="comment">//外循环的次数 = 轮数 = 数组的长度-1</span></span><br><span class="line">    <span class="comment">//（1）找出本轮未排序元素中的最值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    未排序元素：</span></span><br><span class="line"><span class="comment">    第1轮：i=1,未排序，[0,4]</span></span><br><span class="line"><span class="comment">    第2轮：i=2,未排序，[1,4]</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    每一轮未排序元素的起始下标：0,1,2,3，正好是i-1的</span></span><br><span class="line"><span class="comment">    未排序的后面的元素依次：</span></span><br><span class="line"><span class="comment">    第1轮：[1,4]  j=1,2,3,4</span></span><br><span class="line"><span class="comment">    第2轮：[2,4]  j=2,3,4</span></span><br><span class="line"><span class="comment">    第3轮：[3,4]  j=3,4</span></span><br><span class="line"><span class="comment">    第4轮：[4,4]  j=4</span></span><br><span class="line"><span class="comment">    j的起点是i，终点都是4</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> max = arr[i-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> index = i-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;arr.length; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; max)&#123;</span><br><span class="line">            max = arr[j];</span><br><span class="line">            index = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（2）如果这个最值没有在它应该在的位置，就与这个位置的元素交换</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第1轮，最大值应该在[0]</span></span><br><span class="line"><span class="comment">    第2轮，最大值应该在[1]</span></span><br><span class="line"><span class="comment">    第3轮，最大值应该在[2]</span></span><br><span class="line"><span class="comment">    第4轮，最大值应该在[3]</span></span><br><span class="line"><span class="comment">    正好是i-1的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(index != i-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//交换arr[i-1]与arr[index]</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i-<span class="number">1</span>];</span><br><span class="line">        arr[i-<span class="number">1</span>] = arr[index];</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">System.out.print(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><p>二维数组的标记：[][]</p><h2 id="相关的表示方式"><a href="#相关的表示方式" class="headerlink" title="相关的表示方式"></a>相关的表示方式</h2><p>（1）二维数组的长度/行数： </p><p>​    二维数组名.length</p><p>（2）二维数组的其中一行：</p><p>​    二维数组名[行下标]</p><p>​    行下标的范围：[0, 二维数组名.length-1]</p><p>（3）每一行的列数：</p><p>​    二维数组名[行下标].length</p><p>​       因为二维数组的每一行是一个一维数组</p><p>（4）每一个元素</p><p>​    二维数组名[行下标][列下标]</p><h2 id="二维数组的声明和初始化"><a href="#二维数组的声明和初始化" class="headerlink" title="二维数组的声明和初始化"></a>二维数组的声明和初始化</h2><p>二维数组的声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐</span></span><br><span class="line">元素的数据类型[][] 二维数组的名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐</span></span><br><span class="line">元素的数据类型  二维数组名[][];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//不推荐</span></span><br><span class="line">元素的数据类型[]  二维数组名[];</span><br></pre></td></tr></table></figure><p>面试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] x, y[];</span><br><span class="line"><span class="comment">//x是一维数组，y是二维数组</span></span><br></pre></td></tr></table></figure><p>二维数组的初始化</p><p>（1）静态初始化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">二维数组名 = <span class="keyword">new</span> 元素的数据类型[][]&#123;</span><br><span class="line">&#123;第一行的值列表&#125;, </span><br><span class="line">&#123;第二行的值列表&#125;,</span><br><span class="line">...</span><br><span class="line">&#123;第n行的值列表&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] arr;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果声明与静态初始化一起完成</span></span><br><span class="line">元素的数据类型[][] 二维数组的名称 = &#123;</span><br><span class="line">&#123;第一行的值列表&#125;, </span><br><span class="line">&#123;第二行的值列表&#125;,</span><br><span class="line">...</span><br><span class="line">&#123;第n行的值列表&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>（2）动态初始化（不规则：每一行的列数可能不一样）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//（1）先确定总行数</span></span><br><span class="line">二维数组名 = <span class="keyword">new</span> 元素的数据类型[总行数][];</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）再确定每一行的列数</span></span><br><span class="line">二维数组名[行下标] = <span class="keyword">new</span> 元素的数据类型[该行的总列数];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)再为元素赋值</span></span><br><span class="line">二维数组名[行下标][列下标] = 值;</span><br></pre></td></tr></table></figure><p>（3）动态初始化（规则：每一行的列数是相同的）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//（1）确定行数和列数</span></span><br><span class="line">二维数组名 = <span class="keyword">new</span> 元素的数据类型[总行数][每一行的列数];</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）再为元素赋值</span></span><br><span class="line">二维数组名[行下标][列下标] = 值;</span><br></pre></td></tr></table></figure><h2 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;二维数组名.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;二维数组名[i].length; j++)&#123;</span><br><span class="line">        System.out.print(二维数组名[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">    System.out.print(arr[i][j]);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维数组的内存分析"><a href="#二维数组的内存分析" class="headerlink" title="二维数组的内存分析"></a>二维数组的内存分析</h2><p>（1）int[][] arr;</p><p>（2）arr = new int[5];</p><p>（3）arr[0] = new int[4];</p><p>（4）arr[0][1]= 12;</p><p>（5）int[][] arr = new int[4][5];</p><p>（6）Student[][]  arr = new Student[6][];</p><p>（7）arr[0] = new Student[8];</p><p>（8）arr[0][1] = new Student(“张三”,”10086”);</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/2array1.png" alt="array"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/2array2.png" alt="array"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/2array3.png" alt="array"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/2array4.png" alt="array"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/2array5.png" alt="array"></p>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
