<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>枚举与注解</title>
      <link href="/2020/06/12/java-exception/"/>
      <url>/2020/06/12/java-exception/</url>
      
        <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常的类型的体系结构"><a href="#异常的类型的体系结构" class="headerlink" title="异常的类型的体系结构"></a>异常的类型的体系结构</h2><p>1、异常系列的超父类：java.lang.Throwable</p><p>（1）只有它或它子类的对象，才能被JVM或throw语句“抛”出</p><p>（2）也只有它或它子类的对象，才能被catch“捕获”</p><p>2、Throwable分为两大派别</p><p>（1）Error：严重的错误，需要停下来重新设计、升级解决这个问题</p><p>（2）Exception： 一般的异常，可以通过判断、检验进行避免，或者使用try…catch进行处理</p><p>3、Exception又分为两大类</p><p>（1）运行时异常：</p><p>​    它是RuntimeException或它子类的对象。</p><p>​    这种类型的异常，编译器不会提醒你，要进行throws或try…catch进行处理，但是运行时可能导致崩溃。</p><p>（2）编译时异常：</p><p>​    异常除了运行时异常以外的都是编译时异常。</p><p>​    这种类型的异常，编译器是强制要求你，throws或try…catch进行处理，否则编译不通过。</p><p>4、列出常见的异常类型</p><p>（1）运行时异常</p><p>RuntimeException、NullPointerException（空指针异常），ClassCastException（类型转换异常），ArithmeticException（算术异常），NubmerFormatException（数字格式化异常），IndexOutOfBoundsException（下标越界异常）（ArrayIndexOutOfBoundsException（数组下标越界异常）、StringIndexOutOfBoundsException（字符串下标越界异常））、InputMisMatchException（输入类型不匹配异常）。。。。</p><p>（2）编译时异常</p><p>FileNotFoundException（文件找不到异常）、IOException（输入输出异常）、SQLException（数据库sql语句执行异常）。。。</p><h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><p>1、在当前方法中处理：try…catch…finally</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形式一：try...catch</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;。。。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//形式二：try...finally</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的代码</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    无论<span class="keyword">try</span>中是否有异常，也不管是不是有<span class="keyword">return</span>，都要执行的部分</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形式三：try..catch..finally</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;。。。</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    无论<span class="keyword">try</span>中是否有异常，也不管<span class="keyword">catch</span>是否可以捕获异常，也不管<span class="keyword">try</span>和<span class="keyword">catch</span>中是不是有<span class="keyword">return</span>，都要执行的部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行特点：</p><p>（1）如果try中的代码没有异常，那么try中的代码会正常执行，catch部分就不执行，finally中会执行</p><p>（2）如果try中的代码有异常，那么try中发生异常的代码的后面就不执行了，找对应的匹配的catch分支执行，finally中会执行</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/exception.png" alt="exception"></p><p>2、finally与return混合使用时</p><p>（1）如果finally中有return，一定从finally中的return返回。</p><p>此时try和catch中的return语句，执行了一半，执行了第一个动作。所以，finally中的return语句会覆盖刚刚的返回值</p><p>return 返回值; 语句有两个动作：（1）把返回值放到“操作数栈”中，等当前方法结束后，这个“操作数栈”中的值会返回给调用处（2）结束当前方法的执行</p><p>（2）如果finally中没有return，finally中的语句会执行，但是不影响最终的返回值</p><p>即try和catch中的return语句两步拆开来走，先把（1）把返回值放到“操作数栈”中，（2）然后走finally中的语句（3）再执行return后半个动作，结束当前方法</p><p>3、在当前方法中不处理异常，明确要抛给调用者处理，使用throws</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 返回值类型  方法名(【形参列表】) <span class="keyword">throws</span> 异常列表&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时调用者，就知道需要处理哪些异常。</p><p>方法的重写的要求：</p><p>（1）方法名：相同</p><p>（2）形参列表：相同</p><p>（3）返回值类型：</p><p>​    基本数据类型和void：相同</p><p>​    引用数据类型：&lt;=</p><p>（4）修饰符：</p><p>​    权限修饰符：&gt;=</p><p>​    其他修饰符：static，final，private不能被重写</p><p>（5）throws：&lt;=</p><p>方法的重载：</p><p>（1）方法名：相同</p><p>（2）形参列表：必须不同</p><p>（3）返回值类型：无关</p><p>（4）修饰符：无关</p><p>（5）throws：无关</p><h2 id="手动抛出异常：throw"><a href="#手动抛出异常：throw" class="headerlink" title="手动抛出异常：throw"></a>手动抛出异常：throw</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> 异常对象;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AccountException(<span class="string">"xxx"</span>);</span><br></pre></td></tr></table></figure><p>throw抛出来的异常对象，和JVM抛出来的异常对象一样，也要用try..catch处理或者throws。</p><p>如果是运行时异常，编译器不会强制要求你处理，如果是编译时异常，那么编译器会强制要求你处理。</p><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>1、必须继承Throwable或它的子类</p><p>我们见到比较多的是继承RuntimeException和Exception.</p><p>如果你继承RuntimeException或它的子类，那么你自定义的这个异常就是运行时异常。编译器就不会提醒你处理。</p><p>如果你继承Exception，那么它属于编译时异常，编译器会强制你处理。</p><p>2、建议大家保留两个构造器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">public</span> 自定义异常名()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line"><span class="keyword">public</span> 自定义异常名(String message)&#123;</span><br><span class="line">    <span class="keyword">super</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、自定义异常对象，必须手动抛出，用throw抛出</p><h2 id="关于异常的几个方法"><a href="#关于异常的几个方法" class="headerlink" title="关于异常的几个方法"></a>关于异常的几个方法</h2><p>（1）e.printStackTrace()：打印异常对象的详细信息，包括异常类型，message，堆栈跟踪信息。这个对于调试，或者日志跟踪是非常有用的</p><p>（2）e.getMessage()：只是获取异常的message信息</p><p>关于异常信息的打印：</p><p>用System.err打印和用e.printStackTrace()都是会标记红色的突出。</p><p>用System.out打印，当成普通信息打印。</p><p>这两个打印是两个独立的线程，顺序是不能精确控制的。</p>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 异常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>枚举与注解</title>
      <link href="/2020/06/11/java-enum/"/>
      <url>/2020/06/11/java-enum/</url>
      
        <content type="html"><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>1、枚举（JDK1.5引入的）</p><p>​    枚举类型的对象是有限、固定的几个常量对象。</p><p>​    某些类的对象只有确定的有限个时，可以把这样的类声明为枚举类。</p><p>​    例如：</p><p>​        星期：Monday(星期一)……Sunday(星期天)</p><p>​        性别：Man(男)、Woman(女)</p><p>​        月份：January(1月)……December(12月)</p><p>​        季节：Spring(春节)……Winter(冬天)</p><p>​        七彩标准色：Red(红)……Purple(紫)</p><p>​        支付方式：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银行卡)、CreditCard(信用卡)</p><p>​        就职状态：Busy、Free、Vocation、Dimission</p><p>​        订单状态：Nonpayment（未付款）、Paid（已付款）、Fulfilled（已配货）、Delivered（已发货）、Return（退货）、Checked（已确认）</p><p>2、语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形式一：枚举类型中只有常量对象列表</span></span><br><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类型名&#123;</span><br><span class="line">    常量对象列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形式二：枚举类型中只有常量对象列表</span></span><br><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类型名&#123;</span><br><span class="line">    常量对象列表;</span><br><span class="line">    </span><br><span class="line">    其他成员列表；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：常量对象列表必须在枚举类型的首行</p><ul><li><p>使用 enum 定义的枚举类，默认继承了 java.lang.Enum类。因此不能再继承其他类。</p></li><li><p>枚举类的所有构造器只能使用 private 访问控制符</p></li><li><p>枚举类的所有实例必须在枚举类的首行显式列出(, 分隔   ; 结尾)，它们实际上都是public static final修饰的常量对象。</p></li><li><p>JDK 1.5 之后可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEnumType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Season s = Season.SPRING;</span><br><span class="line"><span class="keyword">switch</span>(s)&#123;</span><br><span class="line">      <span class="keyword">case</span> SPRING:</span><br><span class="line">        System.out.println(<span class="string">"春暖花开"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> SUMMER:</span><br><span class="line">        System.out.println(<span class="string">"夏日炎炎"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AUTUMN:</span><br><span class="line">        System.out.println(<span class="string">"秋高气爽"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> WINTER:</span><br><span class="line">        System.out.println(<span class="string">"白雪皑皑"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Season&#123;</span><br><span class="line">SPRING,SUMMER,AUTUMN,WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回忆：首行</p><p>（1）super()或super(实参列表)：必须在子类构造器的首行</p><p>（2）this()或this(实参列表)：必须在本类构造器的首行</p><p>（3）package 包; 声明包的语句必须在源文件.java的代码首行</p><p>（4）枚举常量对象列表必须在枚举类型的首行</p><p>3、在其他类中如何获取枚举的常量对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取一个常量对象</span></span><br><span class="line">枚举类型名.常量对象名</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个常量对象</span></span><br><span class="line">枚举类型名.valueOf(<span class="string">"常量对象名"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取所有常量对象</span></span><br><span class="line">枚举类型名[] all = 枚举类型名.values();</span><br></pre></td></tr></table></figure><p>4、枚举类型的特点</p><p>（1）枚举类型有一个公共的基本的父类，是java.lang.Enum类型，所以不能再继承别的类型</p><p>（2）枚举类型的构造器必须是私有的</p><p>（3）枚举类型可以实现接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyRunnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Gender implements MyRunnable&#123;</span><br><span class="line">    NAN,NV;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">enum</span> Gender implements MyRunnable&#123;</span><br><span class="line">    NAN&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;,NV&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、父类java.lang.Enum类型</p><p>（1）构造器</p><p>​        protected Enum(String name, int ordinal)：由编译器自动调用</p><p>（2）String name()：常量对象名</p><p>（3）int ordinal()：返回常量对象的序号，第一个的序号是0</p><p>（4）String toString()：返回常量对象名，如果子类想重写，需要手动写</p><p>（5）int compareTo(Object obj)：按照常量对象的顺序比较</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>1、注解</p><p>​    它是代码级别的注释</p><p>2、标记符号：@</p><p>3、系统预定义的三个最基本的注解：</p><p>（1）@Override：表示某个方法是重写的方法</p><p>​        它只能用在方法上面，会让编译器对这个方法进行格式检查，是否满足重写的要求</p><p>（2）@SuppressWarnings(xx)：抑制警告</p><p>（3）@Deprecated：表示xx已过时</p><p>4、和文档注释相关的注解</p><p>（1）文档注释</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">文档注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>（2）常见的文档注释</p><p>@author：作者</p><p>@since：从xx版本加入的</p><p>@see：另请参考</p><p>@param：形参</p><p>@return：返回值</p><p>@throws或@exception：异常</p><p>5、JUnit相关的几个注解</p><p>（1）@Test：表示它是一个单元测试方法</p><p>这个方法需要是：public void xxx(){}</p><p>（2）@Before：表示在每一个单元测试方法之前执行</p><p>这个方法需要是：public void xxx(){}</p><p>（3）@After：表示在每一个单元测试方法之后执行</p><p>这个方法需要是：public void xxx(){}</p><p>（4）@BeforeClass：表示在类初始化阶段执行，而且只执行一次</p><p>这个方法需要是：public static void xxx(){}</p><p>（3）@AfterClass：表示在类的“卸载”阶段执行，而且只执行一次</p><p>这个方法需要是：public static void xxx(){}</p><p>6、元注解</p><p>（1）@Target(xx)：用它标记的注解能够用在xx位置</p><p>(xx)：由ElementType枚举类型的10个常量对象指定，例如：TYPE，METHOD，FIELD等</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;TYPE,METHOD,FIELD&#125;)</span><br></pre></td></tr></table></figure><p>（2）@Retention（xx）：用它标记的注解可以滞留到xx阶段</p><p>(xx)：由RetentionPolicy枚举类型的3个常量对象指定，分别是：SOURCE，CLASS，RUNTIME</p><p>唯有RUNTIME阶段的注解才能被反射读取到</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br></pre></td></tr></table></figure><p>（3）@Documentd：用它标记的注解可以读取到API中</p><p>（4）@Inherited：用它标记的注解可以被子类继承</p><p>7、自定义注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@元注解</span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@元注解</span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    配置参数列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置参数的语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型  配置参数名();</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">数据类型  配置参数名() <span class="keyword">default</span> 默认值;</span><br></pre></td></tr></table></figure><p>关于配置参数：</p><p>（1）配置参数的类型有要求：</p><p>八种基本数据类型、String、枚举、Class类型、注解、它们的数组。</p><p>（2）如果自定义注解声明了配置参数，那么在使用这个注解时必须为配置参数赋值，除非它有默认值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@自定义注解名(配置参数名<span class="number">1</span>=值，配置参数名<span class="number">2</span>=值。。。)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果配置参数类型是数组，那么赋值时，可以用&#123;&#125;表示数组</span></span><br><span class="line">@自定义注解名(配置参数名<span class="number">1</span>=&#123;值&#125;，配置参数名<span class="number">2</span>=值。。。)</span><br></pre></td></tr></table></figure><p>（3）如果配置参数只有一个，并且名称是value，那么赋值时可以省略value=</p><p>（4）如果读取这个注解时，要获取配置参数的值的话，可以当成方法一样来访问</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">自定义注解对象.配置参数();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 枚举与注解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 枚举与注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象的高级特征</title>
      <link href="/2020/06/03/java-oop3/"/>
      <url>/2020/06/03/java-oop3/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象的高级特性"><a href="#面向对象的高级特性" class="headerlink" title="面向对象的高级特性"></a>面向对象的高级特性</h1><h2 id="关键字：final"><a href="#关键字：final" class="headerlink" title="关键字：final"></a>关键字：final</h2><p>final：最终的</p><p>用法：</p><p>（1）修饰类（包括外部类、内部类类）</p><p>​        表示这个类不能被继承，没有子类</p><p>（2）修饰方法</p><p>​        表示这个方法不能被重写,但是任然被继承</p><p>（3）修饰变量（成员变量（类变量、实例变量），局部变量）</p><p>​        表示这个变量的值不能被修改</p><p>注意：如果某个成员变量用final修饰后，也得手动赋值，而且这个值一旦赋完，就不能修改了，即没有set方法</p><h2 id="关键字：native"><a href="#关键字：native" class="headerlink" title="关键字：native"></a>关键字：native</h2><p>native：本地的，原生的<br>用法：</p><p>​    只能修饰方法，而且看不见方法体</p><p>​    表示这个方法的方法体代码不是用Java语言实现的，而是调用了底层C/C++的代码，这些代码被编译为.dll文件，让Java来执行的</p><p>​    但是对于Java程序员来说，可以当做Java的方法一样去正常调用它，或者子类重写它。</p><p>JVM内存的管理：</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/jvm.png" alt="jvm"></p><p>方法区：类的信息、常量、静态变量、动态编译生成的字节码信息</p><p>虚拟机栈：Java语言实现的方法的局部变量</p><p>本地方法栈：非Java语言实现的方法的局部变量，即native方法执行时的内存区域</p><p>堆：new出来的对象</p><p>程序计数器：记录每一个线程目前执行到哪一句指令</p><h2 id="关键字：static"><a href="#关键字：static" class="headerlink" title="关键字：static"></a>关键字：static</h2><p>static：静态的</p><p>用法：</p><p>1、成员方法：我们一般称为静态方法或类方法</p><p>（1）不能被重写</p><p>（2）被使用</p><p>​        本类中：其他方法中可以直接使用它</p><p>​        其他类中：可以使用“类名.方法”进行调用，也可以使用”对象名.方法”，推荐使用“类名.方法”</p><p>（3）在静态方法中，我们不能出现：this，super，非静态的成员</p><p>2、成员变量：我们一般称为静态变量或类变量</p><p>（1）静态变量的值是该类所有对象共享的</p><p>（2）静态变量存储在方法区</p><p>（3）静态变量对应的get/set也是静态的</p><p>（4）静态变量与局部变量同名时，就可以使用“类名.静态变量”进行区分</p><p>3、内部类：后面讲</p><p>4、代码块：静态代码块</p><p>5、静态导入（JDK1.5引入）</p><p>没有静态导入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">1000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.unclehe.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(Utils.MAX_VALUE);</span><br><span class="line">        Utils.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用静态导入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">1000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.unclehe.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.unclehe.utils.Utils.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(MAX_VALUE);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>1、语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        静态代码块;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、作用：</p><p>协助完成类初始化，可以为类变量赋值。</p><p>3、类初始化<clinit>()</p><p>类的初始化有：</p><p>①静态变量的显式赋值代码</p><p>②静态代码块中代码</p><p>其中①和②按顺序执行</p><p>注意：类初始化方法，一个类只有一个</p><p>4、类的初始化的执行特点：</p><p>（1）每一个类的<clinit>()只执行一次</p><p>（2）如果一个子类在初始化时，发现父类也没有初始化，会先初始化父类</p><p>（3）如果既要类初始化又要实例化初始化，那么一定是先完成类初始化的</p><h2 id="变量的分类与区别"><a href="#变量的分类与区别" class="headerlink" title="变量的分类与区别"></a>变量的分类与区别</h2><p>1、变量按照数据类型分：</p><p>（1）基本数据类型的变量，里面存储数据值</p><p>（2）引用数据类型的变量，里面存储对象的地址值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//a中存储的是数据值</span></span><br><span class="line"></span><br><span class="line">Student stu = <span class="keyword">new</span> Student();<span class="comment">//stu存储的是对象的地址值</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];<span class="comment">//arr存储的是数组对象的地址值</span></span><br><span class="line">String str = <span class="string">"hello"</span>;<span class="comment">//str存储的是"hello"对象的地址值</span></span><br></pre></td></tr></table></figure><p>2、变量按照声明的位置不同：</p><p>（1）成员变量</p><p>（2）局部变量</p><p>3、成员变量与局部变量的区别</p><p>（1）声明的位置不同</p><p>成员变量：类中方法外</p><p>局部变量：（1）方法的()中，即形参（2）方法体的{}的局部变量（3）代码块{}中</p><p>（2）存储的位置不同</p><p>成员变量：</p><p>​    如果是静态变量（类变量），在方法区中</p><p>​    如果是非静态的变量（实例变量），在堆中</p><p> 局部变量：栈</p><p>（3）修饰符不同</p><p>成员变量：4种权限修饰符、static、final…</p><p>局部变量：只有final</p><p>（4）生命周期</p><p>成员变量：</p><p>​    如果是静态变量（类变量），和类相同</p><p>​    如果是非静态的变量（实例变量），和所属的对象相同，每一个对象是独立</p><p>局部变量：每次执行都是新的</p><p>（5）作用域</p><p>成员变量：</p><p>​    如果是静态变量（类变量），在本类中随便用，在其他类中使用“类名.静态变量”</p><p>​    如果是非静态的变量（实例变量），在本类中只能在非静态成员中使用，在其他类中使用“对象名.非静态的变量”</p><p>局部变量：有作用域</p><h2 id="根父类"><a href="#根父类" class="headerlink" title="根父类"></a>根父类</h2><p>1、java.lang.Object类是类层次结构的根父类。包括数组对象。</p><p>（1）Object类中声明的所有的方法都会被继承到子类中，那么即所有的对象，都拥有Object类中的方法</p><p>（2）每一个对象的创建，最终都会调用到Object实例初始化方法<init>()</p><p>（3）Object类型变量、形参、数组，可以存储任意类型的对象</p><p>2、Object类的常用方法</p><p>（1）public String toString()：</p><p>​        ①默认情况下，返回的是“对象的运行时类型 @ 对象的hashCode值的十六进制形式”</p><p>​        ②通常是建议重写，如果在eclipse中，可以用Alt +Shift + S–&gt;Generate toString()</p><p>​        ③如果我们直接System.out.println(对象)，默认会自动调用这个对象的toString()</p><p>（2）public final Class&lt;?&gt; getClass()：获取对象的运行时类型</p><p>（3）protected void finalize()：当对象被GC确定为要被回收的垃圾，在回收之前由GC帮你调用这个方法。而且这个方法只会被调用一次。子类可以选择重写。</p><p>（4）public int hashCode()：返回每个对象的hash值。</p><p>​        <strong>规定：</strong></p><p>​                ①如果两个对象的hash值是不同的，那么这两个对象一定不相等；</p><p>​                ②如果两个对象的hash值是相同的，那么这两个对象不一定相等。</p><p>​        主要用于后面当对象存储到哈希表等容中时，为了提高性能用的。</p><p>（5）public boolean equals(Object obj)：用于判断当前对象this与指定对象obj是否“相等”</p><p>​        ①默认情况下，equals方法的实现等价于<code>==</code>，比较的是对象的地址值</p><p>​        ②我们可以选择重写，重写有些要求：</p><p>​            A：如果重写equals，那么一定要一起重写hashCode()方法，因为规定：</p><p>​                a：如果两个对象调用equals返回true，那么要求这两个对象的hashCode值一定是相等的；</p><p>​                b：如果两个对象的hashCode值不同的，那么要求这个两个对象调用equals方法一定是false；</p><p>​                c：如果两个对象的hashCode值相同的，那么这个两个对象调用equals可能是true，也可能是false</p><p>​            B：如果重写equals，那么一定要遵循如下几个原则：</p><p>​                a：自反性：x.equals(x)返回true</p><p>​                b：传递性：x.equals(y)为true, y.equals(z)为true，然后x.equals(z)也应该为true</p><p>​                c：一致性：只要参与equals比较的属性值没有修改，那么无论何时调用结果应该一致</p><p>​                d：对称性：x.equals(y)与y.equals(x)结果应该一样</p><p>​                e：非空对象与null的equals一定是false</p><h2 id="关键字：abstract"><a href="#关键字：abstract" class="headerlink" title="关键字：abstract"></a>关键字：abstract</h2><p>类用于描述现实生活中一类事物。类中有属性、有方法等成员。</p><p>某种情况下，父类只能知道子类应该具备一个怎样的方法，但是不能够明确知道如何实现该方法。</p><p>只能在子类中才能确定如何去实现方法体。</p><p>例如：定义一个几何图形。所有几何图形都应该具备一个计算面积的方法。但是不同的几何图形计算面积的方式完全不同。</p><p>Java中为上述问题提供了相应的解决办法：</p><p>Java允许父类中只是提供一个方法的声明（方法的签名），但是不提供具体的实现。</p><p>具体的实现由子类来完成，该方法被称为“抽象方法”。</p><p>拥有一个或者多个抽象方法的类，被称为“抽象类”。</p><p>1、什么时候会用到抽象方法和抽象类？</p><p>当声明父类的时候，在父类中某些方法的方法体的实现不能确定，只能由子类决定。但是父类中又要体现子类的共同的特征，即它要包含这个方法，为了统一管理各种子类的对象，即为了多态的应用。</p><p>那么此时，就可以选择把这样的方法声明为抽象方法。如果一个类包含了抽象方法，那么这个类就必须是个抽象类。</p><p>2、抽象类的语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【权限修饰符】 <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">【权限修饰符】 <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、抽象方法的语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【其他修饰符】 <span class="keyword">abstract</span> 返回值类型  方法名(【形参列表】);</span><br></pre></td></tr></table></figure><p>抽象方法没有方法体</p><p>4、抽象类的特点</p><p>（1）抽象类不能直接实例化，即不能直接new对象</p><p>（2）抽象类就是用来被继承的，那么子类继承了抽象类后，必须重写所有的抽象方法，否则这个子类也得是抽象类</p><p>（3）抽象类也有构造器，这个构造的作用不是创建抽象类自己的对象用的，给子类在实例化过程中调用；</p><p>（4）抽象类也可以没有抽象方法，那么目的是不让你创建对象，让你创建它子类的对象</p><p>（5）抽象类的变量与它子类的对象也构成多态引用</p><p>5、不能和abstract一起使用的修饰符？</p><p>（1）final：和final不能一起修饰方法和类</p><p>（2）static：和static不能一起修饰方法</p><p>（3）native：和native不能一起修饰方法</p><p>（4）private：和private不能一起修饰方法</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>1、接口的概念</p><p>接口是一种标准。注意关注行为标准（即方法）。</p><p>面向对象的开发原则中有一条：面向接口编程。</p><p>2、接口的声明格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">interface</span> 接口名</span>&#123;</span><br><span class="line">    接口的成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、类实现接口的格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 实现类  <span class="keyword">implements</span> 父接口们</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 实现类 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 父接口们</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、接口继承接口的格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">interface</span> 接口名 <span class="keyword">extends</span> 父接口们</span>&#123;</span><br><span class="line">    接口的成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、接口的特点</p><p>（1）接口不能直接实例化，即不能直接new对象</p><p>（2）只能创建接口的实现类对象，那么接口与它的实现类对象之间可以构成多态引用。</p><p>（3）实现类在实现接口时，必须重写所有抽象的方法，否则这个实现类也得是抽象类。</p><p>（4）Java规定类与类之间，只能是单继承，但是Java的类与接口之间是多实现的关系，即一个类可以同时实现多个接口</p><p>（5）Java还支持接口与接口之间的多继承。</p><p>6、接口的成员</p><p>JDK1.8之前：</p><p>（1）全局的静态的常量：public static final，这些修饰符可以省略</p><p>（2）公共的抽象方法：public abstract，这些修饰符也可以省略</p><p>JDK1.8之后：</p><p>（3）公共的静态的方法：public static ,这个就不能省略了</p><p>（4）公共的默认的方法：public default，这个就不能省略了</p><p>7、默认方法冲突问题</p><p>（1） 当一个实现类同时实现了两个或多个接口，这个多个接口的默认方法的签名相同。</p><p>解决方案：</p><p>方案一：选择保留其中一个</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口名.<span class="keyword">super</span>.方法名(【实参列表】);</span><br></pre></td></tr></table></figure><p>方案二：完全重写</p><p>（2）当一个实现类同时继承父类，又实现接口，父类中有一个方法与接口的默认方法签名相同</p><p>解决方案：</p><p>方案一：默认方案，保留父类的</p><p>方案二：选择保留接口的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接口名.<span class="keyword">super</span>.方法名(【实参列表】);</span><br></pre></td></tr></table></figure><p>方案三：完全重写</p><p>8、示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> MAX_SPEED = <span class="number">7900000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9、常用的接口</p><p>（1）java.lang.Comparable接口：自然排序</p><p>​    抽象方法：int compareTo(Object obj)</p><p>（2）java.util.Comparator接口：定制排序</p><p>​    抽象方法：int compare(Object obj1 ,Object obj2)</p><p>（3）示例代码</p><p>如果员工类型，默认顺序，自然顺序是按照编号升序排列，那么就实现Comparable接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略了构造器，get/set,toString</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id - ((Employee)obj).id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在后面又发现有新的需求，想要按照薪资排序，那么只能选择用定制排序，实现Comparator接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalaryComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span></span>&#123;</span><br><span class="line">        Employee e1 = (Employee)o1;</span><br><span class="line">        Employee e2 = (Employee)o2;</span><br><span class="line">        <span class="keyword">if</span>(e1.getSalary() &gt; e2.getSalary())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e1.getSalary() &lt; e2.getSalary())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>1、内部类的概念</p><p>​    声明在另外一个类里面的类就是内部类。</p><p>2、内部类的4种形式</p><p>（1）静态内部类</p><p>（2）非静态成员内部类</p><p>（3）有名字的局部内部类</p><p>（4）匿名内部类</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>1、语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在匿名子类中调用父类的无参构造</span></span><br><span class="line"><span class="keyword">new</span> 父类()&#123;</span><br><span class="line">    内部类的成员列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在匿名子类中调用父类的有参构造</span></span><br><span class="line"><span class="keyword">new</span> 父类(实参列表)&#123;</span><br><span class="line">    内部类的成员列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口没有构造器，那么这里表示匿名子类调用自己的无参构造，调用默认父类Object的无参构造</span></span><br><span class="line"><span class="keyword">new</span> 父接口名()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、匿名内部类、匿名对象的区别？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> Student(<span class="string">"张三"</span>));<span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">Student stu = <span class="keyword">new</span> Student(<span class="string">"张三"</span>);<span class="comment">//这个对象有名字，stu</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//既有匿名内部类，又是一个匿名的对象</span></span><br><span class="line"><span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.test();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个匿名内部类的对象，使用obj这个名字引用它，既对象有名字，但是这个Object的子类没有名字</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3、使用的形式</p><p>（1）示例代码：继承式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//用父类与匿名内部类的对象构成多态引用</span></span><br><span class="line">        Father f = <span class="keyword">new</span> Father()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"用匿名内部类继承了Father这个抽象类，重写了test抽象方法"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        f.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）示例代码：实现式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//用父接口与匿名内部类的对象构成了多态引用</span></span><br><span class="line">        Flyable f = <span class="keyword">new</span> Flyable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"用匿名内部类实现了Flyable这个接口，重写了抽象方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        f.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）示例代码：用匿名内部类的匿名对象直接调用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用匿名内部类的匿名对象直接调用方法"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.test();</span><br></pre></td></tr></table></figure><p>（4）示例代码：用匿名内部类的匿名对象直接作为实参</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student[] all = <span class="keyword">new</span> Student[<span class="number">3</span>];</span><br><span class="line">all[<span class="number">0</span>] = <span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="number">23</span>);</span><br><span class="line">all[<span class="number">1</span>] = <span class="keyword">new</span> Student(<span class="string">"李四"</span>,<span class="number">22</span>);</span><br><span class="line">all[<span class="number">2</span>] = <span class="keyword">new</span> Student(<span class="string">"王五"</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用匿名内部类的匿名对象直接作为实参</span></span><br><span class="line"><span class="comment">//这个匿名内部类实现了Comparator接口</span></span><br><span class="line"><span class="comment">//这个匿名内部类的对象，是定制比较器的对象</span></span><br><span class="line">Arrays.sort(all, <span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Obeject o1, Object o2)</span></span>&#123;</span><br><span class="line">        Student s1 = (Student)o1;</span><br><span class="line">        Student s2 = (Student)o2;</span><br><span class="line">        <span class="keyword">return</span> s1.getAge() - s2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 外部类名  【<span class="keyword">extends</span> 外部类的父类】 【<span class="keyword">implements</span> 外部类的父接口们】</span>&#123;</span><br><span class="line">【其他修饰符】 <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  静态内部类 【<span class="keyword">extends</span> 静态内部类自己的父类】 【<span class="keyword">implements</span> 静态内部类的父接口们】</span>&#123;</span><br><span class="line">        静态内部类的成员列表;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">外部类的其他成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 使用注意事项</p><p>（1）包含成员是否有要求：</p><p>​        可以包含类的所有成员</p><p>（2）修饰符要求：</p><ul><li>​        权限修饰符：4种</li><li>​        其他修饰符：abstract、final</li></ul><p>（3）使用外部类的成员上是否有要求</p><ul><li>​        只能使用外部类的静态成员</li></ul><p>（4）在外部类中使用静态内部类是否有要求</p><ul><li>​        正常使用</li></ul><p>（5）在外部类的外面使用静态内部类是否有要求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）如果使用的是静态内部类的静态成员</span><br><span class="line">外部类名.静态内部类名.静态成员</span><br><span class="line">（<span class="number">2</span>）如果使用的是静态内部类的非静态成员</span><br><span class="line">①先创建静态内部类的对象</span><br><span class="line">外部类名.静态内部类名 对象名 = <span class="keyword">new</span> 外部类名.静态内部类名(【实参列表】);</span><br><span class="line">②通过对象调用非静态成员</span><br><span class="line">对象名.xxx</span><br></pre></td></tr></table></figure><p>（6）字节码文件形式：外部类名$静态内部类名.class</p><p>3、示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer.Inner.test();</span><br><span class="line">        </span><br><span class="line">        Outer.Inner in = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h3><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 外部类名  【<span class="keyword">extends</span> 外部类的父类】 【<span class="keyword">implements</span> 外部类的父接口们】</span>&#123;</span><br><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span>  非静态内部类 【<span class="keyword">extends</span> 非静态内部类自己的父类】 【<span class="keyword">implements</span> 非静态内部类的父接口们】</span>&#123;</span><br><span class="line">        非静态内部类的成员列表;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">外部类的其他成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 使用注意事项</p><p>（1）包含成员是否有要求：</p><p>​    不允许出现静态的成员</p><p>（2）修饰符要求</p><p>​    权限修饰符：4种</p><p>​    其他修饰符：abstract，final</p><p>（3）使用外部类的成员上是否有要求</p><p>​    都可以使用</p><p>（4）在外部类中使用非静态内部类是否有要求</p><p>​    在外部类的静态成员中不能使用非静态内部类</p><p>（5）在外部类的外面使用非静态内部类是否有要求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用非静态内部类的非静态成员</span></span><br><span class="line"><span class="comment">//(1)创建外部类的对象</span></span><br><span class="line">外部类名  对象名<span class="number">1</span> = <span class="keyword">new</span>  外部类名(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)通过外部类的对象去创建或获取非静态内部类的对象</span></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line">外部类名.非静态内部类名  对象名<span class="number">2</span> = 对象名<span class="number">1</span>.<span class="keyword">new</span> 非静态内部类名(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line">外部类名.非静态内部类名  对象名<span class="number">2</span> = 对象名<span class="number">1</span>.get非静态内部类对象的方法(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）通过非静态内部类调用它的非静态成员</span></span><br><span class="line">对象名<span class="number">2</span>.xxx</span><br></pre></td></tr></table></figure><p>（6）字节码文件形式：外部类名$非静态内部类名.class</p><p>3、示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">            System.out.println(j);<span class="comment">//可以</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">// Inner in = new Inner();//不可以</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        </span><br><span class="line">        Outer.Inner in1 = out.<span class="keyword">new</span> Inner();     <span class="comment">//创建   </span></span><br><span class="line">        in1.method();</span><br><span class="line">        </span><br><span class="line">        Outer.Inner in2 = out.getInner();<span class="comment">//获取</span></span><br><span class="line">        in2.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 外部类名  【<span class="keyword">extends</span> 外部类的父类】 【<span class="keyword">implements</span> 外部类的父接口们】</span>&#123;</span><br><span class="line">【修饰符】 返回值类型  方法名(【形参列表】)&#123;</span><br><span class="line">        【修饰符】 <span class="class"><span class="keyword">class</span>  局部内部类 【<span class="keyword">extends</span> 局部内部类自己的父类】 【<span class="keyword">implements</span> 局部内部类的父接口们】</span>&#123;</span><br><span class="line">        局部内部类的成员列表;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">外部类的其他成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 使用注意事项</p><p>（1）包含成员是否有要求</p><p>​    不允许出现静态的成员</p><p>（2）修饰符要求</p><p>​    权限修饰符：不能</p><p>​    其他修饰符：abstract、final</p><p>（3）使用外部类的成员等上是否有要求</p><p>​    ①使用外部类的静态成员：随便用</p><p>​    ②使用外部类的非静态成员：能不能用要看所在的方法是否是静态的</p><p>​    ③使用所在方法的局部变量：必须 final修饰的</p><p>（4）在外部类中使用局部内部类是否有要求</p><p>​    有作用域</p><p>（5）在外部类的外面使用局部内部类是否有要求</p><p>​    没法使用</p><p>（6）字节码文件形式：外部类名$编号局部内部类名.class</p><p>3、示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">                System.out.println(j);<span class="comment">//可以</span></span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> k = <span class="number">30</span>;</span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">                System.out.println(j);<span class="comment">//不可以</span></span><br><span class="line">                System.out.println(k);<span class="comment">//可以</span></span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象的基本特征</title>
      <link href="/2020/06/02/java-oop2/"/>
      <url>/2020/06/02/java-oop2/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象的基本特征"><a href="#面向对象的基本特征" class="headerlink" title="面向对象的基本特征"></a>面向对象的基本特征</h1><p>面向对象的基本特征：</p><p>1、封装</p><p>2、继承</p><p>3、多态</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><blockquote><p>封装是面向对象编程的核心思想。将对象的属性和行为封装起来，其载体就是类。类通常对客户隐藏其实现细节，这就是封装的思想。</p></blockquote><p>1、好处：</p><p>（1）隐藏实现细节，方便使用者使用</p><p>（2）安全，可以控制可见范围</p><p>2、如何实现封装？</p><p>通过权限修饰符</p><blockquote><p>面试题：请按照可见范围从小到大（从大到小）列出权限修饰符？</p></blockquote><table><thead><tr><th>修饰符</th><th>本类</th><th>本包</th><th>其他包的子类</th><th>任意位置</th></tr></thead><tbody><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>缺省(什么都不写)</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>权限修饰符可以修饰什么？</p><p>类（类、接口等）、属性、方法、构造器、内部类</p><p>类（外部类）：常用<code>public</code>和<code>缺省</code>修饰</p><p>属性：4种都可以</p><p>方法：4种都可以</p><p>构造器：4种都可以</p><p>内部类：4种都可以</p><p>3、通常属性的封装是什么样的？</p><p>当属性的权限修饰符可以是private、缺省、protected、public。但是我们大多数时候，见到的都是private，然后给它们配上get/set方法。</p><p>示例代码：标准Javabean的写法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性私有化</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> marry;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公共的get/set</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">        name = n;<span class="comment">//这里因为还没有学习this等，可能还会优化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMarry</span><span class="params">(<span class="keyword">boolean</span> m)</span></span>&#123;</span><br><span class="line">        marry = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMarry</span><span class="params">()</span></span>&#123;<span class="comment">//boolean类型的属性的get方法，习惯使用把get换成is</span></span><br><span class="line">        <span class="keyword">return</span> marry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>1、构造器的作用：<br>（1）和new一起使用创建对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用无参构造创建对象</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参构造创建对象</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名(实参列表);</span><br></pre></td></tr></table></figure><p>（2）可以在创建对象的同时为属性赋值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">        radius = r;<span class="comment">//为radius赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、声明构造器的语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 类名()&#123;<span class="comment">//无参构造</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    【修饰符】 类名(形参列表)&#123;<span class="comment">//有参构造</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、构造器的特点：</p><p>（1）所有的类都有构造器</p><p>（2）如果一个类没有显式/明确的声明一个构造器，那么编译器将会自动添加一个默认的无参构造</p><p>（3）如果一个类显式/明确的声明了构造器，那么编译器将不再自动添加默认的无参构造，如果需要，那么就需要手动添加</p><p>（4）构造器的名称必须与类名相同</p><p>（5）构造器没有返回值类型</p><p>（6）构造器可以重载</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">        radius = r;<span class="comment">//为radius赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键字this"><a href="#关键字this" class="headerlink" title="关键字this"></a>关键字this</h2><p>1、this关键字：</p><p>意思：当前对象</p><p>（1）如果出现在构造器中：表示正在创建的对象</p><p>（2）如果出现在成员方法中：表示正在调用这个方法的对象</p><p>2、this的用法：</p><p>（1）this.属性</p><p>​    当局部变量与成员变量同名时，那么可以在成员变量的而前面加“this.”用于区别</p><p>（2）this.方法</p><p>​    调用当前对象的成员方法，完全可以省略“this.”</p><p>（3）this()或this(实参列表)</p><p>​    this()表示调用本类的无参构造</p><p>​    this(实参列表)表示调用本类的有参构造</p><blockquote><p>this()或this(实参列表)要么没有，要么必须出现在构造器的首行</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、成员变量与局部变量的区别？</p><p>这里只讨论实例变量（关于类变量见static部分）</p><p>（1）声明的位置不同</p><p>成员变量：类中方法外</p><p>局部变量：方法中或代码中</p><p>​    ①方法的形参列表</p><p>​    ②方法体中局部变量</p><p>​    ③代码块中的局部变量</p><p>（2）运行时在内存中的存储位置不同</p><p>成员变量：堆</p><p>局部变量：栈</p><blockquote><p>基本数据类型的变量在栈中，引用数据类型的变量在堆中：不准确</p></blockquote><p>（3）修饰符</p><p>成员变量：有很多修饰符，例如：权限修饰符</p><p>局部变量：不能加权限修饰符，唯一的能加的是final</p><p>（4）初始化</p><p>成员变量：有默认值</p><p>局部变量：没有默认值，必须手动初始化</p><p>（5）生命周期</p><p>成员变量：随着对象的创建而创建，随着对象被回收而消亡，即与对象同生共死。每一个对象都是独立的。</p><p>局部变量：方法调用时才分配，方法运行结束就没有了。每一次方法调用，都是独立的</p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>1、包的作用：</p><p>（1）可以避免类重名</p><p>​    有了包之后，类的全名称就变为：包.类名</p><p>（2）分类组织管理众多的类</p><p>​    例如：java.lang包，java.util包，java.io包…..</p><p>（3）可以控制某些类型或成员的可见范围</p><p>​    如果某个类型或者成员的权限修饰缺省的话，那么就仅限于本包使用</p><p>2、声明包的语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>(1)必须在源文件的代码首行</p><p>(2)一个源文件只能有一个</p></blockquote><p>3、包的命名规范和习惯：<br>（1）所有单词都小写，每一个单词之间使用.分割<br>（2）习惯用公司的域名倒置</p><p>例如：com.alibaba.xxx;</p><blockquote><p>建议大家取包名时不要使用“java.xx”包，可能与java的核心包重复</p></blockquote><p>4、使用其他包的类：</p><p>​    前提：被使用的类或成员的权限修饰符是 &gt; 缺省的</p><p>（1）使用类型的全名称</p><p>​    例如：java.util.Scanner input = new java.util.Scanner(System.in);</p><p>（2）使用import 语句之后，代码中使用简名称</p><p>5、import语句</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 包.类名;</span><br><span class="line"><span class="keyword">import</span> 包.*;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>当使用两个不同包的同名类时，例如：java.util.Date和java.sql.Date。一个使用全名称，一个使用简名称</p><p>Java.lang包中的类可以不使用import语句，直接使用简名称</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.project.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>1、为什么要继承</p><ul><li>当多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。提高了代码的复用性。</li><li>继承的出现让类与类之间产生了关系，可以创建更为特殊的类型。</li><li>利于可维护性。<br>此处的多个类称为<strong>子类</strong>（派生类SubClass），单独的这个类称为<strong>父类</strong>（基类或超类SuperClass）。</li></ul><p><strong>继承的好处</strong></p><p>（1）代码的复用</p><p>（2）代码的扩展</p><p>2、如何实现继承？</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 子类  <span class="keyword">extends</span> 父类</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、继承的特点</p><p>（1）子类会继承父类的所有特征（属性、方法）</p><p>​    但是，私有的在子类中是不能直接使用的(可通过get/set间接使用)</p><p> <img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/inherit.png" alt="inherit"></p><p>（2）子类不会继承父类的构造器</p><p>​    因为，父类的构造器是用于创建父类的对象的</p><p>（3）子类的构造器中又必须去调用父类的构造器</p><p>​    在创建子类对象的同时，为从父类继承的属性进行初始化用，可以借助父类的构造器中的代码为属性赋值。</p><p>（4）Java只支持单继承：一个子类只能有一个“直接”父类</p><p>（5）Java又支持多层继承：父类还可以有父类，特征会代代相传</p><p>（6）一个父类可以同时拥有很多个子类</p><h2 id="关键字super"><a href="#关键字super" class="headerlink" title="关键字super"></a>关键字super</h2><p>super关键字：引用父类的xx，找父类的xx</p><p>用法：</p><p>（1）super.属性</p><p>​    当子类声明了和父类同名的成员变量时，那么如果要表示某个成员变量是父类的，那么可以加“super.”</p><p>（2）super.方法</p><p>​    当子类重写了父类的方法，又需要在子类中调用父类被重写的方法，可以使用”super.”</p><p>（3）super()或super(实参列表)</p><p>​    super()：表示调用父类的无参构造</p><p>​    super(实参列表)：表示调用父类的有参构造</p><blockquote><p>注意：</p><p>（1）如果要写super()或super(实参列表)，必须写在子类构造器的首行</p><p>（2）如果子类的构造器中没有写：super()或super(实参列表)，那么默认会有 super()</p><p>（3）如果父类没有无参构造，那么在子类的构造器的首行“必须”写super(实参列表)</p><p>（4）如果子类构造器中写了super(实参列表)，那么super()就不会存在</p></blockquote><h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p>1、方法的重写（Override）</p><p>当子类继承了父类的方法时，又觉得父类的方法体的实现不适合于子类，那么子类可以选择进行重写。</p><p>2、方法的重写的要求</p><p>（1）方法名：必须相同</p><p>（2）形参列表：必须相同</p><p>（3）修饰符</p><p>​    权限修饰符：子类方法的权限修饰符的可见性范围 &gt;= 父类被重写方法的权限修饰符的可见性范围</p><p>​        例如：</p><p>​                子类方法的权限修饰符是public，父类被重写的权限修饰符public</p><p>​                子类方法的权限修饰符是public，父类被重写的权限修饰符protected</p><p>（4）返回值类型</p><p>​    如果是基本数据类型和void：必须相同</p><p>​    如果是引用数据类型：要求子类重写的方法返回值类型 &lt;= 父类被重写的方法的返回值类型</p><p>​        例如：</p><p>​                子类方法的返回值类型是Student，父类被重写的返回值类型是Student</p><p>​                子类方法的返回值类型是Student，父类被重写的返回值类型是Person</p><p>​    在Java中我们认为，在概念范围上：子类 &lt; 父类</p><p>3、重载（Overload）与重写（Override）的区别</p><p>​    重载（Overload）：在同一个类中，方法名相同，形参列表不同，和返回值类型无关的两个或多个方法。</p><p>​    重写（Override）：在父子类之间。对方法签名的要求见上面。</p><p>特殊的重载：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOverload</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="comment">//b对象可以调用几个a方法</span></span><br><span class="line">b.a();</span><br><span class="line">b.a(<span class="string">""</span>);<span class="comment">//从b对象同时拥有两个方法名相同，形参不同的角度来说，算是重载</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非静态代码块"><a href="#非静态代码块" class="headerlink" title="非静态代码块"></a>非静态代码块</h2><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        非静态代码块</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、作用</p><p>目的：在创建的过程中，为对象属性赋值，协助完成实例初始化的过程</p><p>3、什么时候执行？</p><p>（1）每次创建对象时都会执行</p><p>（2）优先于构造器执行</p><h2 id="实例初始化过程"><a href="#实例初始化过程" class="headerlink" title="实例初始化过程"></a>实例初始化过程</h2><p>1、概念描述</p><ul><li><p>实例初始化过程：实例对象创建的过程</p></li><li><p>实例初始化方法：实例对象创建时要执行的方法</p></li><li><p>实例初始化方法的由来：它是有编译器编译生成的</p></li><li><p>实例初始化方法的形式：<init>()或<init>(形参列表)</p></li><li><p>实例初始化方法的构成：</p><p>①属性的显式赋值代码</p><p>②非静态代码块的代码</p><p>③构造器的代码</p><blockquote><p>其中</p><p>①和②按顺序执行，从上往下</p><p>③在①和②的后面</p></blockquote></li></ul><p>因此一个类有几个构造器，就有几个实例初始化方法。</p><p>2、单个类实例初始化方法</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"非静态代码块1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String str = assign();<span class="comment">//调用方法，来为str进行显式赋值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.str = str;</span><br><span class="line">System.out.println(<span class="string">"有参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"非静态代码块2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">assign</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"assign方法"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/initialization.png" alt="initialization"></p><p>3、父子类的实例初始化</p><p>注意：</p><p>（1）原先super()和super(实参列表)说是调用父类的构造器，现在就要纠正为调用父类的实例初始化方法了</p><p>（2）原先super()和super(实参列表)说是必须在子类构造器的首行，现在要纠正为必须在子类实例初始化方法的首行</p><p>结论：</p><p>（1）执行顺序是先父类实例初始化方法，再子类实例初始化方法</p><p>（2）如果子类重写了方法，通过子类对象调用，一定是执行重写过的方法</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ba</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String str = assign();</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"(1)父类的非静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Ba</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"(2)父类的无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">assign</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"(3)父类的assign()"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"ba"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Er</span> <span class="keyword">extends</span> <span class="title">Ba</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String str = assign();</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"(4)子类的非静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Er</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//super()  ==&gt;调用父类的实例初始化方法，而且它在子类实例初始化方法的首行</span></span><br><span class="line">System.out.println(<span class="string">"(5)子类的无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">assign</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"(6)子类的assign()"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"er"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Er();<span class="comment">//612645</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/initialization2.png" alt="initialization"></p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>1、多态：</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">父类 引用/变量 = 子类的对象;</span><br></pre></td></tr></table></figure><p>2、前提：</p><p>（1）继承</p><p>（2）方法的重写</p><p>（3）多态引用</p><p>3、现象：</p><p>​    编译时看左边/“父类”，运行时看右边/“子类”。</p><p>​    编译时，因为按父类编译，那么只能父类有的方法，子类扩展的方法是无法调用的；    </p><p>​    执行时一定是运行子类重写的过的方法体。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"走路"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"细嚼慢咽的吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"婀娜多姿走路"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shop</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"买买买..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"狼吞虎咽的吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"大摇大摆的走路"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"吞云吐雾"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Woman();<span class="comment">//多态引用</span></span><br><span class="line">        p.eat();<span class="comment">//执行子类重写</span></span><br><span class="line">        p.walk();<span class="comment">//执行子类重写</span></span><br><span class="line">        <span class="comment">//p.shop();//无法调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、应用：</p><p>（1）多态参数：形参是父类类型，实参是子类对象</p><p>（2）多态数组：数组元素类型是父类，元素存储的是子类对象</p><p>示例代码：多态参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> Woman());<span class="comment">//实参是子类对象</span></span><br><span class="line">        test(<span class="keyword">new</span> Man());<span class="comment">//实参是子类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Person p)</span></span>&#123;<span class="comment">//形参是父类类型</span></span><br><span class="line">      <span class="comment">// 相当于 Person p = new Woman() 或者 new Man() 形成多态</span></span><br><span class="line">        p.eat();</span><br><span class="line">        p.walk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：多态数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person[] arr = <span class="keyword">new</span> Person[<span class="number">2</span>];<span class="comment">//多态数组</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> Woman(); <span class="comment">// arr[0] 的类型为Person 形成多态</span></span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> Man();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            all[i].eat();</span><br><span class="line">            all[i].walk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、向上转型与向下转型：父子类之间的转换</p><p>（1）向上转型：自动类型转换</p><p>​    当把子类的对象赋值给父类的变量时（即多态引用时），在编译时，这个对象就向上转型为父类。此时就看不见子类“特有、扩展”的方法。</p><p>（2）向下转型：强制转换。有风险，可能会报ClassCastException异常。</p><p>​    当需要把父类的变量赋值给一个子类的变量时，就需要向下转型。</p><p>​    <strong>要想转型成功，必须保证该变量中保存的对象的运行时类型是 &lt;= 强转的类型</strong></p><p><strong>为什么要向上转型？</strong></p><p>​    因为多态数组、多态参数的应用场景，使得有的时候，不得不向上转型，这是为了方便统一管理各种子类的对象。</p><p><strong>为什么要向下转型?</strong></p><p>​    向下转型的目的是为了调用子类特有的方法等    </p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChineseWoman</span> <span class="keyword">extends</span> <span class="title">Woman</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//向上转型</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Woman();</span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line">Woman m = (Woman)p1; </span><br><span class="line"><span class="comment">//p1变量中实际存储的对象就是Woman类型，和强转的Woman类型一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向上转型</span></span><br><span class="line">Person p2 = <span class="keyword">new</span> ChineseWoman();</span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line">Woman w2 = (Woman) p2; </span><br><span class="line"><span class="comment">//p2变量中实际存储的对象是ChineseWoman类型，强制的类型是Woman，ChineseWoman&lt;Woman类型     </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、instanceof</p><p>表达式语法格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象/变量  <span class="keyword">instanceof</span>  类型</span><br></pre></td></tr></table></figure><p>运算结果：true 或 false</p><p>作用：</p><p>用来判断这个对象是否属于这个类型，或者说，是否是这个类型的对象或这个类型子类的对象</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChineseWoman</span> <span class="keyword">extends</span> <span class="title">Woman</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Woman w = <span class="keyword">new</span> Woman();</span><br><span class="line">        ChineseWoman c = <span class="keyword">new</span> ChineseWoman();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p <span class="keyword">instanceof</span> Woman)&#123;<span class="comment">//false</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(w <span class="keyword">instanceof</span> Woman)&#123;<span class="comment">//true</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c <span class="keyword">instanceof</span> Woman)&#123;<span class="comment">//true</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象基础</title>
      <link href="/2020/05/31/java-oop1/"/>
      <url>/2020/05/31/java-oop1/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象编程思想"><a href="#面向对象编程思想" class="headerlink" title="面向对象编程思想"></a>面向对象编程思想</h1><p>常见的编程思想有：</p><p><strong>面向过程（POP）编程思想</strong></p><p>面向过程POP（Process-Oriented Programming）强调的是系统的数据被加工处理的过程，数据仅仅作为输入和输出存在，在程序设计中主要以函数或者过程为程序的基本组织方式。</p><p>比如说，C语言中，数据与处理这些数据的函数是分离的，程序的最小单元是函数。</p><p><strong>面向对象（OOP）编程思想</strong></p><p>前辈们说，这样不好，应该把数据和与这些数据相关的行为放在一起，用一个叫做类的东西装起来。于是，在Java中，程序的最小单元变成了类。——这种思想叫做面向对象编程。</p><p>面向对象（Object Oriented Programming）是以<strong>对象</strong>为中心，将对象的内部组织与外部环境区别开来，将表征对象的内部属性数据与外部隔离开来，其行为与属性构成了一个整体，而系统功能则表现为一系列对象之间的相互作用的序列，能更加形象的模拟或表达现实世界。</p><p>当然，会使用Java语言并不代表已经领会了面向对象的思想。面向对象有三大特性：封装、继承、多态。封装有什么作用？封装时要注意什么？继承有什么优点和缺点？什么时候使用继承？多态有什么好处？什么时候使用多态？……这些问题的解答有一些指导原则，比如单一职责原则、里氏替换原则、开闭原则、接口隔离原则、依赖倒置原则等等。这些原则就是编程思想。</p><p>举个例子来说，你写了一个程序，现在用的是SQLServer的数据库，但客户说，将来也可能换成MySQL、Oracle数据库。那你可能就会考虑了：如何在现有的基础上，做最少的改动，就能从SQLServer换到MySQL、Oracle。于是，你就会开始想这些问题：如何能达到更少的变动？是否需要创建接口？在什么地方创建接口？接口中定义哪些方法？如何让调用者更方便地获取接口的实现类的对象？……这个，就是你的编程思想。就是那些原则在你的实践中的应用。</p><p>面向过程：POP: Process-Oriented Programming</p><p>​    以函数（方法）为最小单位</p><p>​    以过程，步骤为主，考虑怎么做</p><p>​    </p><p>面向对象：OOP: Object Oriented Programming</p><p>​    以类/对象为最小单位，类包括：数据+方法</p><p>​    以对象（谁）为主，考虑谁来做，谁能做</p><p>面向对象仍然包含面向过程，只不过关注点变了，关注谁来做</p><p>​    </p><p>程序员的角色：</p><p>面向过程：程序员是具体执行者</p><p>面向对象：程序员是指挥者</p><p>面向对象的开发过程：其实就是不断创造对象，使用对象，指挥对象做事情</p><p>面向对象的设计过程：就是管理和维护对象之间的关系</p><h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><p>类与对象是面向对象的核心概念：</p><p>类(class)：对现实生活中一类事物的描述，抽象的，也可以说类是对象的设计模板。</p><p>对象(object)：是实际存在的该类事物的每个个体，因而也称实例(instance)，是一个实实在在的个体，具体的</p><p>比如：</p><p>​    宝马、奥迪、奔驰、特斯拉、比亚迪…这些就可以抽取一个<code>车</code>的类。</p><p>​    颜色、轴长、价格…这些就是<code>车</code>类的属性。</p><p>​    驾驶、拉人、撩妹…这些就是<code>车</code>类的行为(方法)。</p><h2 id="如何声明类"><a href="#如何声明类" class="headerlink" title="如何声明类"></a>如何声明类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    成员列表：属性、方法、构造器、代码块、内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何创建对象"><a href="#如何创建对象" class="headerlink" title="如何创建对象"></a>如何创建对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名();  <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名(); <span class="comment">//有名对象</span></span><br></pre></td></tr></table></figure><h1 id="类的成员之一：属性"><a href="#类的成员之一：属性" class="headerlink" title="类的成员之一：属性"></a>类的成员之一：属性</h1><h2 id="如何声明属性"><a href="#如何声明属性" class="headerlink" title="如何声明属性"></a>如何声明属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 数据类型  属性名;    <span class="comment">//属性有默认值</span></span><br><span class="line">    【修饰符】 数据类型  属性名 = 值; <span class="comment">//属性有初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">car</span> </span>&#123;</span><br><span class="line">String color;</span><br><span class="line">  <span class="keyword">double</span> price;</span><br><span class="line">  <span class="keyword">double</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：属性的类型可以是Java的任意类型，包括基本数据类型、引用数据类型（类、接口、数组等）</p></blockquote><p><strong>总结：</strong></p><p>Java的数据类型</p><p>（1）基本数据类型</p><p>​        byte,short,int,long,float,double,char,boolean</p><p>（2）引用数据类型</p><p>​        ①类：</p><p>​            例如：String、Student、Circle、System、Scanner、Math…</p><p>​        ②接口：</p><p>​        ③数组：</p><p>​            例如：int[]，String[]，char[]，int[][]</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">这里把<span class="keyword">int</span>[]看成数组类型，是一种引用数据类型，右边赋值的是一个数组的对象</span><br><span class="line"></span><br><span class="line">元素的数据类型：<span class="keyword">int</span></span><br><span class="line">数组的数据类型：<span class="keyword">int</span>[]</span><br></pre></td></tr></table></figure><h2 id="如何为属性赋值"><a href="#如何为属性赋值" class="headerlink" title="如何为属性赋值"></a>如何为属性赋值</h2><ul><li>在声明属性时显式赋值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 数据类型  属性名 = 值; <span class="comment">//属性有初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">char</span> gender = <span class="string">'男'</span>;<span class="comment">//显式赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStudent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s1.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s1.gender);<span class="comment">//男</span></span><br><span class="line">        </span><br><span class="line">        s1.name = <span class="string">"小薇"</span>;<span class="comment">//修改属性的默认值</span></span><br><span class="line">        s1.gender = <span class="string">'女'</span>;<span class="comment">//修改属性的初始值</span></span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s1.name);<span class="comment">//小薇</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s1.gender);<span class="comment">//女</span></span><br><span class="line">        </span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s2.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s2.gender);<span class="comment">//男</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建对象之后赋值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 数据类型  属性名; <span class="comment">//属性有默认值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span>  类名();</span><br><span class="line"></span><br><span class="line"><span class="comment">//为对象的属性赋值</span></span><br><span class="line">对象名.属性名 = 值;</span><br></pre></td></tr></table></figure><p><strong>如何访问属性的值</strong></p><ul><li>在本类的方法中访问</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;<span class="comment">//直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在其他类的方法中访问</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCircle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Circle c1 = <span class="keyword">new</span> Circle();</span><br><span class="line">        <span class="keyword">double</span> area = <span class="number">3.14</span> * c1.radius * c1.radius;<span class="comment">//对象名.属性名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性的特点"><a href="#属性的特点" class="headerlink" title="属性的特点"></a>属性的特点</h2><ul><li><p>属性有默认值</p><p>基本数据类型：</p><p>​    byte,short,int,long：0</p><p>​    float，double：0.0</p><p>​    char：\u0000</p><p>​    boolean：false</p><p>引用数据类型：</p><p>​    null</p></li><li><p>每一个对象的属性是独立，互不干扰</p></li></ul><h2 id="对象属性的内存图"><a href="#对象属性的内存图" class="headerlink" title="对象属性的内存图"></a>对象属性的内存图</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">char</span> gender = <span class="string">'男'</span>;<span class="comment">//显式赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStudent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s1.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s1.gender);<span class="comment">//男</span></span><br><span class="line">        </span><br><span class="line">        s1.name = <span class="string">"小薇"</span>;</span><br><span class="line">        s1.gender = <span class="string">'女'</span>;</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s1.name);<span class="comment">//小薇</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s1.gender);<span class="comment">//女</span></span><br><span class="line">        </span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s2.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s2.gender);<span class="comment">//男</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/object.png" alt="object"></p><h1 id="类的成员之二：方法"><a href="#类的成员之二：方法" class="headerlink" title="类的成员之二：方法"></a>类的成员之二：方法</h1><h2 id="方法的概念"><a href="#方法的概念" class="headerlink" title="方法的概念"></a>方法的概念</h2><p>方法也叫函数，是一个独立功能的定义，是一个类中最基本的功能单元。</p><p>把一个功能封装为方法的目的是，可以实现代码重用，从而简化代码。</p><p>方法的使用原则：</p><p>（1）必须先声明后使用</p><p>​        类，变量，方法都要先声明后使用</p><p>（2）不调用不执行，调用一次执行一次。</p><h2 id="方法的语法"><a href="#方法的语法" class="headerlink" title="方法的语法"></a>方法的语法</h2><p><strong>方法的声明格式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 返回值类型  方法名(【形参列表】)&#123;</span><br><span class="line">        方法体：实现功能的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>（1）【修饰符】：</p><p>（2）返回值类型：</p><p>​        ①void：表示无返回值</p><p>​        ②非void：所有的Java数据类型都可以</p><p>（3）方法名：能很好的体现方法的功能</p><p>​        命名的规范：①见名知意②从第二个单词开始首字母大写</p><p>（4）【形参列表】：</p><p>​        在完成这个方法的功能时，需要一些数据，这些数据要由“调用者”来决定，那我们就可以设计形参。</p><p>​        语法格式：</p><p>​            ()：无参，空参</p><p>​            (数据类型  形参名)：一个形参</p><p>​            (数据类型1  形参名1,  ……,   数据类型n  形参名n)：n个形参</p><p>（5）方法体：实现方法的功能，最好一个方法就完成一个独立的功能。</p><p><strong>方法的调用格式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本类同级别方法调用：直接调用</span></span><br><span class="line">方法名(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在其他类的方法中调用</span></span><br><span class="line">对象名.方法名(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">如果方法有返回值，需要用变量接收</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>（1）是否传实参</p><p>​        看被调用的方法是否有形参</p><p>（2）是否接收返回值</p><p>​        看被调用的方法是否是void，如果是void，就不需要也不能接收，如果不是void，就可以接收。</p><p><strong>方法的声明与调用的代码示例</strong></p><ul><li>无参无返回值方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"半径："</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printInfo();<span class="comment">//本类中调用无参无返回值方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"半径："</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCircle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Circle c1 = <span class="keyword">new</span> Circle();</span><br><span class="line">        c1.printInfo(); <span class="comment">//其他类中调用无参无返回值方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无参有返回值方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//  System.out.println("半径：" + radius + "，面积：" + getArea());//本类中调用无参有返回值</span></span><br><span class="line">       <span class="keyword">double</span> area = getArea();<span class="comment">//本类中调用无参有返回值</span></span><br><span class="line">        System.out.println(<span class="string">"半径："</span> + radius + <span class="string">"，面积："</span> + area);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCircle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Circle c1 = <span class="keyword">new</span> Circle();</span><br><span class="line">        <span class="keyword">double</span> area = c1.getArea();</span><br><span class="line">        System.out.println(<span class="string">"面积："</span> + area);</span><br><span class="line">        <span class="comment">//或</span></span><br><span class="line">        System.out.println(<span class="string">"面积："</span> + c1.getArea());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有参无返回值方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicTools</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printRectange</span><span class="params">(<span class="keyword">int</span> line, <span class="keyword">int</span> column, <span class="keyword">char</span> sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=line; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=column; j++)&#123;</span><br><span class="line">                Sytem.out.print(sign);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printRectange(<span class="number">5</span>,<span class="number">10</span>,<span class="string">'%'</span>);<span class="comment">//本类中调用有参无返回值方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicTools</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printRectange</span><span class="params">(<span class="keyword">int</span> line, <span class="keyword">int</span> column, <span class="keyword">char</span> sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=line; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=column; j++)&#123;</span><br><span class="line">                Sytem.out.print(sign);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GraphicTools tools = <span class="keyword">new</span> GraphicTools();</span><br><span class="line">        tools.printRectange(<span class="number">5</span>,<span class="number">10</span>,<span class="string">'%'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有参有返回值方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">7</span>;</span><br><span class="line">        System.out.println(x + <span class="string">"+"</span> + y + <span class="string">"="</span> + sum(x,y));<span class="comment">//本类中调用有参有返回值的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyMath my = <span class="keyword">new</span> MyMath();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(x + <span class="string">"+"</span> + y + <span class="string">"="</span> + my.sum(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法声明与调用的原则</strong></p><p>（1）方法必须先声明后调用</p><blockquote><p>如果调用方法时，如果方法名写错或调用一个不存在的方法，编译会报错</p></blockquote><p>（2）方法声明的位置必须在类中方法外</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        方法<span class="number">2</span>()&#123;  <span class="comment">//错误</span></span><br><span class="line">        </span><br><span class="line">   &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    方法<span class="number">2</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）方法的调用的位置有要求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    调用方法  <span class="comment">//错误位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        调用方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）方法的调用格式要与方法的声明格式对应</p><p>​        ①是否要加“对象.”：看是否在本类中，还是其他类中</p><p>​        ②是否要接收返回值：看被调用方法是否是void</p><p>​        ③是否要传实参：看被调用方法是有形参列表</p><h2 id="方法的重载Overload"><a href="#方法的重载Overload" class="headerlink" title="方法的重载Overload"></a>方法的重载Overload</h2><blockquote><p>在同一个类中，出现了两个或多个的方法，它们的方法名称相同，形参列表不同，这样的形式称为方法的重载。和返回值类型无关。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求两个整数的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求三个整数的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(max(a,b),c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求两个小数的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法的参数传递机制"><a href="#方法的参数传递机制" class="headerlink" title="方法的参数传递机制"></a>方法的参数传递机制</h2><p>Java中方法的参数传递机制：值传递</p><p>（1）形参是基本数据类型时，实参给形参传递数据值，是copy的形式，形参对值的修改不影响实参。<br>（2）形参是引用数据类型时，实参给形参传递地址值，形参对对象的属性的修改，会影响实参对象的属性值，因为此时形参和实参就是指向同一个对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[] args)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">        swap(x,y);<span class="comment">//调用完之后，x与y的值不变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(MyData my)</span></span>&#123;</span><br><span class="line">        my.num *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyData m = <span class="keyword">new</span> MyData();</span><br><span class="line">        m.num = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        change(m);<span class="comment">//调用完之后，m对象的num属性值就变为2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p><strong>可变参数</strong></p><p>形参列表中出现了<code>数据类型... 形参名</code>形式的形参，就是可变参数</p><p><strong>包含可变参数的方法的调用原则</strong></p><p>可变参数的形参部分，可以传入0～n个对应类型的实参，也可以传入对应类型的数组对象</p><p><strong>可变参数的声明原则</strong></p><ul><li>一个方法只能包含一个可变参数</li><li>可变参数必须是形参列表的最后一个</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数传入个数0～n个</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VarParam</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 调用方式一创建数组传入</span></span><br><span class="line">    <span class="keyword">int</span>[] arr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    System.out.println(<span class="string">"0个元素的累加和："</span> + sum(arr1));<span class="comment">//0</span></span><br><span class="line">    <span class="keyword">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">"5个元素的累加和："</span> + sum(arr2));<span class="comment">//15</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用方式二传入不同个数的参数</span></span><br><span class="line">    System.out.println(<span class="string">"0个元素的累加和："</span> + sum());<span class="comment">//0</span></span><br><span class="line">    System.out.println(<span class="string">"1个元素的累加和："</span> + sum(<span class="number">3</span>));<span class="comment">//3</span></span><br><span class="line">    System.out.println(<span class="string">"0个元素的累加和："</span> + sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));<span class="comment">//15</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 可变参数nums当成数组用</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">      sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非可变参数"><a href="#非可变参数" class="headerlink" title="非可变参数"></a>非可变参数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数传入个数1～n个</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VarParam</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"1个元素的累加和："</span> + max(<span class="number">5</span>));<span class="comment">//5</span></span><br><span class="line">    System.out.println(<span class="string">"5个元素的累加和："</span> + max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>));<span class="comment">//8</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//求1～n个整数参数的最大值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span>... nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">// sum1就是非可变参数，至少传入一个参数</span></span><br><span class="line">    <span class="keyword">int</span> max = num1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(max &gt; num[i])&#123;</span><br><span class="line">        max = num[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h1><blockquote><p>元素类型是引用数据类型的数组称为对象数组。因为元素中存储的是对象。</p></blockquote><p>一维数组：</p><p>1、元素是基本数据类型</p><p>2、元素是引用数据类型，也称为对象数组，即数组的元素是对象</p><blockquote><p>注意：对象数组，首先要创建数组对象本身，即确定数组的长度，然后再创建每一个元素对象，如果不创建，数组的元素的默认值就是null，所以很容易出现空指针异常NullPointerException。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> year;</span><br><span class="line"><span class="keyword">int</span> month;</span><br><span class="line"><span class="keyword">int</span> day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyDate[] arr = <span class="keyword">new</span> MyDate[<span class="number">3</span>];<span class="comment">//创建数组对象本身，指定数组的长度</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> MyDate();<span class="comment">//每一个元素要创建对象</span></span><br><span class="line">            arr[i].year = <span class="number">1990</span> + i;</span><br><span class="line">            arr[i].month = <span class="number">1</span> + i;</span><br><span class="line">            arr[i].day = <span class="number">1</span> + i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象数组的内存图"><a href="#对象数组的内存图" class="headerlink" title="对象数组的内存图"></a>对象数组的内存图</h2><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.delivr.net/gh/uncle-he/blog-resource/img/object-array.png" alt="objectArray"></p>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/2020/05/31/java-array/"/>
      <url>/2020/05/31/java-array/</url>
      
        <content type="html"><![CDATA[<h1 id="数组的相关概念"><a href="#数组的相关概念" class="headerlink" title="数组的相关概念"></a>数组的相关概念</h1><h2 id="数组的相关概念-1"><a href="#数组的相关概念-1" class="headerlink" title="数组的相关概念"></a>数组的相关概念</h2><blockquote><p> 所谓<code>数组(Array)</code>，就是相同数据类型的元素按一定顺序排列的集合，就是把有限个类型相同的变量用一个名字命名，以便统一管理他们，然后用编号区分他们，这个名字称为<code>数组名</code>，编号称为<code>下标或索引(index)</code>。组成数组的各个变量称为数组的<code>元素(element)</code>。数组中元素的个数称为<code>数组的长度(length)</code>。</p></blockquote><p>例如：</p><p>​    int s1_score = 80; </p><p>​    int s2_score = 90; </p><p>​    int s3_score = 87; </p><p>​    …..</p><p>​    int[] scores = {80, 90, 87, 68, 99, 100, 79, 96};  </p><p>​    元素1：scores[0]=80; </p><p>​    数组的长度为8</p><h2 id="数组的特点"><a href="#数组的特点" class="headerlink" title="数组的特点"></a>数组的特点</h2><ul><li><p>数组的长度一旦确定就不能修改</p></li><li><p>创建数组对象会在内存中开辟一整块连续的空间。而数组名中引用的是这块连续空间的首地址。</p></li><li><p>遍历数组和获取某个元素的速度快，因为可以通过数组名+下标，直接定位到任意一个元素。</p></li></ul><h2 id="数组类型与数组元素的类型"><a href="#数组类型与数组元素的类型" class="headerlink" title="数组类型与数组元素的类型"></a>数组类型与数组元素的类型</h2><p>数组中的元素可以是任何数据类型，包括基本类型和引用类型</p><p>数组属引用类型，把数组看成对象(object)，数组中的每个元素相当于该对象的成员变量。</p><p>例如：</p><p>（1）基本数据类型元素的数组</p><p>​        int[] scores = {80, 90, 87, 68, 99, 100, 79, 96};</p><p>​        scores数组的类型是：int[]，元素的类型是int</p><p>​        scores是一个对象，scores[0],scores[1]等元素是scores对象的成员变量</p><p>（2）引用数据类型元素的数组</p><p>​        String[] strings = {“hello”,”java”,”world”,”array”};</p><p>​        strings数组的类型是：String[]，元素的类型是String</p><p>​        strings是一个对象，strings[0]，strings[1]等元素是strings对象的成员变量</p><h2 id="数组的分类"><a href="#数组的分类" class="headerlink" title="数组的分类"></a>数组的分类</h2><p>数组按照维度分为：一维数组、二维数组、多维数组</p><p>数组按照元素的数据类型分：基本数据类型元素的数据，引用数据类型元素的数组（也称为对象数组）</p><h1 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h1><h2 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h2><p>元素数据类型[] 数组名 = new 元素数据类型[]{元素1的值，元素2的值，….};</p><p>说明：</p><p>（1）静态初始化时数组的长度由{}中罗列的元素的个数决定</p><p>（2）静态初始化时[]中不可以再写长度</p><p>（3）如果声明与初始化一起，可以简写：</p><p>元素数据类型[] 数组名 = {元素1的值，元素2的值，….};</p><p>例如：</p><p>​    int[] arr = {1, 2, 3, 4, 5, 6};</p><p>​    String[] arr = {“hello”, ”java”, ”world”};</p><h2 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h2><p>元素数据类型 数组名 = new 元素数据类型[数组的长度];</p><p>说明：</p><p>（1）动态初始化时数组的长度在[]中指定，而且必须指定</p><p>（2）动态初始化时每一个元素有默认值</p><p>注意：</p><p>（1）无论是静态初始化还是动态初始化必须确定数组长度。</p><p>动态初始化在创建数组对象时，显式指明长度，静态初始化，由列出的元素个数确定数组的长度</p><p>（2）数组的长度一旦确定，不可改变</p><p>（3）只指定数组长度，没有为元素手动赋值，那么元素有默认值</p><ul><li><p>基本数据类型</p><p>byte,short,int,long：0</p><p>float,double：0.0</p><p>char：\u0000</p><p>boolean：false</p></li><li><p>引用数据类型</p><p>统统都是null</p></li></ul><p>（4）元素的数据类型是引用数据类型，在刚刚动态初始化后，元素的值是null，并没有创建元素的对象，元素的对象需要单独创建。</p><p>例如：</p><p>Student[] arr = new Student[3];</p><p>此时arr[i]为null，arr[i]并没有指向任何学生对象，此时arr[i].属性或arr[i].方法都会报空指针异常</p><p>String[] arr = new String[3];</p><p>此时arr[i]也为null，arr[i]中并没有存储任何字符串对象</p><h2 id="元素的访问与赋值"><a href="#元素的访问与赋值" class="headerlink" title="元素的访问与赋值"></a>元素的访问与赋值</h2><p>数组的元素表示方式：数组名[下标]</p><p>下标的范围是：[0,数组的长度)  或[0,数组的长度-1]</p><p>数组元素的赋值：数组名[下标] = 值;</p><p>例如：</p><p>nums[0] = 15;</p><p>students[1] = new Student(“大美女”);</p><h2 id="数组的长度"><a href="#数组的长度" class="headerlink" title="数组的长度"></a>数组的长度</h2><p>数组名.length</p><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><h3 id="普通for循环遍历"><a href="#普通for循环遍历" class="headerlink" title="普通for循环遍历"></a>普通for循环遍历</h3><p>for(int i = 0;  i&lt;数组名.length; i++) {</p><p>​    System.out.println(数组名[i]);</p><p>}</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增强for循环遍历"><a href="#增强for循环遍历" class="headerlink" title="增强for循环遍历"></a>增强for循环遍历</h3><p>for(元素的数据类型  变量名 : 被遍历的数组名) {</p><p>​    System.out.println(变量名);  //每循环一次，变量名代表一个元素</p><p>}</p><p>区别：</p><ul><li><p>普通for可以修改数组元素的值，增强for不行；</p></li><li><p>普通for可以获取下标信息，增强for没有下标信息；</p></li><li><p>仅遍历时增强for效率高</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">"孙悟空"</span>, <span class="string">"唐僧"</span> , <span class="string">"猪八戒"</span>, <span class="string">"沙悟净"</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String name : names) &#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的内存分析"><a href="#数组的内存分析" class="headerlink" title="数组的内存分析"></a>数组的内存分析</h2><p>数组对象是在堆中创建的，元素相当于数组对象的成员变量。创建数组对象会在堆中开辟连续的空间</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/array1.png" alt="array"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/array2.png" alt="array"></p><h1 id="数组的相关算法"><a href="#数组的相关算法" class="headerlink" title="数组的相关算法"></a>数组的相关算法</h1><h2 id="数组中找最值"><a href="#数组中找最值" class="headerlink" title="数组中找最值"></a>数组中找最值</h2><h3 id="数组中找最大-小值"><a href="#数组中找最大-小值" class="headerlink" title="数组中找最大/小值"></a>数组中找最大/小值</h3><p>思路：</p><p>（1）先假设第一个元素最大/最小</p><p>（2）然后用max/min与后面的元素一一比较</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//找最大值</span></span><br><span class="line"><span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">        max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组中找最值及其下表"><a href="#数组中找最值及其下表" class="headerlink" title="数组中找最值及其下表"></a>数组中找最值及其下表</h3><p>思路：</p><p>（1）先假设第一个元素最大/最小</p><p>（2）然后用max/min与后面的元素一一比较</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//找最大值</span></span><br><span class="line"><span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">        max = arr[i];</span><br><span class="line">        index = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//找最大值</span></span><br><span class="line"><span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; arr[maxIndex])&#123;</span><br><span class="line">        maxIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"最大值："</span> + arr[maxIndex]);</span><br></pre></td></tr></table></figure><h2 id="数组统计：求总和、均值、统计偶数个数等"><a href="#数组统计：求总和、均值、统计偶数个数等" class="headerlink" title="数组统计：求总和、均值、统计偶数个数等"></a>数组统计：求总和、均值、统计偶数个数等</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//求总和、均值</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//因为0加上任何数都不影响结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    sum += arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> avg = (<span class="keyword">double</span>)sum/arr.length;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求总乘积</span></span><br><span class="line"><span class="keyword">long</span> result = <span class="number">1</span>;<span class="comment">//因为1乘以任何数都不影响结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    result *= arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//统计偶数个数</span></span><br><span class="line"><span class="keyword">int</span> even = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        even++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反转"><a href="#反转" class="headerlink" title="反转"></a>反转</h2><ul><li>借助一个新数组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)先创建一个新数组</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)复制元素</span></span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newArr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[len -<span class="number">1</span> - i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)舍弃旧的，让arr指向新数组</span></span><br><span class="line">arr = newArr;<span class="comment">//这里把新数组的首地址赋值给了arr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首尾对应位置交换</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)计算要交换的次数：  次数 = arr.length/2</span></span><br><span class="line"><span class="comment">//(2)首尾交换</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length/<span class="number">2</span>; i++)&#123;<span class="comment">//循环的次数就是交换的次数</span></span><br><span class="line">    <span class="comment">//首  与  尾交换</span></span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[arr.length-<span class="number">1</span>-i];</span><br><span class="line">arr[arr.length-<span class="number">1</span>-i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p><strong>应用场景：</strong></p><ul><li>扩容</li><li>备份</li><li>截取</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要把arr数组扩容，增加1个位置</span></span><br><span class="line"><span class="comment">//(1)先创建一个新数组，它的长度 = 旧数组的长度+1</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)复制元素</span></span><br><span class="line"><span class="comment">//注意：i&lt;arr.length   因位arr比newArr短，避免下标越界</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)把新元素添加到newArr的最后</span></span><br><span class="line">newArr[newArr.length-<span class="number">1</span>] = 新值;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)如果下面继续使用arr，可以让arr指向新数组</span></span><br><span class="line">arr = newArr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 备份</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建一个长度和原来的数组一样的新数组</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、复制元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 截取</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> end = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建一个新数组，新数组的长度 = end-start + 1;</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[end-start+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、赋值元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newArr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[start + i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newArr.length; i++)&#123;</span><br><span class="line">    System.out.println(newArr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul><li>顺序查找</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] == value)&#123;</span><br><span class="line">        index = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(value + <span class="string">"不存在"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(value + <span class="string">"的下标是"</span> + index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>二分查找</p><p>对数组有要求，元素必须有大小顺序</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用二分查找法在数组中查找 int value = 2;是否存在，如果存在显示下标，不存在显示不存在。</span></span><br><span class="line"><span class="comment">已知数组：int[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam2</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;<span class="comment">//数组是有序的</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="comment">//找到结束</span></span><br><span class="line">            <span class="keyword">if</span>(value == arr[mid])&#123;</span><br><span class="line">                index = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//没找到</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; arr[mid])&#123;<span class="comment">//往右继续查找</span></span><br><span class="line">                <span class="comment">//移动左边界，使得mid往右移动</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value &lt; arr[mid])&#123;<span class="comment">//往左边继续查找</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(value + <span class="string">"不存在"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(value + <span class="string">"的下标是"</span> + index);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li>冒泡排序</li><li>简单的直接排序</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;<span class="comment">//外循环的次数 = 轮数 = 数组的长度-1</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第1轮，i=1,从左到右两两比较，arr[0]与arr[1]。。。。。arr[3]与arr[4]</span></span><br><span class="line"><span class="comment">    第2轮，i=2,从左到右两两比较，arr[0]与arr[1]。。。。。arr[2]与arr[3]</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    arr[j]与arr[j+1]比较</span></span><br><span class="line"><span class="comment">    找两个关键点：（1）j的起始值：0（2）找j的终止值，依次是3,2,1,0，得出j&lt;arr.length-i</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arr.length-i; j++)&#123;</span><br><span class="line">        <span class="comment">//两两比较</span></span><br><span class="line">        <span class="comment">//从小到大，说明前面的比后面的大，就交换</span></span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单的直接排序</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;<span class="comment">//外循环的次数 = 轮数 = 数组的长度-1</span></span><br><span class="line">    <span class="comment">//（1）找出本轮未排序元素中的最值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    未排序元素：</span></span><br><span class="line"><span class="comment">    第1轮：i=1,未排序，[0,4]</span></span><br><span class="line"><span class="comment">    第2轮：i=2,未排序，[1,4]</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    每一轮未排序元素的起始下标：0,1,2,3，正好是i-1的</span></span><br><span class="line"><span class="comment">    未排序的后面的元素依次：</span></span><br><span class="line"><span class="comment">    第1轮：[1,4]  j=1,2,3,4</span></span><br><span class="line"><span class="comment">    第2轮：[2,4]  j=2,3,4</span></span><br><span class="line"><span class="comment">    第3轮：[3,4]  j=3,4</span></span><br><span class="line"><span class="comment">    第4轮：[4,4]  j=4</span></span><br><span class="line"><span class="comment">    j的起点是i，终点都是4</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> max = arr[i-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> index = i-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;arr.length; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; max)&#123;</span><br><span class="line">            max = arr[j];</span><br><span class="line">            index = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（2）如果这个最值没有在它应该在的位置，就与这个位置的元素交换</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第1轮，最大值应该在[0]</span></span><br><span class="line"><span class="comment">    第2轮，最大值应该在[1]</span></span><br><span class="line"><span class="comment">    第3轮，最大值应该在[2]</span></span><br><span class="line"><span class="comment">    第4轮，最大值应该在[3]</span></span><br><span class="line"><span class="comment">    正好是i-1的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(index != i-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//交换arr[i-1]与arr[index]</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i-<span class="number">1</span>];</span><br><span class="line">        arr[i-<span class="number">1</span>] = arr[index];</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">System.out.print(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><p>二维数组的标记：[][]</p><h2 id="相关的表示方式"><a href="#相关的表示方式" class="headerlink" title="相关的表示方式"></a>相关的表示方式</h2><p>（1）二维数组的长度/行数： </p><p>​    二维数组名.length</p><p>（2）二维数组的其中一行：</p><p>​    二维数组名[行下标]</p><p>​    行下标的范围：[0, 二维数组名.length-1]</p><p>（3）每一行的列数：</p><p>​    二维数组名[行下标].length</p><p>​       因为二维数组的每一行是一个一维数组</p><p>（4）每一个元素</p><p>​    二维数组名[行下标][列下标]</p><h2 id="二维数组的声明和初始化"><a href="#二维数组的声明和初始化" class="headerlink" title="二维数组的声明和初始化"></a>二维数组的声明和初始化</h2><p>二维数组的声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐</span></span><br><span class="line">元素的数据类型[][] 二维数组的名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐</span></span><br><span class="line">元素的数据类型  二维数组名[][];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//不推荐</span></span><br><span class="line">元素的数据类型[]  二维数组名[];</span><br></pre></td></tr></table></figure><p>面试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] x, y[];</span><br><span class="line"><span class="comment">//x是一维数组，y是二维数组</span></span><br></pre></td></tr></table></figure><p>二维数组的初始化</p><p>（1）静态初始化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">二维数组名 = <span class="keyword">new</span> 元素的数据类型[][]&#123;</span><br><span class="line">&#123;第一行的值列表&#125;, </span><br><span class="line">&#123;第二行的值列表&#125;,</span><br><span class="line">...</span><br><span class="line">&#123;第n行的值列表&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] arr;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果声明与静态初始化一起完成</span></span><br><span class="line">元素的数据类型[][] 二维数组的名称 = &#123;</span><br><span class="line">&#123;第一行的值列表&#125;, </span><br><span class="line">&#123;第二行的值列表&#125;,</span><br><span class="line">...</span><br><span class="line">&#123;第n行的值列表&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>（2）动态初始化（不规则：每一行的列数可能不一样）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//（1）先确定总行数</span></span><br><span class="line">二维数组名 = <span class="keyword">new</span> 元素的数据类型[总行数][];</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）再确定每一行的列数</span></span><br><span class="line">二维数组名[行下标] = <span class="keyword">new</span> 元素的数据类型[该行的总列数];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)再为元素赋值</span></span><br><span class="line">二维数组名[行下标][列下标] = 值;</span><br></pre></td></tr></table></figure><p>（3）动态初始化（规则：每一行的列数是相同的）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//（1）确定行数和列数</span></span><br><span class="line">二维数组名 = <span class="keyword">new</span> 元素的数据类型[总行数][每一行的列数];</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）再为元素赋值</span></span><br><span class="line">二维数组名[行下标][列下标] = 值;</span><br></pre></td></tr></table></figure><h2 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;二维数组名.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;二维数组名[i].length; j++)&#123;</span><br><span class="line">        System.out.print(二维数组名[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">    System.out.print(arr[i][j]);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维数组的内存分析"><a href="#二维数组的内存分析" class="headerlink" title="二维数组的内存分析"></a>二维数组的内存分析</h2><p>（1）int[][] arr;</p><p>（2）arr = new int[5];</p><p>（3）arr[0] = new int[4];</p><p>（4）arr[0][1]= 12;</p><p>（5）int[][] arr = new int[4][5];</p><p>（6）Student[][]  arr = new Student[6][];</p><p>（7）arr[0] = new Student[8];</p><p>（8）arr[0][1] = new Student(“张三”,”10086”);</p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/2array1.png" alt="array"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/2array2.png" alt="array"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/2array3.png" alt="array"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/2array4.png" alt="array"></p><p><img src= data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs= data-src="https://cdn.jsdelivr.net/gh/uncle-he/blog-resource/img/2array5.png" alt="array"></p>]]></content>
      
      
      <categories>
          
          <category> 自学Java </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
